inżynierię oprogramowania
na czacie pojawiło się pytanie
o nagrywanie, proszę Państwa
ja nagrywam wykłady zgodnie
z poleceniem dziekana
i one będą dla Was
przez jakiś czas dostępne, zdaje się, że to jest
chyba okres trzech miesięcy
kiedy są dostępne
więc
zakładam, że odpowiedziałam
na pytanie
teraz, proszę Państwa, może zacznę
od
takich
spraw
organizacyjnych, czyli
pokażę Państwu
właśnie
ja wyłączę kamerę
już w tej chwili
no
dobrze
mam nadzieję, że mnie słychać
słychać, chciałabym jakiś odzyw
od Państwa usłyszeć
słychać i widać
dobra, gdyby się coś
bo czasem są jakieś problemy techniczne
w trakcie się zdarzają, więc
więc bardzo proszę wtedy o
jakąś informację
proszę Państwa, no zacznę
może od
właśnie tutaj pokazuję Państwu
stronę w UBI
gdzie widzicie Państwo, że dla tego przedmiotu
są udostępnione dokumenty
to są udostępnione
wszystkie prezentacje
wykładowe z zeszłego roku
one się jakoś tam troszkę pewnie będą
zmieniać, więc ja potem
no ewentualnie po wykładzie
jeżeli ten wykład będzie modyfikowany
to będę te nowe wersje umieszczać
zacznę może
od
konspektu, zaraz ja mam tutaj
ten konspekt już otwarty
zgodnie znowu z regułami
więc mamy proszę Państwa osiem
spotkań
tutaj jeśli chodzi o treści programowe
to one są wpisane tutaj, ale
w tej chwili niewiele
to Państwu mówi, więc ja to pominę
ja dzisiaj będę Państwu mówić
o tym czym się zajmuje inżynieria
oprogramowania, jakie ma cele i zadania
i przy okazji tego będę
Państwu również mówić czy ta
tematyka będzie poruszana na wykładzie
czy nie
jeśli chodzi o
literaturę, no to
no to proszę Państwa ja
nie zakładam, że będziecie Państwo
studiować jakieś
książki dodatkowe
jeżeli jesteście obecni na wykładzie
nie tylko powiedzmy
fizycznie, ale również
no jakoś uważacie
czy słuchacie tego co ja mówię
natomiast
tutaj chcę zwrócić uwagę Państwa
że te materiały, które
zobaczycie w UBI, które są udostępnione
no może poza dzisiejszym
wykładem to następne zajęcia
to one
mają takiego charakteru
jak to się mówi do self study
to będą proszę Państwa
tylko na przykład jakieś rysunki
prawie że bez komentarza
i te materiały
no nie nadają się
do takiej samodzielnego
uczenia się
one stanowią pewien materiał
ilustracyjny do wykładu
więc dlatego zachęcam Państwa
do jednak
uczestniczenia w wykładzie
więc mamy
jeśli chodzi o prawda materiały
to mamy te w UBI przygotowane prezentacje
teraz proszę Państwa
pewna część tego
wykładu będzie poświęcona
UML-owi, czyli
Unified Modeling Language
a więc takiemu językowi, który stanowi
standard modelowania obiektowego
i tutaj
proszę Państwa, jeśli chodzi o UML-a
jest bardzo, bardzo dużo różnych książek
jest bardzo
dużo materiałów w internecie
także
jest bardzo dużo złych materiałów w internecie
dotyczących UML-a
z bardzo poważnymi błędami
proszę Państwa, jeżeli
no szukacie czegoś
dotyczącego UML-a
to proszę jednak brać książki
w książkach też są błędy
ale nie ma ich aż tak dużo
dlatego, że książka zanim została wydana
no to tam miała przynajmniej
jakichś dwóch recenzentów, którzy
no powinni byli ją dobrze
przeczytać i ewentualnie
te błędy wyłapać i te błędy
powinny być skorygowane
a wiemy, że w internecie
no to można umieścić, każdy może umieścić
to, co mu się żywnie podoba
ja tutaj podaję jakieś dwie pozycje
w języku polskim, jest bardzo
dużo pozycji w języku angielskim
niektóre z nich są przetłumaczone
na język polski
natomiast istotne jest, żebyście
Państwo sięgając do
UML-a, to popatrzyli do
książki UML-u, popatrzyli
czy to jest UML wersji
2.coś
dlatego
że jest
no pewna liczba książek, które operują
używają UML-a w wersji
1. tam nie wiem
4 czy 7, a tutaj była
bardzo duża różnica, także proszę
zwrócić uwagę na to tam
gdzieś zwykle na drugiej czy trzeciej
stronie jest napisane jakiego UML-a
ta książka dotyczy
i tutaj
podaję dwie pozycje, które są
akurat w języku polskim
teraz
wiele takich rzeczy ogólnych dotyczących
inżynierii oprogramowania
znajdziecie Państwo w książce
doskonałe książki dotyczące
inżynierii oprogramowania
pisze chyba nadal
Profesor Jan Somerwil
z Lancaster University
niektóre z nich są dostępne
online, do niektórych z nich są dostępne
prezentacje, ja czasem
będę korzystać z niektórych slajdów
Profesora Somerwila i wtedy
na dole tego slajdu będzie
wyraźnie powiedziane, z której to
książki ten
slajd pochodzi.
Ponieważ właśnie ta książka
Software Engineering profesora Sommerbilla,
jedna z tych wydań została
przetłumaczona na język polski,
no to właśnie to jest książka,
którą on pisze od wielu, wielu
lat. Ma kolejne
wydania, w tej chwili już nie pamiętam,
które, czy to jest dziesiąte, czy jeszcze
jakoś wyżej. I proszę
Państwa, są bardzo duże
zmiany pomiędzy tymi wydaniami.
I
stara się po prostu tą dziedzinę
przedstawić
w takiej formie
aktualnej.
Teraz
ja z Państwem mam wykład
i na przykład właśnie, jak będę
Państwa uczyć tego UML-a,
no to będę musiała
Wam pokazać jakieś przykłady
i
te przykłady, również niektóre z nich
będą się pojawiały
właśnie w UBI.
Lub będziemy je po prostu
rysować w trakcie zajęć.
Teraz
jeśli chodzi o zaliczenie
tego przedmiotu, to odbywa się
na podstawie egzaminu. Egzamin jest
pisemny, egzamin się zwyczajowo
odbywa w insperze.
Na egzaminie jest do zdobycia 100 punktów
i 41 punktów, zgodnie
z regułami szkoły zalicza.
Dalej tutaj Państwo widzicie, jak
wygląda skala.
Powyżej 55
punktów jest
ocena 3,5,
potem 66, to jest
4 i tak dalej.
Czy do tych rzeczy organizacyjnych
może ktoś z Państwa ma jakieś pytania?
Uwagi.
Ten konspekt
oczywiście jest dostępny.
Jak Państwo
widzicie, jest udostępniony
w materiałach.
Nie słyszę,
nie widzę pytań, więc zakładam, że
wszystko jest jasne. Proszę
popatrzeć, tutaj mają Państwo taki
katalog, który się nazywa wykłady
i właśnie w tych
wykładach
są prezentacje,
z których ja będę
korzystać.
Natomiast teraz
jeszcze, skąd Państwo macie wiedzieć,
którą z tych prezentacji ja
używałam na wykładzie, prawda?
Więc ja mam obowiązek
wypełniania dziennika zajęć. Czy ten
dziennik zajęć jest dla Państwa dostępny?
Takie mam pytanie. Czy to widzicie, to co ja
tutaj wpisuję w dzienniku zajęć?
Wydaje mi się, że chyba nie,
ale...
Gdyby ktoś z Państwa
spróbował sprawdzić, czy
ja dzisiaj
coś już tam wpisałam w tym dzienniku,
czy...
Macie, czy nie?
Ja nic nie widzę.
Nie macie, ok, dobra. Proszę Państwa, w takim razie
zrobimy to w ten sposób, że ja
po każdych zajęciach...
Przepraszam? To znaczy, to jest
widoczne. Jak się wejdzie w UBI
u nas w informacje
o przedmiocie po prostu, to
jest widoczne, bo widzę dokładnie to, co Pani
napisała, czyli omówienie regulaminu i konspektu
i później, że
metody to wykładzony zdalnie.
Tak. Tak, że to jest
widoczne.
Tak. Dobrze. Proszę Państwa,
no dla tych, którzy do tego,
nie potrafią, czy nie wiedzą, jak
dojść, to ja będę robić taka rzecz,
która mnie niewiele pracy kosztuje.
Mianowicie po każdych zajęciach
ten dziennik zajęć będę
pobierać i będę
go po prostu tutaj Państwa
umieszczać w tych,
no w tych,
jak gdyby w tych...
Czyli tutaj się pojawi, również na tym
głównym poziomie pojawi się coś, co
się będzie nazywało, no pewnie dziennik zajęć
albo jakoś tak i będą kolejne
numery wykładów 1, 2, 3,
4, 5, więc tam na podstawie
tego będziecie Państwo widzieli,
które z tych prezentacji, które
w tym katalogu wykłady są, których
z tych prezentacji ja używałam.
Dobrze.
Czy do tego może ktoś z Państwa ma jakieś
pytania, uwagi?
Jeżeli nie,
no to w takim razie, proszę
Państwa, tak, zatrzymam
teraz udostępnianie tego
pliku.
Znaczy ten obraz
i proszę Państwa,
przejdę już teraz do
spraw merytorycznych,
chyba, że ktoś z Państwa ma jeszcze jakieś
pytania.
Nie słyszę.
Dobra, więc w takim razie, proszę
Państwa, przejdę do
już spraw
merytorycznych,
czyli no, zacznę od
opowiedzenia Państwu,
tak,
czym ogólnie zajmuje się inżynieria
oprogramowania, skąd
ona się wzięła, dlaczego
się jej uczymy i tak dalej.
Czyli właśnie,
jak powstała inżynieria oprogramowania,
jakie ma cele,
zadania, czym się
zajmuje
i tutaj przy okazji tego,
tego opowiadania, czym się zajmuje
inżynieria oprogramowania, będę
Państwu mówić, czy ta tematyka
będzie przeze mnie poruszana
na wykładzie, czy nie.
I
troszkę powiem, bo
porozmawiamy sobie na temat
oprogramowania wysokiej jakości.
Dlaczego?
No właśnie dlatego, że
produkcja takiego oprogramowania
jest właśnie celem inżynierii
oprogramowania, więc musimy wiedzieć,
co my tutaj rozumiemy jako
oprogramowanie wysokiej jakości.
Pierwsza sprawa,
skąd się wzięła inżynieria oprogramowania?
Otóż, proszę Państwa,
koniec lat sześćdziesiątych,
lata siedemdziesiąte,
to jest tak zwany kryzys
w oprogramowaniu.
Wiele projektów, które
wówczas realizowano,
po prostu
kończyło się fiaskiem.
Jednym z takich
projektów,
powszechnie znany, który właśnie
się nie udało zrealizować,
to był projekt systemu
Multix, który
no jak
się nazywało
Multix,
który w Bell Laboratories był realizowany
i był to
no jak na owe czasy
miał być to projekt systemu
operacyjnego, takiego, w którym
wiele osób mogło pracować,
równolegle. Lata sześćdziesiąte to jest,
proszę Państwa, to są
komputery, maszyny,
raczej, które, prawda, pracowały
w takim trybie beczowym,
a tu miał być
taki już system dostępny dla
użytkowników. I proszę Państwa,
jak zrobiono projekt,
to się okazało,
że czas realizacji tego
systemu byłby na tyle długi,
że jak ten system
by został doprowadzony
do takiej wersji, nazwijmy to,
sprzedaży,
to już był
nieaktualny, więc ten projekt
upadł. Ale proszę Państwa,
trzech dobrych programistów,
którzy przy tym projekcie
pracowało,
napisali
po prostu w asembleże
maszyny PDP-11
system operacyjny Unix.
On się początkowo nazywał troszeczkę
inaczej, inaczej było to pisane
i
no i chwała im za to, bo do
dnia dzisiejszego z tego Unixa
korzystamy. Czyli właśnie
na przykładzie tego systemu
chciałam Państwu
pokazać, że
w przypadku dużych projektów
często one się
kończyły klęską.
Kończyły się klęską dlatego,
że tak jak Państwu powiedziałem, to miał być
projekt zupełnie nowego systemu,
działającego na innych zasadach niż
te poprzednie. A więc
w owych czasach wiele tych
systemów, które wtedy zaczęto
produkować, to były systemy
nowe, jakieś zupełnie
nowe pomysły, były nowe
dziedziny zastosowań.
Nie było przykładów
poprzednich systemów, z których
można by było skorzystać.
Były to systemy bardzo złożone
i
nie bardzo było wiadomo, jak
organizować pracę
przy takich złożonych systemach
i w dodatku systemach,
w których, no,
które realizuje grupa ludzi.
I to jest właśnie przykład tego
systemu Multix, że coś
realizowane w dużym zespole
po prostu upadło. Natomiast
trzech programistów usiadło i
napisało ten system.
Właśnie nie było metod, nie było
narzędzi, które
pozwalały realizować
duże, złożone systemy
i przez zespoły
ludzkie. No i
to jest jak gdyby
jeden problem do tego
kryzysu w oprogramowaniu.
Druga sprawa to jest kwestia
kosztów, że wtedy
koszty produkcji oprogramowania
rosły liniowo,
tak jak tutaj Państwu podaję,
12% na rok.
No i
to ten przyrost, prawda,
no też
starano się coś z tym
zrobić, no bo wiadomo było,
że jeżeli, prawda, troszkę
ograniczymy ten szybki
wzrost cen oprogramowania,
kosztów produkcji oprogramowania,
to przyniesie to
po prostu korzyści
ekonomiczne. Natomiast, no, ceny
sprzętu spadały.
No i teraz, proszę Państwa,
właśnie,
przyczyny upadku wielu projektów.
Tak jak Państwu powiedziałam, duża
złożoność, nowe
dziedziny, do których te projekty
wchodziły. To, że to były
zwykle pierwsze projekty w danej
dziedzinie, a więc znowu nie było
dobrych przykładów, z których można by było
korzystać. Nie było wiadomości,
jak organizować taki
proces budowy złożonego
oprogramowania.
Nie bardzo potrafiono oceniać
stopień zaawansowania prac
programistycznych. Wydawało
się w owym czasie,
że
jeżeli, prawda,
jakiś kawałek programu napiszemy
w jeden dzień, powiedzmy, 100 linii,
wtedy, w tych latach 60-tych
programowano głównie w
assemblerach, czy
w portranie, no to,
coś, powiedzmy, co
będzie zawierało 10 tysięcy,
1000 linii, to napiszemy
w 10 dni i uruchomimy
w 10 dni. I to się okazało
nieprawdą. To, jak
Państwu mówię, no to były te problemy
końca lat 60-tych,
początek lat 70-tych,
ta pozorna łatwość
wykonywania i takie liniowe
szacowanie, ile to nam zajmie.
No i proszę Państwa, ja prowadząc
zajęcia projektowe
ze studentami od wielu lat, obserwuję, że
do dnia dzisiejszego, że, powiedzmy,
pierwszy projekt, który jest prosty,
to studenci zrobią w weekend,
tak, a drugi projekt z tego
samego przedmiotu, który jest znacznie bardziej
zaawansowany i oni są uprzedzeni
o tym, że on jest bardziej zaawansowany,
no to oni zakładają, że
skoro ten pierwszy napisali, powiedzmy,
w sobotę, no to ten bardziej złożony, to
napiszą w sobotę i niedzielę. No i często
niestety te założenia się nie
sprawdzają.
Także, proszę Państwa, to były te
przyczyny upadku wielu
projektów.
Te wysokie
koszty i ten liniowy
przyrost tych kosztów produkcji
oprogramowania, no
również powodował, że zaczęto
szukać jakichś takich
metod, żeby
te koszty produkcji
nie były aż tak wysokie.
Żeby je jakoś ograniczyć.
Dlatego, że widziano,
że to przyniesie od razu
korzyści ekonomiczne.
No i teraz, skąd brać
te pomysły?
I otóż, proszę Państwa, no popatrzono na
inne dziedziny inżynieryjne.
Czyli na przykład szukano
pomysłów u inżynierów
tak zwanych
civil engineering i
czyli takich, którzy się zajmują
budową dróg, mostów,
wiaduktów, jak
i u inżynierów mechaników
budujących złożone urządzenia
mechaniczne.
Ponieważ te dziedziny, tak jak Państwo
tutaj widzicie, zawierały
słowo engineering,
czyli właśnie ta inżynieria.
I z przodu miały słowo
określające, w jakiej
dziedziny to
należy,
do czego to dotyczy.
No to w ten sposób powstało
określenie software engineering.
Czyli wzięto to słowo engineering,
bo szukamy
jakiś metod, narzędzi,
wskazań produkcji
oprogramowania
więc z tego dodano
to słowo software.
I to, proszę Państwa, określenie
software engineering
zostało zaproponowane na
konferencji międzynarodowej
w końcu lat
siedemdziesiątych. Bardzo
się spodobało, zostało przyjęte
i jest
wykorzystywane, używane do
dnia dzisiejszego.
No i język polski może być ono
przetłumaczone właśnie
jako inżynieria oprogramowania.
Można,
używa się również określenia technologia
produkcji oprogramowania,
ale to określenie inżynieria oprogramowania
jest bardzo dobrym określeniem
istniejącym do dnia
dzisiejszego i używanym
do dnia dzisiejszego.
Także
wiemy już teraz skąd się wzięła
nazwa, tak, skąd się wzięło
sam jak gdyby
problem powstania
tej dziedziny.
No, powstała ona pod
koniec lat siedemdziesiątych,
czy w połowie lat siedemdziesiątych
mniej więcej. Jest to, proszę Państwa,
dziedzina, która się bardzo szybko
rozwija.
Więc, więc właśnie.
No to popatrzmy teraz na to, jakie
są cele
tej inżynierii oprogramowania.
Czyli, powiedziałam Państwu,
jakie były problemy, więc
szukano rozwiązania tych problemów.
Czyli szukano
metod,
technik,
produkcji programów.
No, takich,
żeby ta produkcja kończyła się
sukcesem,
ale jednocześnie chodziło o to,
żeby ten program,
który my wyprodukujemy, był
programem wysokiej jakości.
O tym, co to, co
rozumiemy przez tą wysoką jakość
oprogramowania, to ja jeszcze dzisiaj
o tym będę mówić.
Mówiłam Państwu
o tych wysokich kosztach i o
tym, że tutaj ten taki cel
ekonomiczny też był.
Ograniczenie kosztów produkcji
oprogramowania, czy zwolnienie
tempa przyrostu tych
kosztów. Czyli chodzi o to,
żeby ta produkcja,
żebyśmy produkowali oprogramowanie
wysokiej jakości, dobre
oprogramowanie, ale
również, żeby
ta produkcja
była efektywna.
No właśnie. No i teraz
zastanówmy się, co to
znaczy, że oprogramowanie jest
wysokiej jakości. I tu bym chciała, żebyście
Państwo spróbowali powiedzieć,
co Wy
odbieracie, czy co dla
Was jest istotne w oprogramowaniu
wysokiej jakości.
Jakie cechy takie
oprogramowanie, dobre oprogramowanie
wysokiej jakości według
Was powinno spełniać?
Wydaje mi się, że niska
awaryjność.
Niskie co?
Niska awaryjność.
Świetnie. Nie ma błędów
za bardzo. Dobrze. Proszę
Państwa, ja jeszcze tutaj
no, będę Państwa
pewnie nie tylko dzisiaj prosiła
o takie włączanie się do
wykładu. I w
przypadku właśnie takich, no
nazwijmy to
merytorycznych
odpowiedzi z Państwa strony,
będę chciała, żebyście Państwo
notowali to na
czacie. Te
osoby, które będą mi
tutaj pomagały w trakcie wykładu
właśnie
odpowiadając na moje
pytania, czy rozwiązując
jakieś zadania, to
ja będę sobie to notowała
plusikami,
które na koniec semestru
przejdą w punkty
dodatkowe. Takie zupełnie
poza tymi
dwa punktami, które w trakcie egzaminu
będziecie mogli zdobyć. No
i te punkty dodatkowe maksymalnie
może, będzie ich
maksymalnie do dziesięciu.
No to widzieliście Państwo,
że takie punkty dodatkowe mogą
Wam podnieść ocenę o pół stopnia.
Jak pokazywałam tą
skalę ocen. Także
no, może
się Państwu opłacić po prostu takie
odzywanie się w trakcie wykładu.
Także bardzo proszę Pana, żeby Pan się
swoje nazwisko tam, znaczy po prostu, żeby Pan
na czacie się
zameldował, że Pan coś powiedział.
Dobra, a ktoś z Państwa może ma
jakieś inne pomysły?
Wydaje mi się, że
wieloplatformowość, że
na różne systemy operacyjne.
Dobra, to jest Pana punkt widzenia.
A ktoś ma jakiś inny pomysł?
Wygodę użytkowania?
Super, dobrze. Co jeszcze?
Dobra dokumentacja.
No to jest Pana punkt widzenia.
Powiedzmy, ok.
Wydajność tego oprogramowania.
Właśnie, dobrze.
Wydajność oprogramowania.
Dobra, czy może coś jeszcze ktoś z Państwa ma jakieś
pomysły?
Bezpieczeństwo.
Dobrze.
Szyfrowanie danych.
No to
możemy to
podpiąć, prawda, pod sprawy związane
z bezpieczeństwem, prawda?
Że chodzi nam o to, żeby te dane były
bezpieczne, nie ujawniane. A to już
to szyfrowanie, to czy tam jakaś
inna metoda, no to jest pewien sposób
techniczny, jak tą cechę
bezpieczeństwa zrealizować.
Dobra, no to
fajnie, że tutaj Państwo
macie jakieś swoje pomysły.
Teraz
proszę Państwa, tak.
Ja tutaj napisałam, że
oprogramowanie wysokiej jakości
to jest oprogramowanie,
które działa zgodnie
z wymaganiami określonymi
przez specyfikację.
Specyfikacja
ma określać,
o tym też jeszcze będę mówić
trochę później na kolejnych zajęciach,
co robi to
oprogramowanie, przy jakich
ograniczeniach ma te swoje
funkcje realizować.
Czyli można powiedzieć,
że tak, jeżeli w specyfikacji
zapiszemy, co chcemy, żeby to
oprogramowanie robiło i jak
się zachowywało, jakie ograniczenia
spełniało,
no to takie oprogramowanie wysokiej
jakości, prawda, powinno właśnie
tak działać, jak myśmy to
napisali w tej specyfikacji.
Oczywiście pod warunkiem, że
ta specyfikacja została dobrze
przygotowana.
Teraz proszę Państwa
to, co żeście tutaj Państwo
podawali, czyli właśnie,
że jest szybkie,
że jest wydajne,
że jest funkcjonalne
tak, jak tego oczekuje użytkownik,
że ma te funkcje,
które są
przydatne użytkownikowi, które
on by chciał mieć.
Ja tutaj, jeśli chodzi o szybkość,
wydajność oprogramowania
te sprawy bezpieczeństwa,
o których Państwo żeście mówili,
to zawsze to musi być widziane
z punktu widzenia
użytkownika. Dlatego, że możemy
mieć bardzo różne kategorie
użytkowników i coś, co dla jednej
kategorii będzie oprogramowaniem
szybkim, to użytkownik
z innej kategorii może
się denerwować, że to jednak wolno
działa, prawda, i że to nie jest to, co on
by chciał, czy jak by chciał.
Także, jak gdyby, musi spełniać
oczekiwania użytkownika.
No i proszę Państwa,
tutaj jeszcze
taka rzecz, o której
Państwo żeście akurat dzisiaj
nie wspomnieli, mianowicie
jest to oprogramowanie,
które daje się łatwo
pielęgnować, chociaż tutaj
jeden z Panów chyba
powiedział, że powinno mieć dobrą
dokumentację. No i to pielęgnowanie
oprogramowania, no w zasadzie
jest możliwe wtedy, kiedy jednak jakaś
dokumentacja do tego oprogramowania istnieje.
Pielęgnować, to znaczy
to, może lepsze słowo jest
angielskie maintenance,
czyli takie utrzymanie
tego oprogramowania
i tutaj rozumiemy
dwie czynności. Po pierwsze,
korekcja błędów,
które na pewno
wystąpią w trakcie pracy tego
oprogramowania, poprawienie tego, co
wyszło w trakcie
pracy, a druga
rzecz, to jest modyfikacja,
adaptacja do
zmieniających się
warunków,
no środowiska, do
zmieniających się oczekiwań
użytkownika.
Jest to odporne na zero day'a.
Dobra.
Teraz
czyli właśnie,
musi się dać pielęgnować.
Dlaczego
to jest istotne?
No na przykład dlatego,
że mówiłam o tym, że to oprogramowanie,
no dzisiaj może te koszty nie
rosną już w sposób liniowy,
ale jednak też trochę
rosną,
że jeżeli robimy
oprogramowanie dla, nie wiem,
jakiegoś konkretnego klienta,
dla jakiejś firmy i ta firma
wyda duże pieniądze
na zakup tego oprogramowania,
to będzie chciała to oprogramowanie
używać przez
wiele lat. Wobec tego w trakcie
pracy, prawda, musimy
mieć możliwość dostosowania
tego oprogramowania do jednak
zmian, które występują
czy w prawie, czy w środowisku,
czy w oczekiwaniach tego użytkownika.
I stąd
te koszty modyfikacji
oczywiście
maintenance'ów w miarę upływu czasu
użytkowania tego oprogramowania,
one rosną, no ale chodzi o to, żeby jednak
jakieś te poprawki i adaptacje
dało się wykonać.
No właśnie,
no i tutaj
musimy mieć
musimy mieć
dokumentację projektową,
która właśnie
pozwoli nam te poprawki
na przykład wprowadzić, prawda, błędy
poprawić i ewentualnie
zmienić to oprogramowanie,
dostosować je do zmieniających się
czy
warunków prawnych,
czy systemów, które
się pojawiły na
rynku, prawda, może być
nowe systemy operacyjne, z którymi to
musi współpracować.
Więc musimy mieć jednak jakąś tam
dokumentację
projektową, która
pozwoli nam na te
czynności.
Teraz, proszę Państwa, mówiąc
o tym kryzysie
w produkcji oprogramowania
w końcu lat
sześćdziesiątych, wspomniałam,
że no ten
ten
systemy, które wówczas
nie dawało się zrealizować sukcesem,
to były systemy
tworzone przez grupy ludzi,
no właśnie dlatego, że
nie było pewnych metod, nie było
narzędzi, nie było metod, które
pozwalałyby pracę
takiego zespołu organizować.
Wobec
tego można powiedzieć tak,
że ta inżynieria oprogramowania
dotyczy, przede wszystkim
dotyczy oprogramowania tworzonego
przez zespoły.
Ale to nie oznacza,
że jeżeli
na przykład ktoś z Państwa realizując
swoją pracę dyplomową
będzie przy
realizacji tej pracy
stosował zasady, metody,
narzędzia inżynierii oprogramowania,
no to można powiedzieć, że
to tylko wyjdzie na dobre
tej pracy, ale
w przypadku jakiejś
tam aplikacji, systemów
wpisanych przez jedną, dwie, trzy
osoby, no to nie jest to aż tak
bardzo krytyczne. Dobrze byłoby
jednak z tego korzystać, ale
nie jest to nieodzowne.
W przypadku, kiedy
jakieś oprogramowanie jest realizowane
przez większy zespół osób,
no nawet już te pięć, sześć osób,
to w zasadzie bez pewnych narzędzi,
metod, technik inżynierii
oprogramowania, no taki
system jest
no trudno,
żeby się udał.
A więc
dotyczy
oprogramowania tworzonego przez zespoły,
ale pojedyncze osoby
też na pewno
na korzyść temu, co robią, jeżeli
będą te metody, techniki, narzędzia
stosować, to to tylko
będzie dobrze.
Teraz, proszę Państwa,
wspomniałam o tych,
że
potrzebne nam są
pewne narzędzia,
metody, środowiska,
więc inżynieria
oprogramowania zawiera
tak zwane aspekty techniczne, prawda?
Tutaj będziemy właśnie szukać
metod projektowania
systemów,
testowania systemów,
tu będą różnego rodzaju narzędzia,
które nam w tym pomagają,
ale skoro mamy do czynienia
z grupą ludzi, zespołem,
to musimy brać pod uwagę
pewne aspekty nietechniczne,
no wynikające
z relacji
pomiędzy tymi członkami
zespołów z naszych
charakterów, naszych możliwości
i tak dalej.
Ja w trakcie wykładu
będę
zajmowała się
aspektami technicznymi, bo tak jak Państwo
widzieliście tam na pierwszym
slajdzie, ja jestem inżynier,
więc
to mnie interesuje
i o tym coś jestem w stanie
powiedzieć, natomiast
w ciągu 15 minut
zasygnalizuję Państwu
pewne problemy, które właśnie
występują,
pewne aspekty nietechniczne
i pewne problemy z tym związane.
Teraz
mówiąc o tym, jak powstała
inżynieria oprogramowania, widzieliście Państwo,
że jak gdyby to
u jej podstaw
jest
pewne problemy związane
z realizacją konkretnych systemów,
czyli takie podejście praktyczne
i o wykorzystanie
pewnych metod, pomysłów
z innych dziedzin inżynieryjnych, też właśnie
te dziedziny inżynieryjne
dają nam podejścia praktyczne.
Więc
mamy te podejścia praktyczne,
ale mamy tutaj
również pewne podejścia formalne,
dlaczego
one się pojawiły i jakie
są ich wady i zalety,
to o tym
na jednym z wykładów Państwu troszkę
powiem.
O formalnych metodach specyfikacji
takich, że ze specyfikacji można
generować kod. Ale głównie
będziemy jednak się koncentrować
na tych podejściach praktycznych.
No dobrze,
to mniej więcej wiemy
czym się,
jakie są cele tej inżynierii
oprogramowania, czego ona dotyczy
i
teraz popatrzmy
co ona nam daje.
A więc
właśnie,
daje nam techniki,
daje nam narzędzia,
które pozwalają
nam projektować
i realizować
złożone systemy.
No i tak jak Państwu wspomniałam,
takie systemy realizowane przez
grupy
ludzi, prawda?
Więc nie tylko pojedyncze osoby,
ale i grupy ludzi.
Te narzędzia,
które pomagają nam
w realizacji tych systemów,
właśnie
przy projektowaniu, przy wykonaniu
przy testowaniu tych systemów
są tutaj
bardzo istotne.
I one zazwyczaj są związane
z pewną konkretną techniką
czy metodą.
Teraz proszę Państwa,
mówiąc o tych problemach
z realizacją projektów
no tam
w tych latach
70-tych, mówiłam Państwu,
że nie bardzo potrafiono wtedy
organizować
właśnie produkcję oprogramowania
przez grupę ludzi.
Że nie bardzo potrafiono
oszacować
ile czasu
będzie trwała ta produkcja,
ile wysiłku
potrzeba, żeby ten system
zrealizować.
Więc takie metody
techniki też
się tutaj w inżynierii
oprogramowania pojawiły.
Ja już dzisiaj
zacznę Państwu troszkę o tym
opowiadać, bo tutaj
w tym dzienniku zanim się wpisałam,
że dzisiaj zacznę Państwu mówić
o modelach procesu produkcji
oprogramowania. Czyli właśnie
o pewnym usystematyzowaniu
tego procesu produkcji oprogramowania
tak, żeby
można było planować
to, żeby można było
szacować ile czasu
potrzeba na wykonanie
poszczególnych czynności,
na wykonanie całego projektu.
Czyli mamy tutaj różne też
narzędzia i techniki, które nam
pozwalają to produkcję
oprogramowania jakoś organizować.
Teraz
kolejna rzecz, to jest
proszę Państwa,
jak podchodzimy do produkcji
jakiegoś
systemu,
no to jest to dla nas
problem nieznany, prawda? My nie
znamy tej dziedziny na ogół, w której
ten system ma działać, więc
jak gdyby tutaj przy produkcji
oprogramowania ciągle mamy
problemy z tym, że
napotykamy się na
zupełnie nowe dla nas
problemy, nowe zadania.
No i tutaj w inżynierii
oprogramowania też
zobaczycie Państwo są metody, które
jakoś tam nam troszkę
podpowiadają, w jaki sposób
to robić, jak to
realizować, jak podchodzić
do tych problemów.
To jest jak gdyby jedna sprawa. Druga
sprawa to jest proszę Państwa to,
żebyśmy maksymalnie wykorzystywali
to, co już mamy,
czy jeśli
chodzi o nasze doświadczenia
w produkcji oprogramowania,
w projektowaniu oprogramowania,
w testowaniu oprogramowania,
jak i również
te oprogramowania,
czy ten kod, który już żeśmy
wcześniej stworzyli, też
żeby to maksymalnie
wykorzystywać. Także tutaj o tym
też będę troszkę
mówić.
No dobra, no to popatrzmy
teraz
czym zajmuje się
inżynieria oprogramowania.
A więc właśnie sposobami
prowadzenia przedsięwzięć
informatycznych. I na ten
temat ja Państwu mówić tutaj nie będę,
bo
Mówiłam Państwu, że to był jeden z problemów właśnie
w te ileś lat wstecz, że źle oceniano, czy nie potrafiło się oprogramować.
No,
oszacować ile wysiłku,
ile pieniędzy będzie kosztowała
produkcja oprogramowania.
O technikach szacowania kosztów produkcji
oprogramowania ja jeden
wykład będę
miała. Jeśli
chodzi o harmonogramowanie, czyli
właśnie określenie
tutaj jak gdyby w
czasie, prawda, kiedy co ma być
robione. Na temat harmonogramowania
nie będę Państwu mówiła,
bo wiem, że jest to poruszane
na innym
przedmiocie, który macie w programie
studiów.
Metody analizy i projektowania
systemów. To proszę Państwa
będzie no jak gdyby
zasadnicza część
tych 32 godzin
wykładu. W tej chwili trudno
mi powiedzieć jak gdyby tak oszacować
ile, ale
no ale tak na oko mniej więcej
połowa to będzie właśnie tego dotyczyło.
Teraz
oprogramowanie dobrej jakości,
wysokiej jakości
i tutaj
któryś z Panów
rzucił takie hasło, że
no to powinno być, prawda,
oprogramowanie takie bezawaryjne,
poprawnie działające.
Otóż też troszkę Państwu powiem,
po pierwsze powiem o tym jakie są
kiedyś na jednym
podkoniowym programie,
na którym
jakie są kiedyś na jednym
pod koniec semestru,
jakie są miary niezawodności
oprogramowania i w jaki sposób
można je zwiększać. Także
jakieś dwie godziny
wykładu na ten temat będą.
Co dalej?
Inżynieria oprogramowania
zajmuje się również metodami
testowania systemów.
Testowanie proszę Państwa
jest bardzo szeroką dziedziną
i spokojnie można by
przygotować wykład
trzydziestodwugodzinny, który dotyczy
tylko i wyłącznie testowania systemów.
Ja pewnie,
nie wiem, no pewnie cztery godziny
wykładu może troszkę więcej na ten temat
poświęcę.
Szacowania
niezawodności oprogramowania.
Właśnie opowiem Państwu
na jednym z wykładów pod koniec semestru
o miarach niezawodności
oprogramowania
i również o tym w jaki sposób się
mierzy te wartości
i również w jaki sposób
się szacuje.
Ponieważ zobaczycie Państwo,
że tutaj
zwiększanie tych wartości
niezawodności systemu
wiąże się z
rosnącymi kosztami produkcji.
Chodzi o to, aby zatrzymać się
na takim poziomie niezawodności,
który jest akceptowany w danym systemie.
Bo kolejne zwiększanie
tej niezawodności znacznie wzrasta
koszty.
Teraz
mówiłam Państwu o tym, że
no właśnie na przykład po to, żeby utrzymywać
to oprogramowanie, a niektóre
z oprogramowania działa przez wiele lat,
no to potrzebujemy
mieć dobrą dokumentację
techniczną,
dobrą dokumentację ewentualnie również
użytkową, czy jakąś pomoc dla
użytkownika. Na temat
dokumentacji ja Państwu mówić
nie będę. Dla
tego, że po pierwsze
jeśli chodzi o sprawy dokumentacji,
to jeżeli Państwo pracujecie
w jakichś firmach, to często w każdej
z takich firm są, że tak powiem, inne
standardy, zwyczaje,
formaty, jak to się powinno robić.
Także na ten temat nie
będę Państwu mówić na
wykładzie.
Procedury
kontroli jakości, prawda? Tutaj
chodzi nam o to, żeby ta jakość
oprogramowania była jak największa,
jak najwyższa.
I to jest też
odrębny temat. Na ten temat
też nie będę Państwu mówić, no bo
po prostu nie wszystkie z tych tematów się
w 32 godzinach zmieszczą.
Skoro inżynieria oprogramowania
dotyczy oprogramowania
tworzonego przez grupy
ludzi,
no to
trzeba też tutaj szukać jakichś technik
pracy zespołowej. Ja na temat
technik pracy zespołowej
Państwu mówić nie będę, bo się po prostu
na tym nie znam. Natomiast
zasygnalizuję pewne
problemy, które
tutaj mogą wystąpić.
Troszkę powiem o
jak gdyby strukturze
zespołów, ale to też będzie w sumie
chyba nie więcej niż 20 minut wykładu.
No dobrze. No to
teraz, proszę Państwa, wróćmy do tej jakości
oprogramowania.
Wiemy, że celem
inżynierii oprogramowania jest
produkcja oprogramowania
wysokiej jakości.
No to teraz jak tą jakość
oprogramowania oceniać?
No i ja tutaj napisałam Państwu,
że ocena jakości oprogramowania
jest sprawą subiektywną.
Myślę, że troszkę żeście Państwo
się już zorientowali, że to faktycznie
tak jest. Bo tak jak Państwa
prosiłam o to, żebyście
mówili co dla Was jest istotne
w oprogramowaniu wysokiej
jakości, w dobrym oprogramowaniu,
to mieliście Państwo różne
pomysły, prawda? Dla
kogoś było ważne, żeby było
łatwo korzystać z takiego oprogramowania,
a dla kogoś innego, żeby było
bezpieczne, a jeszcze
dla kogoś innego, żeby
było szybkie.
Więc widzimy, że
to jest na pewno sprawa
subiektywna. No, ale
jednak jakoś sobie musimy z tym poradzić.
I teraz, proszę Państwa,
tak, ja Państwu pokażę
taki model McCalla,
który te kryteria
oceny jakości oprogramowania
dzieli na pewne grupy.
Mówiłam Państwu,
że to jest model stary.
To jest pierwszy model
jakości oprogramowania,
który powstał. No, dlaczego
ja o takim starym modelu mówię?
Dlatego, że, proszę Państwa, te
pomysły, które dawno, dawno temu
McCall wprowadził, one
zostały wprowadzone i są
wykorzystywane. W tej
chwili mamy normę ISO,
która
dotyczy właśnie
oprogramowania wysokiej
jakości i tam
ma różne, różne cechy.
Można ją sobie, nie wiem,
znaleźć, poczytać.
Natomiast ja o tej normie Państwu
nie chcę mówić, no bo to po prostu
będzie bardzo nudne. Ale
właśnie te poszczególne, jak gdyby
działki w tej
normie aktualnie,
aktualnej jakości oprogramowania
to są właśnie
też wynikają z tego, co
kiedyś McCall wprowadził.
Czyli pierwsza rzecz on zaproponował,
żebyśmy te kryteria oceny
jakości podzielili na
pierwsze grupy. Czyli na przykład,
żebyśmy oceniali
sposób działania
oprogramowania. No bo
to jest istotne dla użytkownika.
Teraz istotną jest
możliwość również wprowadzenia zmian
i poprawek. Więc to jest jak gdyby
druga kategoria.
No i trzecia kategoria tutaj
też jeden z Panów
wspomniał o tym, że czasem istotne
jest, żeby oprogramowanie
działało na różnych platformach. Więc
możliwość przenoszenia oprogramowania,
mobilność tego oprogramowania.
Także
zaproponował takie trzy
grupy, jak gdyby
i w tej normie, która
aktualnie jest normą
ogólnoświatową
właśnie też są takie, te podejścia
są zachowane.
Dobra, zajmijmy się
kryteriami związanymi ze
sposobem działania.
No to słucham, co byście Państwo tutaj
jakie kryteria tutaj
wstawili, prawda?
Co uważacie, że tu jest istotne?
Jeżeli chcemy
oceniać sposób
działania oprogramowania, to na przykład
na co powinniśmy patrzeć?
Na
przystępność
używania interfejsu?
Tak.
Tak, to
jest ok.
Bardzo dobrze. Coś jeszcze?
Z użytkownikiem.
Co z użytkownikiem?
Ktoś wspomniał
zasoby. Przepraszam, chodziło
o czas.
Jeszcze raz by Panowie
wzajemnie, żeście sobie, to po kolei.
Najpierw jeden, potem drugi. Słucham.
Jeszcze raz by
byliście w kurze. Dla użytkownika
ważny jest
czas jakby reakcji z programu,
prawda? Czyli czas oczekiwania na
jakąś wymianę informacji.
Super, bardzo dobrze.
Co jeszcze?
Znaczy ilość zużytych zasobów
i też mi się wydaje, że
ilość
informacji
znaczy minimalna ilość
przetwarzanych informacji
przez program tak, żeby
ograniczyć,
tak, żeby wspierać prywatność
użytkownika.
To jest rzeczywiście dosyć
ważne sprawy są, ale
ja Panu powiem tak.
Takiego użytkownika to nie interesuje.
To jest ważne
i tak powinniśmy
projektować i realizować systemy.
To, o czym Pan powiedział
jest ważne dla zespołu, który
ten system realizuje.
Ale dla takiego użytkownika, który
siedzi po drugiej stronie
gdzieś przy komputerze
swoim, czy tam nawet
z telefonu z tego systemu korzysta,
to jego to specjalnie
nie interesuje, jak te zasoby są.
Czy one są duże, czy małe,
zużywane. To jego to specjalnie
nie dotyczy. Także to jest
jak gdyby sprawa techniczna,
o której Pan wspomniał.
Natomiast tutaj w tej grupie
raczej chodzi nam o kryteria
związane z tym, co widać
jak gdyby na zewnątrz.
Czyli właśnie tak jak tutaj Panowie
któryś powiedział. Przyjazność.
Interfejs użytkownika.
Taki, żeby to był interfejs
dostosowany do tej
konkretnej grupy użytkowników.
Kontrola uprawnień.
Żeby właśnie jakieś nasze dane
nie były
dostępne
dla innych
użytkowników.
Ktoś powiedział o tym, żeby czas
reakcji był, żeby szybko dostawać
odpowiedź na nasze zapytania.
I jeszcze możliwość
ostrzeżeń o
możliwych problemach.
Na przykład
jak
może to wpłynąć na
działanie całego systemu.
Czyli takie trochę
prawda, prowadzenie za rękę
tego użytkownika, żeby on sobie
nie nabroił. To Pan ma na myśli?
Tak, tak.
No wie Pan, to to możemy
też jak gdyby włożyć tutaj w tą
przyjazność.
Jeżeli ją będziemy szerzej jakoś tam
traktować.
Tak, ale ma Pan rację, to jest też
istotne.
Teraz
tutaj również chodzi o to,
żeby prawda
ten system
realizował to, co faktycznie
użytkownik potrzebuje
i co by chciał, żeby było.
I właśnie nazwijmy to poprawnością,
tak, żeby prawda użytkownik
był ze sposobem działania, żeby
użytkownicy byli zadowoleni
z tego, co ten system im pozwala
zrobić.
No i chodzi o to również,
żeby
ten system działał
właśnie no zgodnie z tym, jak się
umówiono, że ma
działać lub jak, prawda, na co
zawarto umowę,
że będzie działał.
I bardzo
istotna sprawa
niezawodność, odporność
na błędy, które
i tutaj też jeden z Panów
powiedział, żeby prawda,
no jak coś, żeby użytkownik
sobie nie nabroił, to jest jak gdyby
jedna rzecz, sam sobie, tak, żeby go jakoś
tam ostrzegać
przed pewnymi krokami, które mogą być
dla niego niebezpieczne.
To jest z jednej strony to,
z drugiej strony to, żeby na przykład
taki system nam się nie zawieszał,
bo to nas będzie denerwować.
Więc,
żeby
on działał niezawodnie,
to też jest bardzo istotne.
Czyli mamy tutaj pewne kryteria
związane ze sposobem działania.
No i teraz proszę Państwa tak,
to możemy jak gdyby ocenić
wtedy, kiedy mamy już gotowy system.
Ale
o tym musimy
pamiętać, robiąc już
projekt systemu.
I teraz
problem polega na
tym, że nie
da się wszystkich z tych
no pożądanych
cech
doprowadzić do
nie wiem, powiedzmy maksimum.
Dlatego,
że no pewne rzeczy
tutaj są ze sobą w jakiejś tam
sprzeczności.
Czyli na przykład, często
jest tak, że jeżeli mamy taki
bardzo przyjazny interfejs
użytkownika, że ten
użytkownik jest tak krok po kroczku,
prowadzony, że ma różne
podpowiedzi, że ma różne
możliwości pomocy,
to to proszę Państwa
zwalnia pracę systemu
po prostu. Czyli będzie wtedy
słabsza wydajność.
Teraz
kwestia niezawodności, odporności
na błędy.
I tutaj proszę Państwa
ja jeden wykład na ten
temat poświęcę.
Będzie mniej więcej pod koniec
semestru.
I
pokażę Państwu
pewne techniki, które
pozwalają nam tą niezawodność
znacznie zwiększyć.
I niestety stosowanie tych
niektórych tych technik
specjalistycznych, wtedy kiedy
chodzi nam już o, nie o taką
niezawodność no dla
powiedzmy nas jako zwykłych
użytkowników, ale
taką niezawodność jaką ma mieć
na przykład system sterowania
elektrownią jądrową.
Żeby to nie wybuchło.
Czy system kontroli lotów.
A więc w pewnych
zastosowaniach
ta niezawodność musi być
bardzo, bardzo wysoka.
I te techniki, które
zwiększają tą niezawodność
one też proszę Państwa niestety
powodują obniżenie wydajności.
Czyli tutaj trzeba
zachować pewien
pewną równowagę
pomiędzy tymi
cechami.
I to różnie
może wyglądać w zależności od
typu oprogramowania, które ma być
realizowane.
No tutaj wspomniałam o tym systemie
sterowania elektrownią jądrową.
Że tutaj te parametry
niezawodnościowe są niezwykle
ważne. Ale tam jest
ważna również szybkość działania tego
systemu, żeby jak gdyby jak przychodzą
pewne
sygnały to żeby tam ten rdzeń
się wysunął czy schował.
Więc jak gdyby
tutaj trzeba
bardzo pilnować tych
relacji, które tu są
istotne w danym typie systemu.
Bo jeżeli robimy taki system
nie dla elektrowni jądrowej
czy tam nie dla jakiejś fabryki chemicznej
ale na przykład dla zwykłego
użytkownika, że to jest
jakiś tam system nie wiem
czy środowisko programistyczne
no to tutaj kwestia tej niezawodności
owszem powinien być to
system, który działa sprawnie i niezawodnie
ale nie jest to aż tak ważne.
Więc musimy sobie zdawać sprawę
jak te cechy
powinny wyglądać w danym
oprogramowaniu, które ma być realizowane.
Już na etapie
projektowania tego oprogramowania.
Druga grupa
to są te kryteria
związane z możliwością
wprowadzenia zmian i poprawek.
Czyli
wspomniałam Państwu o tym
maintenance, czyli właśnie
poprawianie błędów,
które na pewno wystąpią
w trakcie użytkowania systemu
ale na pewno
też trzeba będzie ten system
adoptować do jakichś nowych
potrzeb, które użytkownik
odkrył korzystając z tego
systemu albo trzeba
będzie adoptować dlatego, że
się zmieniły nie wiem przepisy
czy zmieniły się wymagania jakieś.
Więc chodzi
o to, aby ta pielęgnowalność
była w miarę łatwa
No i
wspomniałam o tym, że
zwykle te oczekiwania
użytkownika rosną
w trakcie korzystania
z systemu, więc trzeba ten system
rozszerzać, rozbudowywać,
dodawać nowe funkcje.
Więc też powinno się
to jakoś w miarę łatwo
dać zrobić.
No i proszę Państwa
to jak gdyby, żeby te
dwie rzeczy dało się
zrealizować
w miarę sprawnie, to
system powinien być
stosunkowo łatwy do testowania.
Dlatego, że no zdajemy sobie sprawę
z tego, że wprowadzenie
takich zmian
wymusza jakichkolwiek
zmian, nawet poprawienie jakiegoś
błędu, który został
zauważony, prawda, wymaga
przetestowania tego systemu, czyli
ta testowalność tego systemu jest
niezwykle ważną sprawą.
No i trzecia grupa
kryteriów
to są związane
właśnie z tą mobilnością,
przenośnością, czyli
przechodzenie na inne
systemy, na inne platformy,
na inne systemy operacyjne.
To jest również możliwość
ewentualnego wykorzystania
fragmentów tego oprogramowania
do konstrukcji
innych systemów, czy
podobnych,
czy po prostu.
I, proszę Państwa,
sprawa otwartości. To szczególnie
w dzisiejszych czasach jest
niezwykle ważne, dlatego,
że mamy
zwykle
no, prawda,
nie jeden system, z którego korzystamy
tylko, czy jakieś firmy
korzystają, tylko zwykle jest ich
wiele i te systemy
muszą sobie przekazywać
pewne dane, wymieniać się
tymi danymi. Czyli, jak gdyby
możliwość współpracy z innymi systemami.
Innymi systemami jest
też cechą niezwykle ważną,
szczególnie w dzisiejszych dniach.
Proszę Państwa, wspomniałam o tym,
że właśnie
niektóre z tych cech
no, są
ze sobą trochę sprzeczne.
Prawda, że jak będziemy
tak bardzo, bardzo walczyć o to,
żeby oprogramowanie
było niezawodne, to nam się pogorszy
jego czas
odpowiedzi, na przykład. Więc
problemem jest osiągnięcie
takiego optimum.
I tak, jak już Państwu wspomniałam, że to
optimum różnie wygląda
w zależności od tego, jaki
typ oprogramowania mamy
realizować. Inne będzie
w systemach, które
sterują
no, czymś bardzo takim ważnym.
Są takie systemy, które się nazywa
Safety Critical System.
Czyli, no, bezpieczeństwo,
prawda, zależy, jest
krytyczne bezpieczeństwo takiego
systemu. I to na przykład
właśnie ta elektrownia jądrowa, o której
wspomniałam, czy
jakaś sterowanie linią produkcyjną
w fabryce chemicznej, czy
właśnie te sterowanie lotami.
Czyli tutaj błąd takiego
systemu może powodować
bardzo poważne
szkody ekonomiczne.
Ludzkie, środowiskowe.
Więc w takich systemach
na pewno kwestia tej
niezawodności jest kwestią
krytyczną.
Ale, no właśnie,
musimy wiedzieć, co dla
danego systemu, jak,
jakie jak gdyby priorytety mają
.
I jeżeli
realizujemy oprogramowanie
dla konkretnego klienta,
to to musi być ustalone z tym
klientem, co dla niego jest
istotniejsze. Czy to, żeby
ten interfejs
był taki bardzo, bardzo, prawda,
łatwy dla użytkownika,
czy na przykład to,
żeby ten system, prawda, dawał bardzo
szybko odpowiedzi.
Teraz...
Momencik...
Właśnie.
Jeśli chodzi o...
Ja mówiłam dzisiaj, że, prawda,
celem inżynierii oprogramowania
jest produkcja oprogramowania
wysokiej jakości.
No ale, proszę Państwa,
na jakość tego oprogramowania
ma wpływ wiele
elementów.
Czyli...
Zależy to od tego, jaką
technologię stosujemy.
Zależy od
tego, jakich mamy
ludzi, którzy przy tym projekcie
pracują, prawda, co oni potrafią,
jak oni pracują.
Na jakość tego produktu
ma wpływ na przykład
harmonogram, w jakim ten produkt
ma być zrealizowany, prawda.
Jeżeli mamy jakiś bardzo przyspieszony
harmonogram, no to pewne
rzeczy mogą być w tym oprogramowaniu
po prostu tak zrobione byle jak,
byle tylko szybko.
Jeżeli jakoś te koszty
mają być takie bardzo, bardzo obniżone,
to też będziemy tutaj pewne rzeczy
starać się robić
szybko i po, jak gdyby,
najmniejszym wysiłkiem.
No i w sumie ta jakość też wtedy
może być kiepska.
I również sam proces
wytwarzania tego też ma wpływ
na jakość produktu.
Także widzicie Państwo, tu nie ma jak gdyby
wiele jest,
wiele jest czynników,
które wpływają na jakość
tego oprogramowania,
które, no,
zostanie wyprodukowane.
Teraz wspomniałam Państwu o tym,
że, no,
pewne z tych cech takich
korzystnych dla nas
są ze sobą
no, jak gdyby,
może nie tyle sprzeczności,
co
wyższa wartość.
Jedna z tych cech
powoduje, że
inna z tych
ocen będzie,
będzie gorsza.
I tutaj mówiłam Państwu,
że właśnie kwestia
tej niezawodności
i efektywności są ze sobą
właśnie w takiej sprzeczności.
Tutaj, proszę Państwa,
nie powinniśmy mieć takiego dylematu,
co jest ważniejsze, czy niezawodność,
czy efektywność, tylko powinniśmy
wybierać niezawodność. Dlaczego?
Dlatego, że, no,
widzimy, że sprzęt
jest coraz szybszy,
coraz tańszy, tak, coraz
jak gdyby większe mamy deski,
większą przepustowość łącz
i tak dalej, więc jak gdyby,
to co może dzisiaj
jest jeszcze niewystarczająco
efektywne, no to po wymianie
na przykład sprzętu,
czy dysku, czy łącza,
może się już okazać wystarczające.
Natomiast,
jeżeli mamy oprogramowanie,
które, no, się
niezbyt dobrze, w cudzysłowie,
sprawuje, czyli na przykład
się zawiesza, ma jakieś
błędy, no to oczywiście będziemy
unikać takiego oprogramowania.
Poza tym,
w takich zawodnych
systemach, no,
trudno nam będzie wprowadzić
jakieś poprawki, tak, nawet jeżeli
coś zauważymy,
że jest niedobre, to trudno
nam będzie to wprowadzić.
No i ja wspomniałam o tych
systemach Safety Critical System,
że szczególnie w tych systemach,
no, tutaj ta kwestia tej
niezawodności musi być bardzo, bardzo
wysoka, dlatego, że
tam mogą być
straty ludzkie, czy jakieś
bardzo duże straty środowiskowe,
więc w tego typu
systemach właśnie te
kwestie niezawodności
muszą być priorytetowe.
Teraz wspomniałam Państwu
o tym, że, no właśnie,
że coś, co dzisiaj jest wolne,
to może jutro już będzie
działało wystarczająco szybko,
więc kwestia tego,
prawda, coraz lepszego
sprzętu, coraz
szybszego sprzętu,
jest istotna,
ale istotną sprawą jest
również to, że jeżeli mamy
system, który dobrze działa,
ale,
no, na przykład
na dzień dzisiejszy
działa trochę za wolno,
to można taki system
przyjrzeć mu się,
jak, jaka
jest przyczyna tego,
że on za wolno działa. Może
na przykład jest za mały dysk,
a może jest za mała przepustowość,
łącza, przez które
on pobiera jakieś dane,
czy wysyła dane. Więc takie
systemy, które działają
poprawnie, można
stroić, właśnie można lokalizować
przyczyny, te wąskie gardła,
które wpływają na tą,
no,
ograniczoną
wydajność tego systemu i
starać się te wąskie gardła
eliminować.
Jeżeli mamy nawet system, który
działa, prawda,
stosunkowo wolno, ale,
ale działa, no to mamy ten
rezultat, który można uzyskać,
więc, więc, no,
dobrze, że coś dostaniemy.
Natomiast w przypadku systemów,
które właśnie się
zawieszają, czy są zawodne,
no to, to po prostu
nie bardzo wiadomo, co my możemy
wtedy dostać i to może powodować
jakieś katastrofy, może
powodować utratę danych.
No to, proszę Państwa, teraz
jeszcze zastanówmy się
od czego ta niezawodność zależy.
Musimy mieć projekt,
dobry projekt,
poprawny projekt.
Teraz zazwyczaj,
żeby mieć poprawny projekt,
to trzeba mieć dobrą specyfikację,
czyli trzeba mieć
jasno określone,
co chcemy,
żeby to oprogramowanie robiło.
No, ale teraz
następna rzecz, to jak mamy taki poprawny,
dobry projekt, no to musimy
ten projekt zrealizować, czyli jest
kwestia implementacji.
Oczywiście tutaj na tym
przejściu właśnie z projektu
do, do kodu, do
implementacji, no też często są popełniane
błędy.
I teraz następna rzecz,
no to jest kwestia
tego, że aktualnie,
oprogramowanie, które tworzymy,
jest oprogramowaniem złożonym,
często składa się z wielu elementów,
tak, one ze sobą jakoś tam
współpracują, mają różne
powiązania. I
teraz proszę Państwa, po pierwsze każdy
z tych elementów powinien być
niezawodny, to jest jak gdyby
jedna sprawa, a po drugie my
musimy je właściwie złożyć, właściwie
one muszą ze sobą współpracować,
prawda, tutaj przy tej współpracy
pomiędzy nimi, tak, ta
współpraca też powinna się odbywać,
no bez,
bez błędów. Czyli
nie tylko same elementy,
ale również w jaki sposób one
zostały zmontowane,
może tak to nazwijmy,
złożone.
Miary
niezawodności oprogramowania
są troszkę inne
niż miary
niezawodności sprzętu, jeśli
chodzi o sprzęt, to taką miarą
powszechnie stosowaną jest
mean time to failure,
i tak jak Państwu mówiłam
pod koniec semestru
jeden z wykładów,
na jednym z wykładów będę mówić o tych
miarach niezawodności, będę mówić
jakie są, w jakich typach
systemu poszczególne miary się
stosuje, jak się je
mierzy. No
ale właśnie, tutaj już wspomniałam Państwu
o tym, żeby mieć dobry projekt,
tak, projekt, który
rzeczywiście ma realizować
to, co użytkownik by sobie
życzył, to musimy mieć
specyfikacje, musimy wiedzieć jakie
są życzenia tego użytkownika.
Czyli tutaj można powiedzieć,
że takim kluczem do
niezawodności i do poprawności
oprogramowania jest dobra
specyfikacja, specyfikacja,
która no odzwierciedla
w pełni oczekiwania, życzenia
użytkownika.
Teraz wspomniałam
Państwu również o tym,
że właśnie
trzeba tą miarę,
tę niezawodność trzeba mierzyć
i jak gdyby, jeżeli osiągniemy
taki pułap,
który dla danej miary
już jest dla nas akceptowalny
w danym typie systemu, prawda,
i tak jak Państwu mówiłam, w przypadku
systemu powiedzmy dla zwykłego
użytkownika, no to ta miara
nie musi być wysoka. W przypadku
systemów safety, critical to powinna
być ta miara, tutaj mamy powiedzmy
całkiem niezawodny system, czyli na przykład
100%, jak dalej.
To musimy tutaj wybrać,
ten akceptowalny poziom,
bo tak jak Państwo widzicie tutaj
koszty, no dramatycznie
rosną ekspotencjalnie,
więc istotne jest,
żeby zatrzymać się
na pewnym akceptowalnym
dla danego typu oprogramowania
poziomie.
Teraz proszę Państwa
wspomniałam Państwu,
że egzamin
będzie miał formę
no takiego egzaminu
prawda, w insperze realizowanego,
tam będzie ileś
sekcji,
mogą być pytania otwarte,
mogą być wybory,
może trzeba będzie coś policzyć
i tutaj na przykład
pokazuję i te
jak gdyby zadania, pytania
będą dotyczyły no tego
materiału, który ja w trakcie wykładów
Państwu tutaj prezentuję.
Więc tutaj na tym slajdzie
pokazuję Państwu jakie
mogą być przykładowe pytania
dotyczące
właśnie tego wykładu,
który przed chwileczką tutaj
Państwu pokazałam i opowiedziałam.
Czyli na przykład
czym zajmuje się inżynieria
oprogramowania, jakie są
cechy oprogramowania wysokiej jakości,
jakie
można stosować kryteria oceny
oprogramowania,
jakie cechy oprogramowania są
związane z działaniem, co oferuje
inżynieria oprogramowania,
dlaczego ważniejsza jest
niezawodność niż
efektywność. To akurat
tutaj widzimy taką przykładową listę
pytań. Jeszcze
raz
wspominam, że
mogą one mieć charakter
otwarty lub mogą być to listy
wyboru, które
będziecie Państwo
wybierać.
I tutaj doszłam do końca
tego
wykładu, jeśli chodzi o
czy mają Państwo do tego jakieś
pytania, uwagi.
Nie ma pytań,
uwag.
Widzę na czacie,
że
Panowie, którzy się odzywali w trakcie
wykładu, się zgłosili.
Dobrze, dostaniecie
plusa za dzisiejszą aktywność
na wykładzie i tak jak Państwu
mówiłam, na koniec semestru te plusy,
które ja będę sobie notować, zostaną
przerobione w dodatkowe
punkty, które możecie w ten sposób
zebrać.
Jeszcze raz
jakieś pytania, uwagi?
Jeśli nie, no to proszę Państwa
tak, po pierwsze
zatrzymam
nagrywanie.
---------------------------------------------Proszę Państwa, jestem już
z powrotem
uruchomiłam również nagrywanie
no i teraz
już tak jak mówiłam Państwu
przechodzę do
spraw
takich bardziej
merytorycznych
po tym wprowadzeniu
na poprzedniej godzinie.
Mianowicie
teraz będę chciała Państwu opowiedzieć
o, tak jak tutaj widzicie
modelach procesu
produkcji oprogramowania.
Pokażę Państwu kilka takich
no typowych modeli.
Przy okazji
każdego z tych modeli będę
starała się Państwu
powiedzieć jakie są wady,
zalety
tego modelu
i również
dla jakiego typu oprogramowania
przy produkcji jakiego typu
oprogramowania
można ten model stosować.
A więc będę
chciała Państwu powiedzieć
o tak zwanym modelu
wodospadowym czy kaskadowym.
W zasadzie pierwszym jaki
stosowano.
Ale nadal
jest on dobry do pewnego typu
oprogramowania.
O modelu ewolucyjnym
opowiem Państwu trochę o prototypowaniu,
o formalnych
transformacjach, o metodzie
iteracyjnej.
Wspomnę o
metodzie RIUS,
modelu spiralnym
i czynnikach
nietechnicznych w inżynierii
oprogramowania. To będzie ten
jeden moment,
gdy będę mówić o jakichś
rzeczach nietechnicznych
przez jakieś 15 minut
mniej więcej. Nie wiem
ile z tego dzisiaj Państwu
zdążę powiedzieć.
W dzienniku zajęć wpiszę do której
strony z tą prezentacją
dzisiaj dojdę.
Także to będziecie Państwo widzieli
do jakiego momentu.
A więc proszę Państwa zaczynamy
od modelu wodospadowego.
I tak jak Państwu wspomniałam
był to pierwszy model,
który zastosowano przy
produkcji, czy postanowiono
stosować przy produkcji
oprogramowania.
Przypisuje się, że jest,
że pochodzi on, że
w 1970 roku
został
zastosowany. Inaczej
nazywa się modelem kaskadowym,
czy liniowym.
I to jest proszę Państwa model,
który zaczerpnięto z tych innych
dziedzin inżynieryjnych.
Wspomniałam Państwu dzisiaj,
że właśnie w początkach
swojego istnienia
inżynieria oprogramowania
starała się wykorzystać pewne
pomysły, które mieli
ci inżynierowie od dróg i mostów,
czy od złożonych urządzeń mechanicznych
i wprowadzić je do
produkcji oprogramowania.
I to jest
właśnie ten model, który
zaczerpnięto od nich.
A więc pierwsza sprawa.
Jeżeli mamy
budować most,
czy jakieś złożone
urządzenie mechaniczne,
no to trzeba przygotować
specyfikacje wymagań.
A więc trzeba określić,
na przykład
weźmy sobie to urządzenie mechaniczne.
Co to urządzenie mechaniczne
ma robić
i w jakich warunkach ma pracować?
Bo to może być istotne, czy to
urządzenie pracuje na przykład
na równiku, czy to
oprogramowanie ma
pracować gdzieś pod kołem,
budowę, prawda? Dla urządzenia,
dla materiału, który zastosujemy
może mieć to bardzo istotne
znaczenie. A więc
specyfikacja wymagań,
określenie, co to
oprogramowanie ma robić
i określenie
przy jakich
ograniczeniach,
czyli jak gdyby co robi
i
ograniczenia, jakie ma
spełniać, czy jakieś warunki
dodatkowe.
I o tym
jeszcze, jak się takie specyfikacje
robi, to troszkę też będę mówić
później. To, co oprogramowanie
ma robić, to są tak zwane
wymagania funkcjonalne.
Przy jakich ograniczeniach ma to
wykonać, to są
wymagania niefunkcjonalne.
I tak samo właśnie z oprogramowaniem.
Co ma robić i jakie
dodatkowe ograniczenia ma spełniać?
A więc na przykład
powiedzmy czas reakcji tego
oprogramowania, czy zajętość pamięci,
czy jakieś
parametry niezawodnościowe.
No i teraz tak,
jak mamy już określone
powiedzmy, co ma robić,
przy jakich ograniczeniach ma to
być zrealizowane,
no to kolejną fazą jest
faza projektowania, czyli
design tego oprogramowania.
Czyli przejście ze
specyfikacji do
fazy projektowej.
Czyli
projektowania,
projektujemy teraz to oprogramowanie
zaczynając od takiego
projektu ogólnego, od projektu
architektonicznego,
wchodząc w coraz to większe
szczegóły, żeby właśnie faktycznie
to oprogramowanie realizowało
to, co w tych wymaganiach
napisano.
Jak mamy gotowy taki
projekt, to możemy
przejść do jego kodowania,
czyli do fazy implementacji
tego oprogramowania.
Czyli
No i
teraz kolejna faza
to jest
faza testowania, czyli
ten kod, który napiszemy
musimy przetestować.
No, potem te małe
elementy składamy w coraz bardziej
złożone, ale też je musimy testować.
Czyli no, ogólnie
faza testowania.
Ja troszkę później
Państwu pokażę za chwilę jeszcze
tutaj jak gdyby te fazy w takiej
wersji bardziej szczegółowej.
No i teraz jak mamy już
to oprogramowanie, prawda,
przetestowane, gotowe, to
oddajemy je do
użytkownikowi, użytkownik na niej
pracuje, a my to
oprogramowanie pielęgnujemy,
czyli poprawiamy
te, które wyszły w trakcie
realizacji tego
oprogramowania, ewentualnie
dodajemy, modyfikujemy,
dodajemy jakieś nowe
możliwości,
czy, no,
adaptujemy
do jakichś zmieniających się
warunków.
Teraz, proszę Państwa, jak
popatrzymy na
te fazy,
to
kiedy mamy
kontakt, powiedzmy, wyobraźmy sobie,
że chodzi tu o produkcję
oprogramowania właśnie dla jakiegoś
tam użytkownika, czy dla jakichś
tutaj tym użytkownikiem, powiedzmy,
może być firma jakaś,
dla której to robimy,
kiedy mamy kontakt
z tym użytkownikiem. No, kontakt
mamy wtedy, kiedy przygotowujemy
tą specyfikację wymaganych,
prawda, czyli tutaj rozmawiamy
to, co to
oprogramowanie ma robić, przy jakich
ograniczeniach, no i
potem jak instalujemy to
oprogramowanie u użytkownika.
Widzicie Państwo, tutaj
jest dosyć duża przerwa
pomiędzy tymi
chwilami, kiedy mamy kontakt,
kontakt z naszym
użytkownikiem, klientem.
No i w związku
z tym tutaj jest pewien problem,
który się wiąże z
zastosowaniem tego modelu
produkcji oprogramowania, że
jeżeli ta
część, kiedy my pracujemy,
ale nie mamy kontaktu z użytkownikiem,
trwa dosyć
długo, to możemy zrealizować
oprogramowanie, które nie będzie
trafiało w oczekiwania
klienta. Czyli tu jest pewien problem,
związany z przyjęciem tej metody
produkcji.
Teraz proszę Państwa,
tutaj popatrzmy jeszcze
na właśnie takie
też te właśnie te fazy,
czyli tu mamy to określanie
wymagań, projekt, implementacja,
testy, pielęgnowanie,
praca systemu i pielęgnowanie.
I teraz proszę
Państwa, tutaj ja pod spodem
napisałam taką
faza strategiczna,
która tak jak Państwo widzicie,
ona się zaczyna,
zaczyna ciut wcześniej
od tego
określania wymagań, a kończy
się tutaj też troszkę
wcześniej. Mianowicie
co to, co się tu dzieje
i co robimy w tej fazie strategicznej,
to ja na chyba
następnym wykładzie mniej więcej będę Państwu
mówić, ale widzicie, to się
w czasie zaczyna troszkę wcześniej.
Czyli tutaj to troszkę wcześniej,
to jest na przykład decyzja,
podjęcie decyzji, czy my
się chcemy,
zabierać za produkcję tego oprogramowania,
czy może, czy chcemy wziąć udział
w przetarg, w przetargu na
dostawę tego oprogramowania.
To jest proszę Państwa,
ta pierwsza faza określania wymagań,
to jest określanie takich
wymagań zgródnych, tego co ten
system ma robić, przy jakich ograniczeniach
ma tych funkcji
dostarczać. I to właśnie się
dzieje w tej fazie strategicznej.
Tu ta dalsza część
tej fazy określania wymagań,
to jest doprecyzowanie
tych wymagań i to już jak Państwo
widzicie, wchodzi
w taki kawałeczek,
który się nazywa analizą.
Czyli właśnie ta analiza
dotyczy analizy
wymagań, a można powiedzieć
jej uszczegółowienia
tych wymagań.
I proszę popatrzeć, i ta analiza
pokrywa się z fazą projektowania.
Tu chodzi o zrobienie
projektu ogólnego systemu.
Co ten system,
żeby ten system realizował
te wymagania, które
ma robić.
Teraz proszę
Państwa, tutaj proszę popatrzeć na
tą kreskę z napisem
dokumentacja. I proszę popatrzeć,
ona się też zaczyna, tutaj trochę
krzywo mi się to narysowało,
może to wytrę. I jeszcze raz.
W fazie
wymagań.
Otóż, co to jest za ta
dokumentacja, którą tutaj mogę?
przygotować w tym czasie, prawda?
Jeżeli to mi się pokrywa z tym
określeniem wymagań. To jest
proszę Państwa dokumentacja
użytkowa, bo to jest określenie
tego, co ten system
ma robić. I już
na tym etapie może
właśnie taka dokumentacja
użytkowa powstawać.
Tutaj dalej widzimy, że ta
dokumentacja pokrywa i projektowanie,
i implementację, i testowanie,
prawda? No bo ona jest cały czas
jest uzupełniana, ale to
już jest właśnie ta dokumentacja
techniczna, w której mamy informację
o tym, jak projekt zrobiono, jak
go zaimplementowano,
jakie
testy wykonano.
No i to jest
proszę Państwa też rzecz taka,
która dla wielu osób wydaje się
być trochę dziwna. Dlaczego tu już
zaczynamy tą dokumentację, a nie
dopiero wtedy, kiedy ten system
jest gotowy. Studenci robiąc
projekty, jeżeli trzeba zrobić
dokumentację, to tą dokumentację
robią na końcu, na ogół wtedy, kiedy to
wszystko już jest gotowe.
To jest proszę Państwa zalecane
podejście właśnie, żeby w ten
sposób działać, prawda?
Mało tego,
no tutaj ja wspominam
czasem te kwestie
tych przetargów na dostawy
oprogramowania. I
przy niektórych z takich
przetargów jest wymaganie,
aby na tej, jak gdyby przystępując
do tego przetargu, żeby
dostarczyć podręcznik,
dla użytkownika. Czyli nie ma w ogóle
systemu, a my
dajemy podręcznik dla użytkownika.
No właśnie ta dokumentacja użytkowa.
Żeby było
z niej najłatwiej
się zorientować, co ten system
ma robić i najłatwiej ocenić,
czy rzeczywiście on
realizuje. Oczekiwania,
jakie mamy w stosunku
do tego systemu.
I niektóre
duże
takie organizacje,
które organizują
wiele przetargów na dostawę
oprogramowania. Na przykład
Agencja
Energii Atomowej
Kosmicznej. Również
one wymagają, aby przystępując
do przetargu właśnie taką
dokumentację użytkową
dostarczyć.
Dobrze. Może
wrócę się do poprzedniego slajdu.
I tutaj, proszę Państwa,
no właśnie, ten model, tak jak
Państwo widzicie, nazywa się modelem
kaskadowym. Często się go
rysuje w takiej formie
właśnie takich
spadających kaskad
na poszczególne
fazy, czyli specyfikacja,
projektowanie,
implementacja, testowanie.
I właśnie
jak gdyby przechodzimy
z fazy do fazy, tak?
Przechodzimy z fazy do fazy.
No ale, proszę Państwa, super
tak by było
w takiej, prawda, kaskadzie, tylko
że życie wygląda troszkę inaczej.
I
na przykład realizując
ten projekt
widzimy, że nie wszystkie
rzeczy zostały dobrze
opisane w tych wymaganiach.
Że, no, brakuje nam
pewnych informacji, czyli musimy,
jeżeli tutaj mamy tą specyfikę,
specyfikację, tak?
A tu mamy projekt.
No to musimy
jak gdyby wrócić tu
z tego projektu
i pewne rzeczy doprecyzować.
Mamy projekt,
tak? Przechodzimy do
kodowania tego projektu i znowu
się okazuje
zazwyczaj, że pewne
rzeczy w projekcie po prostu,
są, no, niedoprecyzowane.
I nie wiemy
w kodzie, jeśli tam
coś tam to jest powiedziane,
co mamy robić, a jak ten warunek
nie jest spełniony, to nie znajdujemy
tej odpowiedzi na to pytanie
w projekcie, więc nie potrafimy
tego kodu napisać. Więc,
że trzeba wrócić
do tej fazy projektowania.
Ale być może tego nie było
w projekcie, dlatego, że
nie było to określone w specyfikacji.
Czyli często,
ten powrót wymaga nie tylko
powrotu do
fazy poprzedniej,
ale być może do jeszcze tych
faz wcześniejszych. Podobnie
tutaj, prawda? Na etapie testowania
no, wykrywamy pewne
braki, błędy, trzeba je
czasem poprawić,
więc wracamy do tej fazy implementacji,
poprawiamy je. Ale
jeżeli to dotyczy takiego
testowania już, jak
gdyby przez
użytkownika, czyli testowania tych,
elementów
funkcjonalności systemu,
no to to może czasem powodować,
że nie tylko tu trzeba będzie,
ale że trzeba będzie wrócić aż tutaj,
bo my nie widzimy pewnych
możliwości, w tym nie ma,
w tym systemie, a więc
nie ma, bo trzeba było,
nie było ich specyfikacji w projekcie
i tak dalej.
No, łatwo sobie
można wyobrazić, że
jeżeli mamy takie powroty
do tych faz wcześniejszych,
to
wiąże się to
no, z rosnącymi kosztami,
prawda, wydłuża to czas produkcji
tego oprogramowania,
rosną koszty.
Wobec tego
tą metodę można
stosować wtedy,
kiedy, no,
tych powrotów będzie jak najmniej.
A tych powrotów będzie
jak najmniej wtedy, kiedy ta
specyfikacja wymagań będzie
bardzo dobra, będzie bardzo
dokładna. No to wtedy mamy
jak gdyby mniej tych powrotów
albo te powroty tylko do fazy
wcześniejszej, a nie ma ich
już jak gdyby do samego
początku. Także
to jest kluczem, żeby tą
metodę można było stosować, jest to, żebyśmy
byli w stanie dobrze,
dokładnie przygotować specyfikacje
wymagane. To jest jak gdyby jeden
wymóg. Drugi wymóg, o którym już
tutaj troszkę Państwu mówiłam,
że jest kwestia tej przerwy w kontakcie
z klientem, prawda, że
tutaj z nim rozmawiamy,
dyskutujemy
wtedy, kiedy przygotowujemy
tą specyfikację wymagań
i potem
dopiero, kiedy instalujemy mu ten system
i on na nim pracuje. I jeżeli
ten okres trwa zbyt
długo, no to
może się okazać, że ten
system, no,
nie trafia w oczekiwania
użytkownika, że jego oczekiwania
się zmieniły, że jego potrzeby się
zmieniły. Także
ten model nie może być stosowany
właśnie do wtedy,
kiedy ten proces produkcji trwałby
bardzo, bardzo długo.
Proszę Państwa, tutaj
popatrzmy na
pewne
procenty kosztów
poszczególnych
faz. Mianowicie
zostało
tutaj w tej kolumnie połączonej
przygotowanie wymagań
i zrobienie projektu.
Tutaj mamy
kolumnę odpowiadającą za
implementację i za
testowanie. I
przyjmując, że
100% mamy do podziału na te
trzy
elementy,
to popatrzmy, jak to się,
to są dane dosyć stare
sprzed iluś lat,
ale po prostu
jak gdyby takich danych,
oczy aktualnych
nie publikowano je,
dlatego je tutaj Państwu
pokazuję. Popatrzmy, jak to wygląda.
A więc, jeśli chodzi
o systemy sterowania,
czyli no właśnie
jakaś tam linia produkcyjna,
sterowanie jakimś urządzeniem,
zaporą wodną,
no to popatrzmy, tutaj
stosunkowo największe
są te koszty tych faz
wcześniejszych, tych faz
wstępnych. Przygotowanie,
wymagań i projektu.
Największe spośród tych
różnych typów systemów,
bo tu uwzględnione są
systemy operacyjne, systemy naukowe,
biznesowe.
Dlaczego? No bo
trzeba dobrze zrozumieć, jak
to ma, sterowanie
ma działać, jak to ma wyglądać,
prawda? Więc jest bardzo trudno
te wymagania przygotować tutaj.
Prawie 50% kosztów
jest jak gdyby w to włożone,
więc to jest bardzo trudne.
Implementacja stosunkowo mało
i testy. Mało
ta implementacja, dlatego, że
zwykle, jeśli chodzi o kod takich
systemów, to on jest stosunkowo
prosty, więc jak gdyby
tutaj te koszty przygotowania
tego kodu są stosunkowo nieduże.
No i musimy
oczywiście ten system
przetestować.
Ja zwyczajowo pytałam się studentów,
zanim im pokazałam tą tabelkę,
prawda, to prosiłam, żeby,
żebyście określili,
jak Wy to widzicie.
Jaki procent,
jaki procent, powiedzmy,
jeżeli te 100%,
tutaj
mówię o tych fazach, prawda?
Jeżeli te 100%, to
jak to dzielicie,
nie wiem, na podstawie na przykład swoich
projektów, czy prac, które
realizujecie? I czy,
czy Waszych, jak gdyby, pomysłów?
I proszę Państwa, no nie wiem, jak gdyby,
to było Waszej grupie, bo już tą tabelkę
pokazałam, więc już nie, jak gdyby,
nie, nie ten, ale zwykle
było tak, że wiele osób mi mówiło,
że te, na przykład tutaj 50%
wkładało w tą implementację,
a tutaj bardzo
mało. A proszę popatrzeć właśnie
w tych danych historycznych,
to to wygląda zupełnie inaczej,
prawda, że bardzo duży wysiłek
wkładamy w te
etapy wstępne
i stosunkowo mało
nas kosztuje
implementacja tego systemu.
Teraz
popatrzmy tutaj na systemy
operacyjne. Jak widzimy
znacznie mniejszy
procent kosztów jest związany
z przygotowaniem wymagań i projektu.
Dlaczego?
Dlatego, że te systemy operacyjne
no tworzone są od wielu,
wielu lat. Dobrze
wiadomo, co taki system robić
powinien, tak, więc te wymagania to nie
jest problem, jak gdyby mamy
z poprzednich systemów. Mamy
również wzorce, mamy metody,
mamy dobre przykłady
systemów operacyjnych, na przykład
jak ten UNIX, o którym wspomniałam
czy inne, a więc wiemy
jak to zaprojektować, wiemy
co ten system ma robić, wiemy jak to
zaprojektować.
Mało nas kosztuje też implementacja,
ale bardzo dużo
nas kosztuje testowanie
takiego systemu. No bo
właśnie tutaj trzeba uwzględnić
w tych testach, prawda,
pracę wielu użytkowników,
tutaj no dostęp do różnych
zasobów, które ten system ma przez
wielu użytkowników, a więc
te testy są drogie.
No i jak gdyby
widzimy, jak to się podobnie rozkłada
w systemach naukowych czy biznesowych.
Tak jak Państwu wspomniałam,
te dane,
które tutaj w tej tabelce pokazuję
są stosunkowo stare,
ale pokazuję je, bo
trudno, znaczy nie znalazłam
danych takich
bieżących, aktualnych.
Natomiast jak to wygląda
w aktualnie produkowanych systemach,
tworzonych systemach?
Otóż, proszę Państwa, jeśli chodzi o
testy, to one
często, testowanie
systemu kosztuje 60%
ogólnych kosztów produkcji,
a w niektórych
systemach nawet 80%.
Czyli proszę popatrzeć, tutaj
rosną te koszty związane
z testowaniem, maleją
koszty związane z implementacją
ze względu na
specjalne środowiska,
narzędzia, użycie
gotowych elementów.
Dobra, czy do tego, co mówiłam
może mają Państwo jakieś pytania,
uwagi?
Tak, tutaj
przy tym testowaniu to chodzi
o testowanie bezpośrednio
kodu, jakieś unit testy,
testy integracyjne.
Tu chodzi o wszelkie
typy testowania, czyli zarówno
takie testowanie, prawda,
testowanie jednostek,
to jest tutaj już na etapie
kodowania, ale potem składamy
te jednostki małe w troszkę
większe, testujemy to,
czyli zarówno tutaj
testy jednostek, testy integracyjne,
jak i potem testy
już całego złożonego
systemu testy,
no, co ten system robi, prawda,
jak się zachowuje, jak działa.
Także tu chodzi o wszystkie typy
testowania, stąd te koszty są tak
wysokie.
Czy coś może jeszcze Państwo
macie jakieś pytania, uwagi?
No to popatrzmy teraz na wady
i zalety takiego
modelu. Zaczniemy od zalet.
...
Mianowicie
łatwo jest, proszę Państwa,
zarządzać
takim projektem, który jest
prowadzony według tego modelu
wodospadowego.
No, właśnie.
Łatwo jest przygotowywać plany,
łatwo jest robić harmonogramy,
łatwo
można monitorować
realizację takiego
projektu. Dlaczego łatwo
można monitorować
taki projekt?
Dlatego, że, proszę Państwa,
tutaj każda
faza, ja potem Państwu
pokażę te fazy
troszkę dokładniej,
jak gdyby z podziałem jeszcze na
na bardziej szczegółowe fazy,
na przykład projekt ogólny,
projekty szczegółowe, każda
z tych faz kończy się
czymś, co
fizycznie istnieje.
Mówi się,
używa się takiego określenia
kamienie milowe.
Powstają w wyniku zakończenia
takiej fazy. Czyli
tutaj mamy dokument,
który określa,
co ten system ma robić,
przy jakich ograniczeniach
ma pracować.
Mamy projekt systemu w tej fazie
drugiej. Mamy kod.
Mamy wyniki testów.
Czyli tutaj są po prostu
pewne fizycznie
istniejące
byty, dokumenty,
które mówią nam
zakończono daną
fazę. A więc jest
łatwo monitorować
realizację
projektu, który tą metodą
jest robiony.
Mamy tutaj narzucenie
tej kolejności wykonywania prac,
co łatwiej
nam jest, prawda, pewne rzeczy sobie
też zorganizować.
Ale to jednocześnie
stanowi wadę tego
modelu, dlatego,
że no mamy
tutaj, prawda, pewną
sekwencję
czynności i to jak gdyby
wydłuża czas produkcji, więc
staramy się to troszkę inaczej
zorganizować. Pokażę Państwu za chwilę
jakiś przykład.
No i teraz proszę Państwa
tak, ja wspomniałam o tym,
że często trzeba powracać
do fazy poprzedniej,
a czasem nawet jeszcze wyżej.
I w związku
z tym mówiłam Państwu,
że tutaj jak
pokazywałam jeszcze raz te fazy,
prawda,
to mówiłam Państwu, że no czasem
trzeba wracać do fazy poprzedniej,
a czasem się trzeba cofać
dużo, dużo wyżej.
No i w związku z tym proszę Państwa
tak, mówiłam, że kluczem do sukcesu
jest tu dobra specyfikacja
wymagań. Bo jeżeli
mamy braki w specyfikacji
wymagań, to będą braki w projekcie.
Jak mamy braki w projekcie,
to będą problemy
z kodem.
I to może wyjść na etapie
testowania, trzeba będzie się
wrócić aż tutaj, więc
będzie to znacznie
podnosiło koszty
produkcji i tego
oprogramowania.
A więc tutaj kluczowe jest
właściwe, dokładne
przygotowanie specyfikacji wymagań.
Jeżeli tutaj mamy
od razu wiemy, że ona jest
nieprecyzyjna, niepełna,
no to bardzo
duże koszty będą się wiązały
z tym, prawda, z tymi powrotami
do tych faz
wcześniejszych i uzupełnianiem
tego. Tutaj jeszcze proszę Państwa
też jest taka rzecz, że jak gdyby
błędy popełnione w pewnej
fazie przeciekają
do faz następnych, prawda.
I teraz pytanie, na którym etapie one
zostaną wykryte.
Jeżeli zostaną wykryte
na tym etapie następnym,
no to te koszty ich usunięcia jeszcze
są stosunkowo nieduże.
Ale im dalej, tym gorzej.
I proszę Państwa
weźmy sobie teraz może taki
przykład.
Jeżeli powiedzmy poprawienie
błędu na etapie
pisania kodu
kosztuje nas jeden,
to na etapie
testowania, jak myślicie,
czy tutaj możemy mówić
o testowaniu na przykład
takim jeszcze,
kiedy jak gdyby
testujemy na przykład
jak gdyby
u nas w firmie
ten system,
a drugi typ testowania, kiedy
testujemy już tylko powiedzmy
funkcjonalność tego.
Czyli testujemy na przykład
poszczególne tutaj część
tego systemu
i testujemy tutaj już
jak gdyby cały system od strony
funkcjonalnej. No to tutaj
te koszty to powiedzmy
zaczną się od pięciu, siedmiu
dojdą do na przykład piętnastu.
Wtedy kiedy ten system jest u nas
w firmie. A teraz proszę
Państwa jeśli ten błąd
został wykryty już
na etapie użytkowania systemu
to tutaj koszty
usunięcia tego błędu będą
sto razy wyższe.
Więc
podaję Państwu
te przykładowe
koszty tutaj jak gdyby zakładając,
że tutaj jest jeden,
tutaj będzie zero trzy, zero dwa,
tu będzie zero pół mniej więcej.
Żebyście Państwo byli świadomi
tego jak istotne jest
to, żeby to mieć dobrze
przygotowane, bo to
te błędy przeciekają do faz następnych,
trudniej jest je wykryć w tych fazach
następnych, a koszty
usunięcia ich w fazach następnych,
rosną. I tutaj jak widzicie
kluczowe jest, żeby te błędy
wykryć wtedy kiedy to oprogramowanie
jeszcze jest u nas w firmie,
która je produkuje, a nie wtedy
kiedy zostanie ono oddane
już użytkownikowi,
no bo wtedy te koszty poprawienia
tego błędu są tak jak Państwo widzicie tutaj
sto razy większe niż
wtedy kiedy to jest
u nas w firmie.
Czy może tutaj
do tego mają Państwo jeszcze jakieś
uwagi?
Komentarze?
No właśnie, czyli ta
kolejność tych prac też stanowi
pewien problem.
Wspomniałam o tych problemach
związanych z błędami, które
ewentualnie popełnimy we wczesnych
fazach. I też już
o tym wspomniałam, że mamy
tutaj długą przerwę w
kontaktach z klientem.
Więc jest to niebezpieczne,
bo możemy
w międzyczasie te
oczekiwania klienta
mogły się na tyle zmienić,
że po prostu
zrobimy system, który zupełnie
nie będzie trafiał
w jego potrzeby,
w jego oczekiwania.
Proszę Państwa i takie przykłady mieliśmy
nawet tutaj w administracji polskiej,
kiedy jak gdyby
robiono pewien system
dla administracji.
Na tyle długo trwała
ta jego produkcja,
że jak wyprodukowano system,
to się okazało, że się wszystko zmieniło
już jeśli chodzi o stronę
organizacyjną i prawną
i system poszedł do śmieci.
Także trzeba na to
zwracać uwagę i jak gdyby
bardzo duże systemy
w ten sposób nie powinny być realizowane
właśnie ze względu na tą długą przerwę
w kontaktach.
Jeszcze raz
ponawiam pytanie, czy może coś się Państwu
przypomniało?
Chcecie się o coś spytać?
Macie jakieś swoje komentarze
czy swoje doświadczenia
ze stosowaniem tej metody produkcji?
Proszę Państwa,
mówiłam Państwu, że ten model
jest bardzo dobrym modelem,
jest lubianym przez kierowników projektów,
bo łatwo jest tym modelem
zarządzać,
łatwo jest monitorować,
łatwo jak gdyby sprawdzać,
czy mieścimy się w harmonogramie,
czy mamy harmonogram
jak gdyby opóźniony
albo może wyprzedzamy go.
Więc popatrzmy, jakie
są rezultaty faz
tego modelu.
Ja
tutaj już pewne rzeczy na tym takim
modelu podstawowym, ogólnym Państwu
wymieniłam, a teraz
popatrzmy, ten model wodospadowy
będzie taki troszkę
dokładniejszy.
Mianowicie, jeśli chodzi
o analizę wymagań,
to ona jest tutaj, proszę Państwa,
jak gdyby zazwyczaj
w dwóch takich fazach
realizowana.
Pierwsze, tak jak Państwu pokazywałam
na tym takim slajdzie
z tymi kreskami,
na tym,
że tutaj mamy, prawda,
to w fazie strategicznej
to określanie wymagań,
a tu mamy ich doprecyzowanie,
które już wchodzi w analizę.
No właśnie, to mamy je podzielone
teraz na właśnie
takie dwie fazy, na analizę
i na definicję.
I ta analiza
to jest takie
główne funkcje, jakie ten system
ma spełniać, takie zgrubne
wymagania. Natomiast definicja
wymagań, to już jest to
po tej analizie wymagań,
to jest dokument, który dokładnie
je opisuje. Czyli
tak jak Państwo widzicie, powstają tutaj
dwa rezultaty.
W tej fazie pierwszej,
w tym studium wykonalności,
w tej fazie strategicznej,
bo to studium wykonalności robimy w fazie
strategicznej, mamy
dokument, który takie
główne funkcje tego
oprogramowania opisuje,
również pewne takie
ważne ograniczenia,
jakie ono ma spełniać,
też zawiera. Ale potem
musimy te wymagania doprecyzować
i mamy już te
precyzyjnie opisane wymagania,
zdefiniowane wymagania,
mamy dokument,
który je opisuje. Czyli tu jest
kolejny dokument, który powstaje.
I tutaj,
proszę Państwa, jeszcze
mamy, jak gdyby
na tym etapie wstępnym,
jeszcze mamy trzecią,
jak gdyby, taką fazę, którą robimy.
Po tym, jak wiemy już,
jak ten system
ma działać, co ma
robić, no to możemy
przygotować właśnie tak zwaną specyfikację
systemu. Czyli po pierwsze
mamy tutaj, co ten
system ma robić, mamy tak zwaną
funkcjonalną
specyfikację systemu
i, proszę Państwa, na tym etapie
opracowujemy
testy akceptacyjne.
Czyli tutaj
już przygotowujemy,
jeszcze nie ma w ogóle systemu,
ale już przygotowujemy,
jakie testy trzeba
będzie wykonać potem, zanim
oddamy ten system do
użytkownika, które sprawdzą,
czy rzeczywiście te funkcje są
realizowane. No i to,
o czym Państwu też już wspominałam,
tutaj powstaje szkic podręcznika
dla użytkownika, bo wiemy,
co ten system ma robić, więc
taki zarys
podręcznika dla użytkownika
powstaje. Czyli
ten pierwszy etap,
specyfikacja wymagań,
w praktyce
to są, jak gdyby, jeszcze trzy
kroki tutaj kolejno wykonywane.
Najpierw takie spojrzenie
od góry na to ogólne,
co ten system ma robić,
potem
właśnie
doprecyzowanie tych wymagań,
opisanie ich dokładne
i również opisanie
systemu,
no bo tu już mamy te wymagania,
przygotowanie
szkicu podręcznika
dla użytkownika i
opracowanie testów
akceptacyjnych. Testy akceptacyjne,
czyli testy, które będą
sprawdzały, czy faktycznie
te funkcje
system realizuje. Także mamy tu
aż trzy takie, no kilka
dokumentów, które powstaje. Łatwo
jest nadzorować,
prawda,
sprawdzić, czy faktycznie
one powstały.
I to jest ta faza pierwsza, faza
specyfikacji wymagań. To, co tam
na tym pierwszym slajdzie było jako
pierwszy krok.
Teraz drugim krokiem
było projektowanie.
I tutaj to projektowanie
też, no
jak gdyby, składa się z
kilku kroków, z kilku takich
faz. Mianowicie
zaczynamy od projektowania
architektury
systemu.
Czyli zastanawiamy się
z jakich części ten system
się powinien składać.
Zastanawiamy się
nad tym, jak one
ze sobą powinny sobie
przekazywać
pewne dane.
A więc
mamy architekturę
systemu. Na przykład z jakich modułów,
czy z jakich podsystemów ma się
składać. Za co
poszczególny moduł,
podsystem są odpowiedzialne.
Co one mają robić, jakie funkcje
mają realizować.
I jak mamy taką architekturę
systemu, to tu
przygotowujemy tak zwane testy
systemowe. Czyli no właśnie
testy, które będą sprawdzały
te połączenia i tą
architekturę.
Znaczy będą sprawdzały
cały ten system.
Teraz kolejny etap
to jest proszę Państwa, jak tutaj mamy
tą architekturę, czyli mamy jakieś
te moduły, podsystemy,
z których to się ma składać,
to musimy zaprojektować
również jak one
będą ze sobą współpracowały.
Czyli kolejny etap
to są interfejsy
pomiędzy tymi częściami,
które tutaj żeśmy
zdefiniowali. Musimy
je wyspecyfikować.
I przygotować
testy integracyjne.
Czyli testy, które będą sprawdzały
poprawność połączeń. Czyli na przykład
jeśli żeśmy ten system tak połączyli,
no to będą sprawdzały
tutaj poprawność tych
połączeń.
Co dalej?
Dalej proszę Państwa mamy
tak, projekt architektury.
Wiemy jak te
części ze sobą się mają
komunikować. Czyli mamy projekt
interfejsów.
To teraz proszę Państwa możemy
wejść w projekty
szczegółowe poszczególnych jednostek.
I
również
przygotować dla nich testy
jednostkowe.
Kolejny etap
to jak Państwo pamiętacie była
implementacja, czyli przygotowanie
kodu programu.
No i teraz proszę Państwa
zaczynamy to
pierwsze
testować te jednostki.
Czyli tu
testy jednostkowe były przygotowane
jak żeśmy projekty robili.
Więc wykonujemy te testy.
Wykryte
błędy są poprawiane.
Znowu wykonujemy te testy.
Tak aż już wszystko będzie,
znaczy nie pojawią się
komunikaty o błędach.
Teraz zaczynamy te jednostki
składać troszkę
większe części
w moduły, podsystemy.
Też je testujemy.
Też mamy pewien dokument, który
zawiera
rezultaty tego
testowania. Znowu jeśli
wykryto błędy, to
wycofujemy się,
poprawiamy te błędy.
Jak to wszystko już, poszczególne
moduły są
przetestowane, nie wykazują
żadnych błędów, to
zaczynamy je składać.
Czyli wykonujemy
już tutaj testowanie
integracyjne i też
oczywiście mamy tutaj
raporty z tego testowania
i na tym etapie już mamy go,
powinniśmy mieć gotowy podręcznik
dla użytkownika, bo jeżeli już
mamy tutaj te testy integracyjne
zrobione, no to znaczy, że mamy
cały ten system w zasadzie gotowy.
A więc możemy jeszcze
cały ten system przetestować
tym testowaniem systemowym,
a następnie
wykonać testy
akceptacyjne,
czyli testy, które sprawdzą
czy rzeczywiście
funkcje tego systemu
są takie jak
umówiono się, że mają być,
tak jak występują
w specyfikacji.
No i na tym etapie mamy
gotowy system i mało tego
mamy gotową dokumentację,
bo zarówno mamy te dokumentacje
projektowe z poprzedniego
slajdu,
te dokumentacje projektowe
typu projekty
właśnie
czy architektury,
czy interfejsów,
jak i mamy
tutaj już gotowe
raporty testowania,
gotowy test,
gotowy system i dokumentację
jego.
Jakieś pytania, uwagi?
Obserwacje?
Nikt nic nie ma?
Wszyscy Państwo już
się poznali?
Czy jeszcze ktoś jest
przytomny?
Jesteśmy, jesteśmy.
Dobrze, bardzo się cieszę,
proszę Państwa,
teraz chcę pokazać Państwu
różnice pomiędzy dwoma słowami,
które bardzo często
są używane, no i
nie zawsze we właściwym znaczeniu.
Mianowicie
weryfikacja i walidacja.
I to są
słowa, które są
no często nawet w jakiś
tam powiedzmy
publikacjach
mylone,
właściwie używane.
Co to jest weryfikacja?
Otóż, proszę Państwa, weryfikacja
to jest odpowiedź
na pytanie, czy my
właściwie budujemy pewien produkt.
A dokładniej
to jest sprawdzenie,
czy on spełnia wymagania.
Czyli musimy mieć te wymagania
na przykład zapisane
w dokumencie,
w specyfikacji
i weryfikujemy,
sprawdzając, czy te funkcje
faktycznie system realizuje.
Czyli tutaj już widać,
że taka weryfikacja
może i powinna
być robiona w firmie,
która to oprogramowanie realizuje.
Która to
oprogramowanie produkuje.
Produkcyjnie.
Natomiast co to jest
walidacja?
Walidacja to ma być odpowiedź
na pytanie, czy to jest właściwy produkt.
Ale
tutaj
chodzi o to,
czy to jest produkt właściwy
dla użytkownika, dla klienta.
Czyli istotną
sprawą jest, że
walidacja musi
być
przeprowadzona
z udziałem klienta,
czy jak gdyby jego reprezentantów.
Jeszcze raz. Weryfikacja
sprawdzenie, czy oprogramowanie
realizuje wymagania
i to powinna robić
firma, która buduje to oprogramowanie
i jej ludzie.
Natomiast jeśli chodzi o
walidację,
no to tutaj
walidacja powinna się odbywać
z udziałem właśnie
tego przyszłego użytkownika.
Bo to on ma się
wypowiedzieć, czy faktycznie
funkcje są takie,
jakie jemu są potrzebne.
No i teraz, proszę Państwa,
wróćmy do tego modelu
wodospadowego,
gdzie
mówiłam Państwu, że
kontakt mamy
z użytkownikiem
wtedy,
kiedy
przygotowujemy
specyfikację wymagań
i potem wtedy, kiedy
instalujemy ten system,
to możemy
przeprowadzić
weryfikację.
Więc
oczywiście,
jak korzystamy z modelu
wodospadowego,
to możemy przeprowadzić
weryfikację, bo mamy
tutaj te wymagania
i tutaj zanim oddamy
ten system w użytkowanie,
to powinniśmy tą weryfikację
przeprowadzić.
Sprawdzić w firmie produkującej,
czy te wymagania są realizowane.
Natomiast walidacja
musi być realizowana z udziałem klienta.
No i teraz w przypadku,
kiedy ten proces produkcji
trwa zbyt długo,
tutaj mogą się tak zmienić
oczekiwania klienta,
że może być tak,
że weryfikacja
przebiegła pozytywnie,
wykonaną,
przebiegła pozytywnie,
a walidacja nie przejdzie,
bo klient już ma
takie potrzeby,
bo zmieniły się jakieś
przepisy, wymagania
i walidacja nie przejdzie,
bo jest ta długa przerwa
w kontaktach z klientem.
Więc mówi się, że ten
model wodospadowy
bardzo wygodny dla kierowników projektu,
no może być stosowany
tylko wtedy, kiedy
dokładnie przygotujemy
tą specyfikację wymagań
i kiedy ten proces produkcji
nie trwa zbyt długo.
Znaczy nie trwa zbyt długo,
no to różnie, różne firmy
do tego podchodzą, czy to jest kwestia
trzech miesięcy,
ogólnie można powiedzieć, że na pewno
nie więcej niż rok, bo wtedy
to już jak gdyby więcej się
może tutaj po stronie klienta zmienić
i możemy nie trafić
z tym systemem zupełnie.
I to by było
na tyle, jeśli chodzi o
system, model
procesu produkcji
w
wodospadowy, czyli ten pierwszy
historyczny, inaczej
kaskadowy.
Tutaj jeszcze raz go pokazuję
z takim dokładniejszym
rozpisaniem poszczególnych faz.
Wiemy już, co to jest weryfikacja.
Wiemy, co to jest
walidacja.
Wiemy, że model
wodospadowy tylko wtedy, kiedy
jesteśmy w stanie dobrze
przygotować specyfikację wymagań.
A więc na przykład wtedy,
kiedy to jest
system w jakiejś dziedzinie
tworzony takiej, że
to nie jest pierwszy system w tej dziedzinie
tworzony i mniej więcej wiadomo,
co taki system robić powinien.
No a co wtedy,
kiedy nie możemy tych
wymagań dobrze przygotować,
wiemy, że
nie będą one dokładne.
Otóż w takich
przypadkach
możemy
stosować
tak zwane
exploratory programming
albo inaczej model odkrywczy.
Czyli
nie będziemy w stanie
przygotować
dokładnych wymagań klienta.
Bo na przykład jest to zupełnie
nowa dziedzina zastosowań.
Jak wtedy
postępujemy?
Otóż
stosujemy
model ewolucyjny,
przygotowujemy
specyfikację, ale
my wiemy,
że ta specyfikacja
będzie niepełna.
Ona jest
zgrubna taka.
Wiemy, że jest niepełna,
ale jednak ją przygotowujemy.
Na podstawie tej
niepełnej specyfikacji
...
...
Proszę Państwa,
zróbmy dwie minuty przerwy,
bo jak gdyby mnie jakiś kaszel złapał,
więc
chwileczkę przerwy.
Ja spróbuję.
Może za chwileczkę
będzie łatwiej.
...
...
...
...
...
...
...




...
...
...
...
...
...
Dobra, proszę Państwa, spróbuję.
Ja mam astmę
i jak widać przed chwileczką
właśnie taki atak się
trafił. To też wynika
z tego, że struny głosowe
jeszcze się nie przyzwyczaiły do takich
czterygodzinnych wykładów.
Troszkę się buntują,
ale myślę, że będzie lepiej.
Dobra, więc proszę Państwa wracam
do tego modelu ewolucyjnego.
Wiemy, że ta specyfikacja
będzie niepełna,
ale jednak ją przygotowujemy.
Na podstawie
tej niepełnej specyfikacji
budujemy system
...
...
...
...
...
....
...
ważne jest, że tu ma być szybko,
...
...
...
...
...
i pracując
na tym systemie
odkrywa,
co mu jeszcze jest potrzebne,
bo tutaj w tej
wersji początkowej nie był
sobie wyobrazić
wszystkiego tego co by chciał od tego
jak gdyby odkrywa nowe potrzeby
my dodajemy te nowe
elementy
oddajemy kolejną wersję
no i tak
i tak tutaj się
kręcimy
ja tutaj pokazałam takie wyjście z tej pętli
wtedy kiedy użytkownik powie
hura jestem zadowolony z tego
co ten system robi
robi to co bym chciał
żeby robiło
ale no niekoniecznie
tak to się może skończyć
bo
co się dzieje
jak no właśnie
musimy szybko coś
dodawać do tego systemu i coraz
to dodajemy nowe rzeczy
jak państwo myślicie czy w takiej sytuacji
tutaj na bieżąco jest
nie wiem dokumentacja projektowa
robiona
tak
to jak wiemy że za chwilę będzie nowa wersja systemu
nie robi się tu dokumentacji projektowej w trakcie
prawda tylko ewentualnie na końcu
to jest jak gdyby jeden problem
więc może dojść w jakimś momencie do sytuacji kiedy po prostu my nie wiemy jak te nowe poprawki tam wprowadzić bo
bo ci koledzy którzy przy tym systemie pracowali to przeszli do innej firmy
i już nikt się w tym systemie nie orientuje
druga sprawa to jest taka że jak na szybko coś budujemy
prawda
no to wiadomo że ta struktura
będzie strukturą niedobrą
nieefektywną tam będzie dużo tego
tych powiązań
więc może być jeszcze problem związany
z tym że w jakimś momencie
ta struktura tego kodu
już będzie tak
zaplątana że nie będziemy w stanie
wprowadzić poprawek
taki kod nazywa się często spaghetti kod
no i teraz zastanówmy się
właśnie kiedy
taki
system można stosować
jakie są jego wady i zalety
a więc zalety
no tutaj pokazałam państwu że
nie zawsze
jesteśmy w stanie określić wymagania
klienta a ten
system nam na to pozwala
prawda że zaczynamy
z jakąś wersją wstępną
prawda i on
stąd się nazywa ewolucyjny albo odkrywczy
że użytkownik jak gdyby
odkrywa co faktycznie ten system
robić powinien
czyli
możemy stosujemy go w takich przypadkach
kiedy wiemy że precyzyjne
że precyzyjna
określenie wymagań
klienta nie jest
możliwe
właśnie
wspominałam państwu o tym że ta struktura
systemu będzie niedobra
że może dojść do sytuacji że
w jakimś momencie nie będziemy w stanie
po prostu już dodać nowych
możliwości do tego systemu
bo już nikt się nie orientuje w tym
kodzie
i tutaj proszę państwa też
wspomniałam o tym że ta produkcja
musi być bardzo szybka
stąd
używamy tutaj środowisk
typu RAD
Rapid Application Development
używamy
takich języków jak
LISP czy jak Prolog które
pozwalają nam też szybko
przygotować
coś działającego
jaki jest
również problem
tutaj z
oprogramowaniem
nie wiem czy ktoś z państwa zna
Prolog albo LISP
nie słychać
nikt się nie odzywa
proszę państwa tutaj
problem z tymi
językami polega
szczególnie one nie są łatwe
w stosowaniu
ale problem polega również na tym
że efektywność
działania takiego programu
wypisanego w tym Prologu też jest
dosyć kiepska więc stąd
te programy
nie są
szybkie
nie są efektywne
ale proszę państwa
ale pozwoliło nam to wyjść
z tej sytuacji kiedy te
wymagania klienta były niejasne
więc tą metodę
ewolucyjną
możemy
stosować
no właśnie wtedy kiedy
kiedy
kiedy ta metoda wytrzymała się w tym Prologie
te wymagania są
nie do końca znane
bo ten klient odkrył te wymagania
tutaj wspomniałam o tej kiepskiej
prawda ewentualnej
efektywności tego systemu
inny problem
to jest to
no tutaj mówiłam państwu że
jak gdyby dokumentacji na bieżąco
się nie tworzy no można tam
na końcu próbować jakąś dokumentację zrobić
ale ta struktura będzie
tak zagmatwana że ta dokumentacja
też będzie kiepska
stąd możemy mieć problemy
z pielęgnowaniem takiego systemu
tutaj często
struktura tego systemu
jego budowa jest w głowie jego twórców
jak oni nie wiem
odejdą albo zapomną
no to koniec to nie jesteśmy w stanie
tam nic zrobić
więc to jest pewien problem
teraz przed chwileczką żeśmy się nauczyli
co to znaczy weryfikacja
co to znaczy walidacja
i ponieważ tutaj
ta specyfikacja jest
no ewidentnie niepełna
nieprecyzyjna
wobec tego przy tej metodzie produkcji
nie ma mowy o weryfikacji
prawda tutaj jedynie jest ta walidacja
tutaj klient nam mówi
no jestem zadowolony
z tego co ten system robi
albo no nie jestem
zadowolony z tego jakie możliwości
ten system mi daje
także tutaj jedynie
walidacja jest możliwa nie ma weryfikacji
teraz no
w związku z tym że widzicie Państwo
tutaj tych wad jest dosyć dużo
więc często tą metodę ewolucyjną
stosuje się
do przygotowania
tak zwanego
oprogramowania prototypu operacyjnego
czyli takiego oprogramowania
które działa
pracuje tak jak trzeba
no ale ma właśnie takie wady
prawda nie mamy dokumentacji
ta struktura jest kiepska
ale odkryliśmy wymagania
i teraz już
na przykład klient sobie pracuje
na tej wersji
tego oprogramowania
a my już mamy tutaj określone
wymagania możemy
korzystając z modelu wodospadowego
przygotować
taką dobrze zorganizowaną
wersję dobrze
ustrukturyzowaną wersję oprogramowania
przygotować dokumentację projektową
i w jakimś momencie
po prostu podmienić te systemy
ten prototyp operacyjny
podmienić na to oprogramowanie
które zostało
przygotowane
no na podstawie tych wymagań
ale już ma dobrą strukturę
dobry projekt dobrą dokumentację
czy może mają Państwo
jakieś pytania
związane z
tym
podejściem ewolucyjnym
inaczej odkrywczym
czyli wtedy kiedy
wiemy że wymagania klienta
nie będą
mamy w stanie dobrze określić
na przykład
systemy sztucznej inteligencji
ja już tutaj przed chwileczką
użyłam określenia
prototyp operacyjny
no to teraz jeszcze
proszę Państwa troszkę chcę powiedzieć
o prototypowaniu
które w produkcji oprogramowania
właściwie zawsze
się powinno stosować
może niekoniecznie do całego systemu
więc popatrzmy
jak to prototypowanie
mogłoby wyglądać
czy powinno wyglądać
no też zaczynamy od ogólnego
określenia wymagań
też mamy szybko
przygotować działający prototyp
a więc te języki
o których wspomniałam
lisp prolog środowiska
typu rad tak żeby
szybko to coś działało
i dajemy prototyp
klientowi klient na nim pracuje
i też nam mówi
czy jest z tego zadowolony
czy nie
na tej podstawie określamy szczegółowo wymagania
czyli tutaj widzimy
że to trochę przypomina
ten model ewolucyjny
tyle że tu nie ma tej pętli
nie ma tego powrotu
tylko to jak gdyby jest raz
robimy dajemy na tym działa
i tu już mamy
nie podmieniamy tych warstw
na ogół
i na tej podstawie
przygotowujemy system
ja wspomniałam Państwu
że
że właściwie prototypy
przy produkcji
prawie każdego systemu
powinniśmy
stosować
czy może Państwo macie pomysł
na to jaka część systemu
zawsze powinna być prototypowana
user interface
bardzo dobrze
user interface
bo po pierwsze mamy narzędzia
które pozwalają nam taki prototyp
użytkownika szybko przygotować
i to jest proszę Państwa
taka rzecz którą jest dosyć trudno opisać
albo jeżeli będziemy chcieli
opisać to dokładnie
to ten opis będzie długi
i będzie nudny
tak jak zaczniemy pisać
że tło ekranu ma być w kolorze taki
ma ramka taka
to po prostu się nie da tego czytać
natomiast jeżeli
robimy prototyp
i od razu widzimy
że pewne napisy są czytelne
lub są nieczytelne
więc właściwie zawsze
interface użytkownika powinien być prototypowany
no i teraz popatrzmy
jakie
cele
już pewne cele wiemy jakie są
bo one prawda
mówiąc na takim prototypie
klient nam mówi
co jeszcze by chciał
czyli
wykrywa
pewne odkrywa
jakie możliwości
jakie funkcje to oprogramowanie
powinno spełniać
i takie funkcje nazywa się
trudnymi usługami
to są proszę Państwa takie rzeczy
które często
jak gdyby klient nam nie jest w stanie
nie powie nam tego
jeżeli zaczynamy przygotowywać
specyfikacje wymagań
no to rozmawiamy z klientem
ja o tym jakie są metody stosowane
to jeszcze będę trochę później mówić
ale na przykład rozmawiamy z klientem
co byś chciał żeby to
robiło tak ma robić
to to to
i jeszcze coś to
ale pewnych rzeczy nie mówi nam
bo pewne rzeczy dla niego
mogą być
no bardzo takie podstawowe
i jemu się wydaje że to jest na tyle
oczywiste
że wszyscy o tym wiedzą
i jak gdyby w ogóle tego nie wyartykułuje
i dopiero jak dostaje system
i widzi
że ta funkcja nie istnieje
w tym systemie
no to wtedy dopiero jest przerażony
a tak na tym prototypie
od razu to zobaczy
czyli właśnie takie funkcje
które bardzo często dla użytkownika
są bardzo podstawowe
bardzo oczywiste
tak oczywiste że on o tym nawet nam
mówi że jemu taka rzecz jest potrzebna
tutaj wychodzą
również braki w specyfikacji
proszę państwa bardzo często
jest tak że my
przygotowujemy na podstawie
tych wymagań które zebraliśmy
przygotowujemy
prototyp
ten prototyp tylko symuluje
działanie tych funkcji
one faktycznie nie są realizowane
ale jak gdyby od strony użytkownika
one są widoczne
i wtedy
użytkownik też pracując na takim
prototypie
widzi że pewnych rzeczy
ten prototyp nie robi
no nie robi dlatego że nie było tego
w tej specyfikacji wyjściowej
początkowej
także te braki w specyfikacji
nawet czasem jest tak że
zespoły które tworzą takie oprogramowanie
po prostu na swoje
własne potrzeby
taki prototyp szybko przygotowują
żeby jak gdyby zobaczyć
czy tam jakiś
sprzeczności
nielogiczności nie ma
celem prototypu
jest wykrycie nieporozumień
między klientem a właśnie
projektantami systemu
i tutaj właśnie to o czym jeden z panów wspomniał
to szczególnie ten
user interface to jest taka rzecz
którą tutaj bardzo
jak gdyby łatwo pokazać
ale
nie tylko prawda
ale również jakieś funkcje które
które projektant
wydaje mu się że powinny działać tak
a klient ma zdanie inne
ale co jeszcze
na co jeszcze prototyp nam pozwala
no właśnie możemy
zademonstrować pracujący
system nawet jeżeli
te funkcje nie są w pełni realizowane
tylko nawet jeżeli one są tak
markowane symulowane
mniej więcej widzimy jak to
miałoby się zachowywać jak to miałoby działać
także to jest też bardzo istotna
możliwość jaką
mamy w prototypach
no i
proszę państwa często prototypy
ale już takie prototypy
nazwijmy to operacyjne
czyli takie które te
funkcje mają nie markowane
ale faktycznie
do końca wykonywane
no to na nich się szkoli
personel tak
czyli właśnie
taki prototyp
na takim prototypie żeśmy
odkryli wszystkie funkcje
jakie system powinien zrealizować
mamy ten prototyp
on jest prawda no może
nieefektywny i nieładnie napisany
nie ma dokumentacji ale jest i działa
i na takim prototypie
szkoli się
personel
a my w międzyczasie pracujemy
nad no dobrze zorganizowanym
o dobrej strukturze
dobrze napisanym efektywnym
systemem który
wtedy w momencie instalacji
już użytkownicy będą przeszkoleni
będą umieli z takiego
systemu korzystać
jeśli chodzi o budowę
prototypu to już troszkę o tym mówiłam
no to właśnie albo jest to
programowanie ewolucyjne o którym
mówiłam
często korzysta się z gotowych
komponentów czyli
na przykład jakichś fragmentów oprogramowania
które w innych systemach
żeśmy użyli
stosuje to o czym
stosuje się niepełną realizację
czyli to co też przed chwileczką
mówiłam że pewne funkcje
są tylko markowane
jak gdyby jest możliwość ich
wywołania ale
faktycznie one jak gdyby nie wiąże
się zanim tam nie wiem zmiana w danych
czy w bazie danych czy gdzieś tylko jest
niepełna realizacja
w
właśnie stosuje się te języki wysokiego
poziomu o których wspomniałam
czyli na przykład prolog lisp
stosuje się środowiska
typu rad
tutaj jeśli chodzi o te
interfejsy użytkownika to mamy
też specjalistyczne narzędzia
generatory takich interfejsów
że bardzo łatwo jest ten interfejs
przygotować
dobra proszę państwa to by było tyle
jeśli chodzi o prototypy
czy może do tego mają państwo
jakieś pytania uwagi
w kwestii budowy user
interfejsów to nawet jeżeli jest
narysowany długopisem to już
czasem wystarczy za prototyp a bardzo
ułatwia życie
tak czasem się
robi takie
słusznie pan powiedział że długopisem narysowany
czasem się po prostu na
kartkach papieru rysuje
takie no jak gdyby
szkielety tego
jakby to miało wyglądać
i taka zabawa na tych kartkach
też czasem sporo
daje no jako taki punkt
wyjściowy na przykład a potem
właśnie skorzystanie z tych
ktoś z państwa może korzystał z takiego
narzędzia do generacji
interfejsów do szybkiego
przygotowania interfejsów
nie było takiej potrzeby tak nie ma
hmm
hmm
hmm
hmm
no dobra
to proszę państwa mamy chyba jeszcze
15 minut
tak dobrze mówię
zgodnie
z programem
a jeszcze chyba
pół godziny
15 min
do 11.15
chyba
hmm
zaraz zobaczymy co
hmm
a jeszcze mamy bo do 11.30
o to jeszcze mamy dużo czasu
hmm dobra
to proszę państwa
hmm
teraz jak gdyby
kolejna kolejna
tutaj możliwość
hmm
mianowicie
formalne transformacje
hmm
ja wspomniałam dzisiaj
że
mamy
hmm
mamy jak gdyby
istotną sprawą jest przygotowanie
tych specyfikacji na przykład w modelu
prawda wodospadowy
bo bez tego ani rusz
i wspomniałam o tym że te
błędy w tych specyfikacjach
przeciekają do następnych
faz że im później
je wykryjemy tym
wyższe są koszty
natomiast dosyć
trudno jest sprawdzić te
specyfikacje to znaczy
sprawdza się je
czyta się je wielokrotnie
analizuje
no ale no
wiadomo że jest to dosyć nudne
nieprzyjemne
no a pomysł był taki no to
może byśmy te specyfikacje
zapisali
w jakiś sposób formalny
żeby można było
pewne rzeczy
wykryć poprzez
nie wiem udowadnianie
czegoś jakiś
twierdzeń
i stąd pojawił się
pomysł formalnych
specyfikacji
które
i to w dodatku starano się wymyśleć
tą notację formalną
w taki sposób
czy jak gdyby
wykorzystać istniejące
notacje formalne tak
żeby z tego języku formalnego
z tego formalnej specyfikacji
po pierwsze na niej
dało się pewne rzeczy sprawdzić
udowodnić
na przykład sprawdzić czy nie ma
sprzeczności w wymaganiach
jeżeli napiszemy
słowami opiszemy wymagania
to bardzo trudno
nam będzie
wykryć musimy szukać jakiejś
głów żeby
zauważyć że wymaganie
na przykład 1.5
jest sprzeczne z wymaganiem
2.7
więc trzeba
dokładnie te teksty analizować
natomiast jakbyśmy to zapisali
w pewnej notacji formalnej
no to może by się
dało takie sprzeczności
wykazać udowodnić
znaleźć
no i stąd
jak gdyby pomysł tych formalnych
specyfikacji
co dalej dalej to
pomyślano sobie tak no jak
ja mam taką formalną specyfikację
i ta formalna
specyfikacja jest sprawdzona
udowodniona że ona jest
dobra
to teraz byśmy chcieli
automatycznie wygenerować
kod
dlatego że właśnie pisząc
ten kod robimy błędy
więc
jeżeli ten proces będzie
procesem automatycznym
to nie będzie tych błędów w kodzie
no i udało się tak to zrobić
są takie formalne
specyfikacje
ja przewiduję
że ja
no nie wiem może godzinę
wykładu poświęcę
na to żeby państwu jakieś
po prostu nie uczyć ich
bo samo uczenie tego jest
no trudne i to wymaga wielu godzin
ale żeby państwu pokazać
taki przykład takiej formalnej
specyfikacji to jest
na przykład jedna z takich notacji
to jest
tak zwane Z-models
które generacja idzie
generacja idzie na przykład do C
czy
czy B-metod generacja idzie
do kodu w jawie
więc
no więc właśnie
zaletą takich formalnych transformacji
jest bardzo wysoka
niezawodność bo po pierwsze
mając pewien zapis formalny
możemy na nim
wiele rzeczy wykazać
udowodnić sprawdzić
jak pójdzie automatyczna
transformacja w kod
to nie mamy błędów w tym kodzie
ten kod jest
jest kodem poprawnym
więc no więc idea
jest super jakie mamy
teraz problemy z tym związane
no obiecałam państwu
że pokażę takie przykłady formalne
specjalnych specyfikacji
nie wiem może
za dwa tygodnie może na następnym
wykładzie może troszkę później jeszcze
może na trzecim wykładzie
zobaczycie państwo że to wcale
nie jest ja pokażę państwu jakieś bardzo
proste rzeczy w ten sposób wyspecyfikowane
czyli na przykład pokażę państwu
nie wiem współrzędne
kartezjańskie albo
no coś prostego albo listy
i zobaczycie państwo
że to wcale nie jest takie proste
więc
to nie jest łatwo
w taki sposób formalny
to wymaga w ogóle innego
innego myślenia
innego jak gdyby podejścia
nie każdy z nas jest w stanie
w taki sposób jak gdyby matematyczny
myśleć i pewne rzeczy wyrażać
bo to się operuje oczywiście
pewną notacją matematyczną
pracuje się tu na zbiorach funkcjach
relacjach
nie każdy z nas jest w stanie
no na tym poziomie jak gdyby coś
opisywać
nie jest to łatwe
tutaj ja napisałam
mała efektywność kodu
to nie do końca jest już
aktualne
dlatego że tu wspomniałam państwu
że jest możliwość
generacji kodu w jawie
z takiej notacji b
która jak gdyby
jest i proszę państwa
i to już jak gdyby w tej chwili
ten kod jest kodem
no zupełnie dobrym
mało tego
już ileś lat temu
w Paryżu jedna z linii metra
miała właśnie
oprogramowanie w taki sposób
formalny
opisane
jeśli chodzi o pewne funkcje
i to jest proszę państwa oprogramowanie
sterujące pociągiem
ta linia metra jeździ
bez pana kierowcy
tylko w oparciu o ten
właśnie system który został
automatycznie wygenerowany
i tu kod był wygenerowany do jawy
i ten kod w jawie steruje tym
ruchem pociągów
no i steruje dobrze prawda
nie ma tam odpukać na razie
żadnych problemów to od wielu wielu lat
działa
więc jeśli chodzi o tą efektywność kodu
to to na początku tak było
a w tej chwili to to już nie jest prawda
no również wynika stąd
że te procesory są coraz szybsze
więc coś co kiedyś było wolne
działało wolno to w tej chwili już ma to
jakoś zadowalająco
ale proszę państwa jeszcze czasem
niekoniecznie
korzysta się ten kod który jest
automatycznie wygenerowany
to jest kod
no ewidentnie nadmiarowy
i tu ja też państwu chyba taki przykład
pokażę w jakimś tam
na tym jednym wykładzie
człowiek popełnia błędy
ale człowiek jest inteligentny
i pewne rzeczy jest w stanie zrobić
prawda lepiej
efektywniej niż
no niż to co nam wyjdzie z tego automatu
więc proszę państwa
szczególnie
no teraz już nie ale
ale można było również robić tak
że właśnie z tej formalnej specyfikacji
tak
po pierwsze jak mamy taką formalną specyfikację
to można
na jej podstawie napisać kod
w cudzysłowie ręcznie
czyli programiści
piszą
a druga metoda
no to właśnie wygenerować ten kod
generacja tego kodu
mamy tutaj tu był kod 1
tu mamy kod 2
ten automatycznie wygenerowany
będzie na pewno dłuższy
ten
no jak mamy inteligentnych
programistów
będzie krótszy szybszy
lepiej działający ale
czy to jest faktycznie dobry kod
no to proszę państwa
teraz są narzędzia
które są w stanie sprawdzić
czy zachowanie tego kodu
i zachowanie tego kodu
czy one są równoważne
i odpowiedzieć na pytanie tak
a jak nie
to wskazać w którym miejscu
więc można wtedy ten kod przygotowany
manualnie
można poprawić prawda
i żeby on się zachowywał tak
jak ten kod automatycznie wygenerował
też jest taka możliwość
ja tu państwu pokazałam taką strzałeczkę
że z tych formalnych specyfikacji
też możemy kod po prostu przygotować
ręcznie
niekoniecznie musimy generację tego kodu robić
no i tutaj powiem państwu
taką historyjkę mianowicie
w jednej z firm
produkujących
oprogramowanie dla
telekomunikacji we Francji
była bardzo kiepska jakość
tego produkowanego kodu
i mieli duże problemy z jakością tego kodu
no i tam
odważną decyzję
szefowie wprowadzili
szefowie powiedzieli wszystko teraz
jak to oprogramowanie
ma się zachowywać
piszemy w formalnych specyfikacjach
no ponieważ
nie jest łatwo
te formalne specyfikacje przygotować
więc musieli praktycznie wymienić
swoich pracowników na nowych
a
ale
na podstawie tych formalnych specyfikacji
kod był pisany ręcznie
i już okazało się
że jest
no ogromna poprawa
w niezawodności tego kodu
to kod po prostu dużo bardziej
niezawodny właśnie
bo te formalne specyfikacje były
precyzyjne były dokładne
więc stąd iż też ten kod był
kodem
bardziej niezawodny
i
czy ktoś z Państwa widzi
a może
pierwsza rzecz jest taka
proszę Państwa
nie całe oprogramowanie
formalnie specyfikujemy
bo po prostu
pewnych rzeczy się nie da
formalnie wyspecyfikować
czego się nie da
formalnie wyspecyfikować
jak myślicie
jakiej części
systemu
no jakieś
pomysły
słucham
to co się dzieje w jądrze systemu
nie to co się dzieje w jądrze
to bardzo dobrze właśnie
do tego stosujemy formalne specyfikacje
ale czego się nie da
formalnie wyspecyfikować
przed chwileczką mówiłam
że do tej części się stosuje prototyp
na przykład
interfejs użytkownika
w której no te notacje formalne
się po prostu nie nadają
bo one nie mają tam żadnych
rzeczy związanych z formatowaniem
więc nie
natomiast
druga rzecz
czy na pewno nie
user interface
user interface
na pewno nie
nie da się formalnie wyspecyfikować
prototypy
generatory takich
czy nawet takie kartkowe
prototypy
ale prototyp
a nie formalna specyfikacja
natomiast tutaj
jeśli chodzi o formalne specyfikacje
to w ten sposób
specyfikujemy te części
systemu które są
odpowiedzialne za jego bezpieczeństwo
czyli tutaj dawałam Państwu
przykład tego systemu
który właśnie
system sterowania pociągiem
czyli
systemu gdzie
no niezawodność
bezpieczeństwo działania tego systemu
jest takie kluczowe
to tam stosujemy formalne specyfikacje
dzisiaj
użyłam takiego
określenia jak
safety critical systems
jak Państwo myślicie
czy safety critical systems
powinny być specyfikowane formalnie
tak
tak jak najbardziej
to jest właśnie jedno z zastosowań
proszę Państwa
i to jak gdyby coraz powszechniej
jest stosowane
oprogramowanie działające
w przemyśle właśnie wszystkie te linie
sterowania
to musi być
jest formalnie specyfikowane
w Wielkiej Brytanii jest norma
taka brytyjska
która mówi że właśnie
jeżeli jest realizowany system
który
ma mieć takie wysokie parametry
niezawodnościowe
to takie systemy
muszą być
formalnie wyspecyfikowane
chociaż niekoniecznie musi być
użyty ten kod który
będzie automatycznie wygenerowany
prawda czasem właśnie się ten kod pisze ręcznie
i porównuje zachowanie
tego kodu z jednego i drugiego systemu
czy coś może mają Państwo jakieś
czyli pokażę Państwu
no albo
na następnym wykładzie albo
jeszcze na następnym
takie przykłady formalnej specyfikacji
po prostu po to żebyście zobaczyli
jak to może wyglądać
no i również dlatego że
tak jak mówiłam coraz bardziej
powszechnie w przemyśle właśnie
w takich zastosowaniach
gdzie bezpieczeństwo systemu jest istotne
to te formalne
specyfikacje są wprowadzane
czy może coś
macie Państwo jakieś
pytania uwagi
czy do małych projektów
się stosuje takie formalne
zapisywanie
wie Pan do
małych projektów raczej
znaczy jeżeli to jest projekt jakiegoś
sterownika jakiegoś urządzenia
to na pewno warto to zrobić
ale jeżeli
to jest nie wiem powiedzmy
Pana projekt nie wiem
dyplomowy nawet no to nie ma sensu
się w to bawić
tutaj proszę Państwa
no nauczenie się tej formalnej specyfikacji
no to są zwykle
powiedzmy na uczelniach
wykład 30 godzinny
żeby jedną z takich specyfikacji
prawda pokazać
i nauczyć
więc to nie jest to prosta sprawa
czyli to prędzej
się spotkamy z tym
w jakiejś firmie w której będziemy
pracować ewentualnie
tak
w niektórych firmach
w niektórych firmach
robi się właśnie takie
czy formalne specyfikacje
czy robi się pewnego rodzaju modele
formalne bo jeszcze druga rzecz to są takie
modele formalne
i sprawdza
się czy to oprogramowanie
które jest
no napisane czy ono
jak gdyby jest zgodne z tym modelem
który
był realizowany
w Polsce również
w
w tej chwili uciekła mi
z głowy nazwa firmy
w Bydgoszczy duża
taka firma
w której właśnie
kiedyś jakieś szkolenia prowadziłam
i oni korzystali
z modeli formalnych przy
tworzeniu swojego oprogramowania
wyleciało mi z głowy
w tej chwili międzynarodowa firma
duża która
w Bydgoszczy miała swój oddział
dobra coś może
jeszcze macie jakieś pytania
uwagi komentarze
czy mała efektywność
kodu to jest coś zawsze
czy to jest można to zmienić
czyli można tak dobrze to opisać
że kod nie będzie mało efektywny
to ja już podkreśliłam
mówiłam że to troszkę jest już
no jak gdyby
niekoniecznie dzisiaj
to znowu zależy od tego
do jakiego celu
w wielu zastosowaniach ta efektywność
tego kodu jest wystarczająca
to co Państwu tutaj mówiłam
że na przykład dla
sterowania tym pociągiem
to było wystarczające
jest wystarczające na aktualnych procesorach
natomiast
mogą być
zastosowania takie
w których ten system sterowania
ma być niesłychanie szybki
taki na
i wtedy może się okazać
że jak gdyby czas działania tego kodu
automatycznie wygenerowanego
że może być za długi
no to wtedy się robi tak że się ten kod poprawia
prawda ręcznie pisząc
i tylko sprawdza się czy zachowanie tych kodów
jest podobne
także to nie zawsze to nie w każdym przypadku
generalnie
chodziło mi o
jak gdyby przekonanie Państwa
że i to zobaczycie
chociaż
chyba nie będę miała czasu żeby Wam
pokazać taki przykład
automatycznie wygenerowanego kodu
że
tam jest wiele rzeczy nadmiarowych
niepotrzebnych
i jeżeli pisze to
no człowiek
w miarę myślący
to po prostu zrobi to
no zrobi to sprytniej
i szybciej i krócej
ale
no w chwili obecnej
w wielu zastosowaniach
nawet właśnie tych przemysłowych
ten już jest już już
bo jak gdyby
poprawiają się coraz bardziej
z roku na rok
coraz bardziej
no dopracowane
jak i również prawda
no wiemy że są coraz szybsze procesory
więc czas wykonania
tego kodu też jest coraz krótszy
także to jest
no jak gdyby rzecz która
zawsze miała miejsce
ileś lat temu
w tej chwili w większości zastosowań
to już jest ta efektywność tego kodu
jest wystarczająca także to słowo
mała tutaj może być
no nie zawsze prawdziwe
dobra
czy coś jeszcze może Państwo macie
jakieś
wątpliwości
no właśnie
więc podsumowując te formalne
specyfikacje
stosujemy nie w każdym systemie
tylko w systemach które wymagają
dużej niezawodności
dużego bezpieczeństwa
na przykład w systemach safety, critical
systemy sterowania
pewnym problemem
który tutaj trzeba przejść to o czym Państwu
mówiłam z tą firmą francuską
jest to że nie jest to łatwe
żeby się tego nauczyć
trochę czasu to wymaga
żeby przejść na inny sposób
myślenia, myślenie za pomocą
właśnie takich
matematycznych
pojęć jak funkcje
relacje, zbiory
no i to o czym już mówiłam
że pewnych rzeczy nie da się
formalnie wyspecyfikować
na przykład interfejsu użytkownika
że formalnie specyfikujemy
tą część systemu
która jest odpowiedzialna za jego
no jak gdyby
sterowanie, działanie
tą logikę systemu w ten sposób
specyfikujemy
formalnie
natomiast pozostałe elementy systemu
nie ma potrzeby
i pewnych rzeczy się po prostu nie da
no właśnie
i zostało nam 9 minut
i następny temat
który ja tutaj widzę
który wymaga troszkę więcej czasu
więc
ja bym dzisiaj zajęcia
na tych formalnych specyfikacjach
skończyła
ale oczywiście jestem do Państwa
dyspozycji jeżeli ktoś ma jakieś
pytania uwagi
to
zapraszam
ja zatrzymam
proszę o nagrywanie już
---------------------------------------------I mamy udostępniony, mam nadzieję, że widzicie Państwo mój ekran.
Na poprzednich zajęciach mówiłam Państwu o tym, czym zajmuje się inżynieria oprogramowania, jakie są jej cele, jakie są jej zadania.
I pokazałam Państwu kilka takich modelów procesu produkcji oprogramowania, zaczynając od takiego historycznie pierwszego, wodospadowego, który można stosować tylko wtedy, kiedy jesteśmy w stanie dokładnie określić wymagania i wtedy, kiedy ten proces produkcji nie trwa zbyt długo.
Bo tak jak pamiętacie Państwo, jeśli trwa zbyt długo, to się może okazać, że zbudujemy świetny system, tylko nie...
Przydatny już klientowi albo nie do końca taki, jak i by klient sobie tego życzył.
Mówiłam Państwu również o innych podejściach, na przykład o takim modelu ewolucyjnym, kiedy na szybko coś dorabiamy do tego systemu i jakby w ten sposób określamy, co ten system ma robić metodą takich kolejnych prób.
Mówiłam również Państwu o formalnych specyfikacjach, tak na razie ogólnie tylko.
A więc...
W takim przypadku, kiedy mamy systemy, na przykład systemy safety critical, kiedy te błędy w specyfikacjach mogą powodować duże problemy, to wtedy warto te systemy formalnie wyspecyfikować.
Mówiłam o tym, że nie wszystko da się formalnie wyspecyfikować, zwykle się formalnie specyfikuje tylko tą część systemu, która jest odpowiedzialna za jego bezpieczeństwo.
Czyli pokażę Państwu, nie wiem, czy raczej na następnych zajęciach, przykład, jak takie formalne specyfikacje wymagają.
Teraz chcę Państwu powiedzieć trochę o takim metodzie przyrostowej realizacji oprogramowania.
To jest metoda, która faktycznie jest wykorzystywana wtedy, kiedy mamy do produkcji duży złożony...
Złożony system.
I jak to wygląda?
Otóż zaczynamy od określania wymagań, czyli tak jak to zazwyczaj bywa.
Z tym, że tutaj, jeśli chodzi o to określanie wymagań, to tutaj chodzi o to, aby złapać całość systemu, mieć taką wizję tego całego systemu.
Na tej podstawie.
Przygotowujemy ogólny projekt tego systemu, taki projekt architektoniczny.
Tutaj te grupy wymagań, które tu zostały wyspecyfikowane, ich realizacja przydzielana jest poszczególnym modułom tego systemu.
Mamy ten projekt ogólny, mamy pewną wizję ogólną tego, co taki system powinien robić.
I teraz, proszę Państwa, z tych takich tutaj funkcji ogólnych, które tutaj mamy, to jest taki system, który jest skupiony na tym, że...
I teraz, proszę Państwa, z tych takich tutaj funkcji ogólnych, które tutaj mamy, to jest taki system, który jest skupiony na tym, że...
I teraz, proszę Państwa, z tych takich tutaj funkcji ogólnych, które tutaj mamy, to jest taki system, który jest skupiony na tym, że...
... grantów komercyjnych iны, dopiero wtedy, że jedną z tych echtnych lekcji nie jesteśmy NPC-现在势記오 오� contraction, clear.
もし 어�'t quem 단계 그� revelations experience 그렇죠 설정одно on a
To właśnie najważniejsze, w jaki podstawie możemy swoim swoim serwisowi wygłaszać tak całą takich Mach Igenie.
... z tylnymi funkcjami.
może jeden z modułów, które tutaj zostały określone, kodujemy to, testujemy to
i dostarczamy tę pierwszą iterację tego systemu, dostarczamy klientowi,
klient na niej pracuje, my w tym czasie bierzemy kolejną funkcję do realizacji.
Tylko, że tutaj jeszcze proszę Państwa tak, no u mnie ta pętla jest pętlą nieskończoną,
co oczywiście tak nie może się odbywać.
Otóż pierwsza sprawa jest taka, tutaj napisałam Państwu, że to są iteracje kolejne
i że ileś ich będzie, oto ile tych iteracji będzie, to my musimy sobie tutaj już podjąć decyzję,
czy ten system będzie realizowany na przykład w pięciu iteracjach, czy w trzydziestu iteracjach,
bo od tego zależy jak duża będzie ta część systemu,
no ta jedna funkcja, którą tutaj realizujemy.
I oczywiście różne podejścia są w firmach stosowane i takich dużych iteracji,
których czas realizacji może sięgnąć nawet tam powiedzmy dwa, trzy miesiące,
jak i takich małych iteracji, gdzie ta część realizowana, może jej realizacja zajmować znacznie mniej czasu.
Teraz proszę Państwa tutaj mam taki bloczek, wybór funkcji do realizacji.
Zapomniałam Państwa zapytać, czy mnie słychać?
Słychać.
Słychać, ok, dobra. Jakby się coś działo, to rozumiem, że będziecie Państwo tutaj jakoś protestować.
Dobra i teraz proszę Państwa, no jakie kryteria możemy stosować tutaj przy wyborze tej funkcji do realizacji?
Otóż pierwsze takie kryterium, które tutaj się narzuca, to jest priorytet tej funkcji dla klienta.
Czyli im bardziej ona jest potrzebna klientowi, tak, to jak gdyby ma większy priorytet.
I zwykle taką pierwszą iterację, to jest właśnie, wybiera się taką funkcję, która jest bardzo potrzebna klientowi,
tak, żeby on już mógł z niej korzystać, a my będziemy w tym czasie, jak on już z niej korzysta,
to będziemy pracować nad kolejnymi funkcjami do realizacji.
To jest jedna z możliwości.
Może macie Państwo pomysły, jaka inna?
Inna by mogła być. Jakie inne kryterium tutaj wyboru tej funkcji mogłoby być?
Może być, proszę Państwa, no wiemy, że jeżeli realizujemy jakiś fragment systemu, tak,
no tutaj jednak te poszczególne fragmenty systemu są od siebie jakoś zależne
i często jeden korzysta z tego, co ten drugi zrobi, więc można tutaj zastosować takie kryterium
przydatności tej funkcji dla danych.
Dalszych iteracji.
To jest jak gdyby druga taka możliwość.
No i wreszcie można też postąpić w inny sposób, mianowicie zastanowić się,
jaka będzie pracochłonność realizacji tej funkcji.
No i w zależności od sytuacji wybierać funkcję na przykład taką, której realizacja będzie łatwa i szybka.
Na przykład wtedy, jeśli to już jest któraś z kolei iteracja i widzimy, że zespół, który realizuje to,
programowanie już jest trochę zmęczone tym projektem, więc żeby, prawda, coś mogli zrobić szybko,
żeby byli zadowoleni z tego, że tak szybko im się udało coś zrobić, no to możemy właśnie zastosować
takie kryterium, że jak gdyby szybkość, łatwość realizacji tej funkcji.
Także tutaj te kryteria wyboru mogą być różne.
My, proszę Państwa, tak jak Państwu tutaj mówiłam, że po zrobieniu takiego projektu ogólnego,
no tutaj zapada decyzja.
Ile tych iteracji będzie i tutaj już te ogólne wymagania, które tutaj mamy,
to są przydzielane początkowo do poszczególnych iteracji,
ale to w trakcie realizacji tego systemu też się zmienić może.
No i teraz, proszę Państwa, tutaj jeszcze jest też taka sprawa,
że w tym czasie, jak tutaj wybierzemy tą funkcję do realizacji, to ona w cudzysłowie jest zamrażana,
czyli już jak ją tutaj wyspecyfikujemy, to w niej się już nic nie,
nie będzie zmieniać, ją po prostu realizujemy, implementujemy, dostarczamy klientowi.
Ale w tym czasie te pozostałe funkcje, które tutaj ogólnie zostały określone,
mogą ulegać zmianom.
Możemy niektóre z nich wycofywać, możemy ewentualnie jakieś nowe dodawać.
No i właśnie przez to, że te poszczególne iteracje są dostarczane klientowi,
prawda, on na nich pracuje.
No i w tym czasie, jeżeli on ma zainteresowany jakiś tam feedback,
jakieś informacje, czy mu się to podoba, czy nie,
to tutaj ten model procesu produkcji, no nie ma tego niebezpieczeństwa,
że zrobimy system, który będzie, no nie trafiał w oczekiwania klienta, prawda,
bo tutaj te kontakty są stosunkowo częste.
I tutaj również jest możliwość, jak gdyby, podążania za pewnymi zmianami.
No te zmiany mogą być oczywiście w tych częściach, które,
które są zrealizowane, ale jesteśmy otwarci na zmiany właśnie w tych,
w tych częściach systemu.
Czy może coś mają Państwo do tego jakieś uwagi, pytania?
No to zastanówmy się teraz, jakie są wady i zalety takiego właśnie sposobu realizacji projektów.
No to zastanówmy się teraz, jakie są wady i zalety takiego właśnie sposobu realizacji projektów.
No to zastanówmy się teraz, jakie są wady i zalety takiego właśnie sposobu realizacji projektów.
Jak chodzi tutaj o zalety, no to niewątpliwie zaletą jest to,
No to zastanówmy się teraz, jakie są wady i zalety takiego właśnie sposobu realizacji projektów.
No to zastanówmy się teraz, jakie są wady i zalety takiego właśnie sposobu realizacji projektów.
No to zastanówmy się teraz, jakie są wady i zalety takiego właśnie sposobu realizacji projektów.
No to zastanówmy się teraz, jakie są wady i zalety takiego właśnie sposobu realizacji projektów.
ale jednak ten kontakt z klientem jest.
Więc nie grozi nam tutaj realizacja systemu zupełnie nietrafiającego
Więc nie grozi nam tutaj realizacja systemu zupełnie nietrafiającego
więc nie grozi nam tutaj realizacja systemu zupełnie nietrafiającego
w oczekiwania klienta.
Istotna zaleta to jest to, tak jak Państwu mówiłam, że tutaj zwykle jeśli chodzi o pierwszą funkcję do realizacji, to zwykle wybiera się taką funkcję, która jest najbardziej potrzebna klientowi i on już z niej korzysta, już na niej pracuje.
Czyli kolejna zaleta takiego sposobu realizacji to jest to, że klient ma możliwość wykorzystania tego systemu stosunkowo szybko.
Nie w pełni funkcjonalnego, nie dostarczającego wszystkich możliwości, ale jednak już może stosunkowo szybko zacząć z niego korzystać.
Jakie wady tutaj możemy mieć?
No, taka najbardziej istotna sprawa to jest to, że my jednak realizujemy ten system po kawałku.
Więc zdajemy sobie sprawę z tego, że nawet mając ten projekt ogólny, realizujemy jedną z funkcji.
Przepraszam, poszłam nie w tą stronę.
Przepraszam, poszłam nie w tą stronę.
I to jest oczywiście pewien dodatkowy kod, który musi umożliwić pracę aktualnej wersji, a potem jak dostarczymy, jak zrealizujemy tą część, no to po prostu zostanie wyrzucony.
Czyli mamy pewną część kodu, który przygotowujemy i który potem zostanie po prostu wyrzucony.
Bo właśnie musimy te...
Zapewniać, że te nieistniejące moduły czy części systemu, tak, że one jednak nie będą wpływały na...
Że system będzie w stanie działać.
To jest dodatkowy wysiłek, a z tym związany dodatkowy koszt.
Czy coś może Państwu jeszcze tutaj przyszło do głowy, jeśli chodzi o taki sposób realizacji projektów właśnie takich przyrostowych?
No jeszcze strata czasu z kontaktu z klientem.
Tak, no tutaj ja też zwracałam uwagę na to, że, prawda, te zmiany są możliwe, ale te zmiany mogą dotyczyć tych części, które jeszcze nie były realizowane, prawda, a te, które już żeśmy zrobili, no to one niejako są już zamrażane i tutaj się już w nich nic nie powinno dziać, czy nie powinniśmy, nie powinniśmy nad nimi nic zrobić.
No jednak jest to metoda, która...
Która jest powszechnie stosowana przez firmy, no w przypadku realizacji dużych, złożonych systemów.
Teraz, proszę Państwa, chcę powiedzieć troszkę o takim podejściu, które się nazywa reuse, które się nazywa reuse, czyli jak gdyby ponowne użycie.
To się inaczej nazywa offshore programming.
Czyli jak gdyby takie...
Takie programowanie, no, z gotowych elementów, które sobie stoją na półce, tak, i czekają, aż je włożymy do naszego oprogramowania.
To jest, tutaj takie części nazywa się COC, skrót pochodzi od słów commercial, off the shelf, tak, czyli takie gotowe komponenty, które, no właśnie, jak gdyby czekają na półce po to, żeby je użyć.
Tak.
Tak.
Tak.
Tak.
Tak.
Tak.
Tak.
Tak.
Tak.
Tak.
Tak.
Tak.
Tak.
Tak.
Tak.
Tak.
Tak.
Tak.
Tak.
Tak.
Tak.
Tak.
Tak.
Tak.
Tak.
Tak.
Tak.
Tak.
Tak.
Tak.
Tak.
Tak.
Tak.
Tak.
Tak.
Tak.
Tak.
Tak.
Proszę Państwa, metoda, ja za chwilę będę mówić o tym, jak się ją stosuje, ale to jest metoda, która pozwala nam bardzo szybko i stosunkowo tanio zbudować oprogramowanie, więc na pewno powinniśmy rozważyć stosowanie takiego podejścia do realizacji projektu, czy może tego projektu nie da się zbudować z gotowych komponentów z tych właśnie COC-ów.
Tutaj jeszcze chciałam zwrócić uwagę na to, że ten komponent, czy taki właśnie element, taka cegiełka, którą użyjemy do budowy naszego systemu, ona może mieć bardzo różną wielkość.
Tutaj mówi się o ziarnie, określa się to jako ziarno, że to ziarno może być albo bardzo małe i to takie małe ziarno to są na przykład biblioteki, które stosujemy już w najprostszych programikach na przykład po to, żeby tam coś wyprowadzić na wyjście programu, czy do jakichś obliczeń matematycznych.
A więc mogą być to po prostu funkcje biblioteczne.
Czyli tutaj to ziarno, ten element, który używamy jest bardzo mały.
Ale mogą być to, proszę Państwa, wręcz pełne aplikacje, które będziemy w jakiś sposób tylko parametryzować po to, żeby dostosować je do naszych potrzeb.
Także tutaj ten element, który będziemy chcieli stosować może być albo bardzo mały, albo może być tutaj całym, całą aplikacją.
Popatrzmy jak wygląda taki proces produkcji.
Właśnie w przypadku, kiedy chcemy te gotowe komponenty stosować.
Zaczynamy oczywiście od specyfikacji wymagań, czyli tutaj gromadzimy funkcje, w jaki sposób to robimy, to o tym dzisiaj będę mówić, gromadzimy funkcje, które to oprogramowanie ma realizować.
Teraz następnym etapem to jest analiza komponentów.
I szukanie komponentów, które by spełniały te funkcje, które tutaj żeśmy wyspecyfikowali, czy znaleźli.
No i teraz, proszę Państwa, sytuacja jest taka, że nigdy się nie da wszystkich tych funkcji pokryć tymi gotowymi komponentami, tylko pewna część jest spełniona, pewna część jest niespełniona.
Czyli na przykład powiedzmy, że tutaj żeśmy sobie...
Kilka funkcji, F1, F2, F3, F4, F5 znaleźli i teraz szukaliśmy tutaj gotowych komponentów i na przykład tutaj żeśmy znaleźli, tutaj żeśmy znaleźli, tego nie ma, tego też nie ma, a tutaj też żeśmy znaleźli.
Więc nie wszystkie z tych funkcji zostały pokryte.
No i co teraz?
No i teraz, proszę Państwa, tutaj kontaktując się z naszym klientem, musimy pewną modyfikację tych wymagań przeprowadzić.
Czyli tutaj te funkcje, których żeśmy nie znaleźli, gotowych komponentów, które by je realizowały, musimy się zastanowić, to wspólnie z klientem, na ile one są istotne dla tego klienta.
No i na przykład, jeżeli ta funkcja trzecia tutaj, tak, nie znaleźliśmy komponenta, ale po rozmowach z klientem on nam powie, że no, fajnie jakby to było, no ale jak tego nie będzie, no to trudno.
No to możemy tą funkcję po prostu, to wymaganie możemy wykreślić.
Natomiast tutaj mamy to wymaganie pierwsze, funkcję pierwszą, którą nie znaleźliśmy, ale tu klient nam powie, no nie, ale to jest dla mnie niesłychanie istotne.
Z tego nie mogę zrezygnować.
No więc właśnie takie funkcje, dla których nie znaleźliśmy gotowych komponentów, no to trzeba na przykład napisać kod, który będzie je realizował.
Teraz już jak wiemy, prawda, jak żeśmy w pewien sposób zmodyfikowali wymagania, no to teraz trzeba,
zaprojektować ten system, zaprojektować tutaj połączenia pomiędzy tymi komponentami,
dlatego, że proszę Państwa, no ten komponent, no to wyobraźmy sobie, że to jest taki bloczek, tak, który coś potrzebuje na wejściu dostać, tak, realizuje pewną funkcję
i te realizowane funkcje jedna czy kilku tutaj na wyjściu udostępnia.
No i teraz może być sytuacja taka, że to są interfejsy wejściowe, to są interfejsy wyjściowe tego komponentu, że one są do siebie dostosowane,
czyli na przykład, że tutaj ten będzie jak gdyby pasował do, tu był jakaś funkcja pierwsza, tak, a tu jest na przykład druga, że one będą pasowały, tak,
i kolejna rzecz jak gdyby będzie realizowana przez ten, i to jest sytuacja, no taka optymalna, ale no nie zawsze,
że tak bywa. Te komponenty mogą pochodzić od różnych producentów, mogą być zupełnie różne wymagania co do tego, co ma się pojawić na wejściu, co ma się pojawić na wyjściu.
A więc typowa sytuacja jest taka, że trzeba napisać pewien kod, który będzie jak gdyby opakowywał ten komponent,
dlatego, że no na przykład te jego interfejsy były niepasujące do tego, co myśmy mieli,
czyli on jak gdyby opakuje zarówno wejście do tego komponentu, jak i wyjście z tego komponentu tak, żeby to pasowało do kolejnego elementu, kolejnego fragmentu systemu.
No więc i kolejny etap, no to jest to po prostu realizacja tego systemu, integracja połączenia tych części,
integracja tych części, integracja tych części,
komponentów. No i tutaj proszę Państwa problem z tym znowu jest taki,
że często wydaje nam się, że tak, no mamy te gotowe komponenty,
więc połączenie ich no to nie powinno być problemem, powinno to nam pójść
szybko, łatwo i przyjemnie i tanie w dodatku. No i w większości przypadków
tak jest, ale nie zawsze. Często mamy problemy duże właśnie z integracją
tych komponentów, dlatego nie tylko jest problem z tymi interfejsami,
o których wspomniałam, ale problemy mogą być również innego rodzaju.
Często taki komponent czy producent pisząc taki komponent zakłada,
że wszystkie zasoby systemu są dla niego dostępne. No i teraz jeśli mamy
kilka takich komponentów, które to samo założenie ich twórcy,
zrobili, no to może się okazać, że trudno będzie je ze sobą jakoś tam
połączyć i trudno będzie je zmusić do współpracy. Także często są problemy
na tym etapie integracji tego systemu i często jest trudno tutaj pewne problemy
rozwiązać, dlatego że w większości wypadków my jak nie mamy dostępu do tego
kodu, my tylko wiemy co ten komponent robi i co ma nam dać na wyjściu.
No i tutaj, żeby właśnie jak gdyby nie było tego problemu, że nie mamy tego dostępu
do kodu, no to niektóre firmy tworzą takie komponenty na swoje własne potrzeby,
czyli jeżeli to jest firma, która produkuje oprogramowanie określonego rodzaju,
na przykład dla telekomunikacji czy dla banków, no to pewne funkcje w tych systemach
są standardowe, zwykle się je realizuje i wtedy mogą one, mogą oni
taki komponent po prostu przygotować na swoje własne potrzeby.
No i znowu zastanówmy się, jakie są wady i zalety takiej właśnie metody
budowy systemów z gotowych komponentów.
Zalety. To jest proszę Państwa wysoka niezawodność.
My korzystamy z gotowych komponentów, które często były już wcześniej,
stosowane w jakichś innych systemach. Często te komponenty mają takie jak gdyby
metryczki, takie świadectwa, że były użyte przez tego producenta,
przez tego producenta, no i że ci producenci byli z nich zadowoleni.
Czyli mają one dobrą niezawodność, więc jeżeli składamy takie dobre elementy,
z dobrych części jak budujemy coś, to mamy większą szansę na to,
że to coś będzie dobrze działało.
No, mamy tutaj pewne standardy, które, prawda, te komponenty muszą,
do których zostały przygotowane, napisane, no i my musimy się do tych standardów
dostosować, także to też jest jakaś zaleta.
Największa zaleta tego chyba to jest to, że taki system z gotowych komponentów
jest proszę Państwa znacznie tańszy niż gdybyśmy mieli każdą z tych części
pisać sami, jak to się mówi.
To znaczy, że to jest taki system pisać od początku i że oczywiście taki system,
ja wspomniałam o tym, że mogą się pojawić te problemy z integracją tych części,
ale mimo wszystko, mimo tych ewentualnych problemów, taki system powstanie
znacznie szybciej niż znowu gdybyśmy mieli to oprogramowanie pisać
od początku do końca sami.
Ze względu właśnie na te zalety, niezawodność, szybkość,
wszystkie koszty, to tak jak Państwu mówiłam, tą metodę zawsze należy rozważyć,
jak przystępujemy do produkcji oprogramowania.
Może nie zawsze całość systemu, ale na pewno trzeba się zastanowić na tym,
jaki procent w naszym systemie powinny stanowić te gotowe komponenty,
te ponownie użyte fragmenty oprogramowania, czy wręcz całe aplikacje.
Teraz, proszę Państwa, jakie tutaj mamy wady, jakie mamy tutaj problemy?
Tak, słucham?
Wady to narzucenie standardów, to w sumie to zaleta i wada.
Dokładnie, to jest na pewno to.
Teraz tak, ja Państwu mówiłam, że na przykład niektóre firmy sobie tworzą takie komponenty,
więc muszą tutaj jakiś dodatkowy koszt ponieść, dlatego że takie komponenty,
proszę Państwa, nie są takie, że nie są takie, że nie są takie, że nie są takie, że nie są takie, że nie są takie, że nie są takie, że nie są takie, że nie są takie, że nie są takie, że nie są takie, że nie są takie.
Muszą być w miarę uniwersalne, żeby można było je użyć w różnych aplikacjach,
więc tutaj ta uniwersalność tego rozwiązania musi być i różne możliwości ono musi uwzględniać.
Teraz ja mówiłam Państwu, że jeżeli nie są to komponenty, które my sami żeśmy tutaj sobie przygotowali,
tylko kupujemy je.
No to problem może być taki, że nie mamy dostępu do kodu tego czegoś, tylko wiemy, co mu podać na wejściu i co on nam tutaj da na wejściu.
No ale teraz może być problem taki, że kupiliśmy taki komponent, super, na razie działa, wszystko jest pięknie i wszystko super działa,
ale teraz, proszę Państwa, może się okazać, że producent tego komponentu,
na przykład zginie z rynku z jakichś tam przyczyn.
Przestało mu się opłacać, nie wiem, produkować albo po prostu zajął się czymś innym.
I teraz pojawia się na przykład nowa wersja systemu operacyjnego z jakimiś istotnymi zmianami,
a ten komponent korzystał z pewnych funkcji systemowych niskiego poziomu
i teraz się może okazać, że on już do tej nowej wersji systemu nie pasuje.
A tutaj nie mamy tej nowszej wersji.
I stąd tutaj widać, że ta metoda to jest małe koszty, czyli na początku to ten koszt produkcji i koszty pielęgnowania systemu są małe,
ale w miarę upływu czasu te koszty rosną, jeżeli tutaj sobie ustawimy czas, a tutaj będą koszty,
to te koszty rosną, dlatego że właśnie takie komponenty,
które przestały działać albo są teraz już jak gdyby w danym środowisku już nie mogą być użyte,
będziemy musieli w trakcie pielęgnowania tego systemu po prostu zastępować kodem, który trzeba będzie pisać.
Stąd w miarę upływu lat ten początek jest ok, a po iluś latach te koszty dramatycznie rosną.
I tutaj może dochodzić też do takich sytuacji.
Że powiedzmy taki system, jeżeli na przykład 10 lat ma być użytkowany, to te koszty pielęgnowania tego systemu na przykład w tym kolejnym dziesiątym roku mogą przekraczać jego koszty produkcji.
Także te wysokie koszty pielęgnowania tego systemu stanowią istotny tutaj problem.
Istotny problem.
Tego typu systemy na ogół nie są to systemy, które działają 20 czy 30 lat, tylko zwykle krócej.
Kolejny problem, który tutaj mamy, to jest, mówiłam Państwu, że nie wszystkie wymagania będziemy realizować.
Że my oczywiście dyskutujemy z klientem, ale z pewnych wymagań będziemy się wycofywać.
Takich, które są mniej ważne dla klienta.
Ze względu na to, że nie udało nam się znaleźć komponentów, które by je miały realizować.
Także to jest też pewien problem związany z tym podejściem do produkcji oprogramowania.
Ale tak czy inaczej, te zalety są na tyle istotne, że jeszcze raz powtarzam, na pewno powinniśmy rozważyć.
Może nie cały system, może tego jego część.
Ale przynajmniej zastanowić się, jaki procent.
W tym naszym systemie nowo produkowanym powinny stanowić te elementy ponownie używane.
Może coś Państwu przyszło do głowy, może macie jakieś swoje komentarze, uwagi?
No i też...
Jest się uzależnionym od innego producenta.
Tak, tak, tak, jak najbardziej.
Tutaj mamy tą zależność od dostawcy komponentu.
No i tutaj z tym problemy mogą powstać w trakcie upływu czasu.
To jest zazwyczaj bezpieczniejsze, ale bywają takie problemy, że jeżeli dostawca popełni błąd.
To trudniej jest nam go naprawić.
Tutaj w ogóle jest tak, że jeżeli jest błąd jak gdyby wewnątrz tego.
No to my nie mamy szansy w zasadzie go naprawić, bo w większości wypadków nie mamy dostępu do tego kodu.
I tu proszę Państwa powstają jeszcze też takie, no jak gdyby kolejne problemy.
To jest takie, że w sumie cały wolumen takiego systemu.
Z gotowych komponentów budowanego jest.
Czyli na przykład jeśli chodzi o zajętość pamięci, długość kodu.
To on jest większy niż gdybyśmy to pisali sami.
Dlatego, że tak jak Państwu mówiłam te komponenty.
One są przez tak projektowane i tak pisane.
Żeby były uniwersalne, żeby miały dużo różnych możliwości.
I nie ze wszystkich możliwości korzystamy.
Czyli na przykład tutaj mamy jakiś komponent, który coś potrzebuje na wyjściu.
I teraz jakieś ma dwie funkcje tutaj udostępnia na wyjściu.
No i teraz proszę Państwa wyobraźmy sobie, że my używamy tylko tej jednej funkcji.
I tutaj się podłączamy z drugim komponentem, który będzie z tej właśnie funkcji korzystał.
A ta sobie wisi.
No więc wydawałoby się, że no co za problem, że ta sobie wisi, że jest niewykorzystana.
No czasem jest problem.
Był taki problem.
Gdy Francja miała swoje rakiety Ariane, które wypuszcza w kosmos.
I mieli właśnie taką serię komponentów przygotowaną dla tego oprogramowania tej rakiety.
No i tam przy przejściu do kolejnej rakiety, jak gdyby użyto komponentu z poprzednich.
Ale nie wykorzystano wszystkich funkcji, które ten komponent spełniał.
Tylko no coś tam, prawda.
Zostawiono.
No i się okazało, że ta rakieta spadła.
Bo właśnie jednak tutaj no ta część, która nie została tutaj jakoś w systemie użyta.
No namieszała tyle w systemie, że w sumie to wszystko.
Rakieta spadła.
Po prostu nie wyleciała tak na tą wysokość, na którą tam była przewidywana.
Także tutaj no należy się spodziewać różnych problemów.
Szczególnie w tej fazie, prawda.
Uruchomienia integracji tego systemu, uruchamiania tego systemu.
No to tutaj różne dziwne rzeczy się dzieją.
Często jest trudno określić jak długo to uruchamianie będzie trwało.
Więc tego typu mamy problemy.
Ale jeszcze raz podkreślam.
Te koszty, w sumie dobra jakość generalnie takich elementów i ich użycie powoduje, że zawsze warto się zastanowić.
Ile tych gotowych komponentów możemy użyć.
Ja przypominam Państwu, że te osoby, które jak gdyby ze mną prowadzą jakieś rozmowy w trakcie wykładu,
to bardzo proszę o meldowanie się potem na czacie, żeby mogły dostać plusa za aktywność na zajęciach.
Miałem jeszcze pytanko.
Tak, tak.
Czy to nie jest tak, że w tym momencie to już tak naprawdę...
Zawsze się trochę używa?
Bo to zależy na którym poziomie odetniemy, czy to jest reużywalny komponent, czy to jest coś, co musimy użyć.
Tak jak nawet na przykład baza danych tak naprawdę konkretna jest teoretycznie komponentem.
Ale z drugiej strony nie piszemy własnej bazy danych raczej do każdego nowego projektu.
Dokładnie, prawda.
Tylko zwykle korzystamy z jakichś, czy korzystamy z jakichś frameworków, które możemy sparametryzować
i wtedy jakoś bardziej dostosowywać.
Jakoś bardziej dostosować do swoich potrzeb.
W tej chwili chyba...
Znaczy ja tutaj mówiłam Państwu, że te gotowe komponenty to często jest takie małe ziarno,
jak wywołania funkcji bibliotecznych, które po prostu mamy w językach programowania i tak.
I jak gdyby nawet niektóre z nich nie do końca widzimy, że z takich funkcji korzystamy,
tylko mamy jakąś operację wejścia, czy wyjścia i za tym się kryje jakaś funkcja, która to realizuje.
Więc w praktyce...
Tak.
Taka sytuacja, że nie ma żadnego takiego gotowego elementu, no to chyba się praktycznie nie zdarza,
bo jeśli tutaj włożymy również w takie komponenty te funkcje biblioteczne,
no to nawet jeżeli piszemy jakieś oprogramowanie na jakiś sterownik, czy na coś,
no to też z pewnych funkcji bibliotecznych, tego języka asemblerowego jednak korzystamy.
Także w jakimś stopniu na pewno zawsze coś jest z tego gotowego.
I też jeżeli sami chcielibyśmy to napisać, jeżeli istnieje jakaś stara, sprawdzona biblioteka,
mamy duże ryzyko błędów.
To niedawno był taki błąd, że jakaś firma zrobiła własne szyfrowanie z znanym algorytmem,
zamiast użyć biblioteki napisali sami, popełnili błąd i nie działało.
No tak bywa.
Proszę Państwa, zawsze jest jak gdyby warto się rozejrzeć za gotowymi, istniejącymi rozwiązaniami,
no bo nasze...
Często może będą jak gdyby lepiej dostosowane do tej sytuacji,
ale no ich realizacja będzie wymagała czasu, kosztów.
No i też możemy się w tym pomylić, prawda?
Możemy mieć świetny pomysł, tylko nie do końca dobrze go zrealizować.
A tutaj mamy już tam ilość tamtych użytkowników, prawda?
Pracowało nad tym.
Być może, że już te błędy, jakie tam twórcy tego komponentu popełnili,
no to tam zostały już wykryte.
Także zawsze w jakimś stopniu korzystamy z tych gotowych komponentów.
Czasem nawet nie do końca sami jesteśmy tego świadomi, że to coś tam gotowego mamy.
Coś może jeszcze macie Państwo, jeszcze jakieś komentarze?
Bardzo proszę.
No to proszę Państwa przechodzę do kolejnego modelu.
To jest proszę Państwa taki model, który nazywa się to modelem spiralnym.
Został on zaproponowany dosyć dawno temu przez Barrego Bohema.
To nazwisko Bohem jeszcze się pojawi co najmniej na jednym wykładzie,
a może na więcej.
To jest profesor ze Stanów Zjednoczonych, który bardzo dużo dobrego zdziałał,
jeśli chodzi o inżynierię oprogramowania.
I tutaj on zaproponował taki model spiralny realizacji projektów,
ale jak zobaczycie Państwo, to jest na tyle ogólny ten model,
że niekoniecznie możemy go stosować do produkcji oprogramowania,
że możemy go stosować również do jakichś naszych innych projektów,
które mamy zrealizować, czy dzieł, które mamy zrealizować.
Mianowicie Barrego Bohem stwierdził, że jak mamy coś zrealizować,
to będziemy to coś realizować w takich, jak tutaj Państwo widzicie,
takich kolejnych spiralkach.
Ileś takich spiralek doprowadzi nas tutaj do celu, do tego gotowego produktu,
czy tego czegoś, co mamy zrobić.
I teraz tę spiralkę, jedno takie, jak to nazwać,
takie kółeczko tej spiralki podzielił na takie cztery sektory.
Powiedział tak.
Pierwszy sektor, ten tutaj, to jest planowanie.
Drugi sektor, tak jak tutaj Państwo widzicie, to jest analiza ryzyka.
Kolejny sektor, to jest konstrukcja.
I czwarty sektor, to jest atestowanie.
Teraz, co tutaj się dzieje w tym planowaniu?
Mianowicie, jeśli chodzi o to planowanie, to tak.
Tutaj sobie stawiamy, jaki jest cel takiej jednej spirali.
Co będzie naszym celem, co będzie tym celem, do którego dążymy.
Musimy się zastanowić, przy jakich ograniczeniach ten cel mamy zrealizować.
I proszę Państwa, szukamy różnych alternatywnych celów.
Szukamy różnych alternatywnych rozwiązań.
Więc, jeżeli na przykład naszym celem jest produkcja systemu takiego,
z którego by na przykład studenci i wykładowcy mogli korzystać,
no na przykład takie UBI chcemy zbudować.
No to teraz to jest nasz cel.
Taki system dla studentów i wykładowców, który pozwala nam na organizację,
zajęć w szkole. To będzie cel.
Teraz druga rzecz, to jest cel tego całego naszego projektu.
Teraz, przy jakich ograniczeniach?
A więc na przykład, w jakim okresie czasowym chcemy to zrobić?
Czy to jest na przykład kwestia jednego roku?
Czy to jest kwestia trzech lat?
Jakie są ograniczenia finansowe?
Ile możemy na to wydać?
No i teraz mamy cel, mamy pewne ograniczenia
i zastanawiamy się, jakie są tutaj możliwe rozwiązania.
No to z tego, co tutaj Państwu już mówiłam na poprzednim wykładzie
i na dzisiejszym wykładzie, no to jaki byśmy tutaj mogli,
jakie sposoby realizacji takiego UBI nowego zaproponować?
Słucham, jakie Państwo macie pomysły?
No, moglibyśmy na przykład budować, jak to się mówi, from scratch,
czyli my wszystko robimy sami, tak?
Teraz przed chwilą mówiłam Państwu o tej metodzie reuse, tak?
Czyli na przykład próbujemy to składać z tych gotowych kodców, tak?
Reuse, tak?
A może na przykład jeszcze byśmy mogli popatrzeć,
czy nie ma jakichś gotowych aplikacji, które byśmy mogli w ogóle,
całe systemy, które byśmy mogli kupić i tutaj tylko sparametryzować.
To jest kolejne, tak?
A może, no i teraz pytanie, tak?
A może by się dało to, nie wiem, formalnie te wymagania wyspecyfikować, tak?
I wygenerować kod.
Czyli mamy jakieś możliwe rozwiązanie tego problemu, tak?
Szukamy tych rozwiązań.
Teraz druga,
druga, tutaj wytrę teraz to, co nasmarowałam.
Druga, drugi sektor tej spirali nazywa się analizą ryzyka.
I tutaj, proszę Państwa, przyglądamy się tym proponowanym rozwiązaniom
i zastanawiamy się, jakie ryzyko wiąże się z przyjęciem właśnie tego rozwiązania.
Być może czasem sobie tutaj pomagamy jakimiś dodatkowymi elementami,
czy dodatkowymi rzeczami, które wymagają stworzenia na przykład jakiegoś prototypu.
Czyli powiedzmy, ja tutaj zaproponowałam, tak?
Że piszemy sami, tak?
Ale na przykład była tutaj ograniczenie czasu, w jakim chcemy ten system dostać, tak?
Powiedzmy rok czasu.
No to się nie zmieścimy, tak?
Za mało pieniędzy mamy na to, żeby to sami napisać.
No to na przykład może przyglądamy się, czy są jakieś takie kocy,
które byśmy mogli użyć w tym systemie w jakimś znaczącym stopniu.
No i tutaj widzimy, że też jakieś tam są, ale nie do końca to jest.
A czy metoda formalna by się tu nadała?
No nie za bardzo.
Na pewno nie do całości systemu, więc tutaj też nie.
I proszę Państwa,
może być taka sytuacja tutaj,
że żadna z tych metod, które tutaj żeśmy proponowali,
no jak gdyby przy tej analizie ryzyka nam się nie spełnia.
Ale może nam wtedy przyjdzie do głowy coś nowego.
Czyli na przykład tutaj widzimy, że powiedzmy my mamy za mało pieniędzy,
ale jakbyśmy poszli powiedzmy i kilka uniwersytetów, kilka uczelni się razem złożyły,
no to może taki system dla kilku uczelni mógłby powstać z tych ograniczonych funduszy każdej z uczelni.
Natomiast jeżeli któreś z tych rozwiązań tutaj wyda się, proponowanych rozwiązań,
wyda się nam sensowne po tej analizie ryzyka,
często ta analiza ryzyka wiąże się po prostu ze zdobywaniem informacji,
czyli poszukiwaniem w literaturze,
poszukiwaniem podobnych rozwiązań.
No i jeżeli nam się to uda, no to ta sekcja trzecia to jest właśnie wybór tej alternatywy,
która jak gdyby najlepiej się tutaj przy tej analizie sprawdziła
lub jeśli nam się to nie udało, no to może nam przyjdzie pomysł na kolejne inne rozwiązanie.
Tak jak wspomniałam Państwu w tym przykładzie,
na przykład spróbujmy się dogadać z innymi uczelniami
i może wspólnie zamówimy taki system.
I teraz...
Czwarty sektor to jest planowanie następnej spirali,
czyli po pierwsze podjęcie decyzji, czy to będzie kontynuowane, czy nie,
zabezpieczenie sobie pewnych środków finansowych na realizację tego,
a więc ta część taka związana z planowaniem.
Jeśli decyzja jest, że dalej działamy,
no to przygotowanie do tej kolejnej.
Kolejnej spirali.
Teraz wrócę tutaj jeszcze do tego obrazku tej spirali.
Tutaj proszę Państwa, więc tak jak widzicie Państwo,
to jest model bardzo ogólny.
No możemy go stosować do produkcji oprogramowania,
ale możemy go stosować tutaj do również jakichś innych projektów,
które mamy zrealizować.
Przy produkcji oprogramowania,
tutaj te sektory, te poszczególne spirali byłyby związane na przykład ze specyfikacją wymagań,
z przygotowaniem projektu, implementacją, testowaniem i tak dalej.
To jest model, tak jak Państwo widzieliście, bardzo ogólny
i można w tym modelu, i tak się faktycznie robi,
włącza się inne modele.
Czyli na przykład jeżeli mamy tutaj teraz, powiedzmy stosujemy ten model spiralny
do produkcji oprogramowania,
to teraz jeżeli mamy taką spiralę,
która dotyczy przygotowania specyfikacji wymagań,
to możemy zbudować prototyp,
na którym byśmy się tutaj pobawili
i zobaczyli czy rzeczywiście wszystkie funkcje są przez nas przewidywane,
lub może byśmy na przykład spróbowali dla pewnej części systemu
zbudować formalne specyfikacje,
więc i prototyp, i formalne specyfikacje,
a może dla jakiejś części systemu byśmy po prostu mogli tutaj stosować
to podejście kaskadowe, wodospadowe.
Także to jest podejście, zarys jak to można realizować,
bardzo, bardzo ogólny
i w zależności od tego jaki jest cel danej spiralki,
to możemy, prawda,
różne tutaj włączać w tym modelu różne inne modele,
które Państwu tutaj pokazałam.
Nie wiem czy mają Państwo może jakieś swoje własne spostrzeżenia
do tej części.
Proszę Państwa, zastanówmy się teraz nad,
jak gdyby spróbujmy się postawić w takiej roli prowadzącego projekt,
takiego kierownika projektu,
no i zastanówmy się, które z tych modeli,
które tutaj Państwu pokazałam,
a więc model wodospadowy, ewolucyjny,
formalne specyfikacje,
który z tych modeli chcielibyśmy użyć,
czy byłby dla nas dogodny jako dla kierownika projektu,
a który może mniej dogodny.
Tutaj jeśli chodzi o kierowanie takim projektem,
no to dobrze byłoby wiedzieć co się w tym projekcie dzieje,
czyli z punktu widzenia kierownika projektu,
chcielibyśmy mieć jak największą możliwość
obserwowania tego postępu wykonywanych prac.
No i teraz modele o takiej dobrej obserwowalności.
To które z tych modeli, które Państwu na poprzednim wykładzie
dzisiaj pokazałam, które mają taką dobrą obserwowalność?
Iteracyjne?
No w iteracyjnej.
No w iteracyjnej.
No w iteracyjnym troszkę trudniej,
trochę widać co się dzieje, prawda, bo mamy te,
ale pewne rzeczy są trudne do przewidzenia,
bo tak jak Państwu mówiłam, że decydujemy się
ile tych iteracji będzie.
Zwykle się to trochę zmienia w trakcie realizacji projektu,
więc nie jest źle, ale nie jest najlepiej.
A w jakim modelu najlepiej widać wszystko co się dzieje?
W jakim modelu każda faza,
modelu każdy krok tego procesu produkcji
kończy się czymś co fizycznie istnieje.
W modelu wodospadowym?
Jasne, w modelu wodospadowym, prawda.
Pokazywałam Państwu, że tam każda faza coś produkuje.
Mamy dokument specyfikacji, mamy projekt,
mamy zbiór testów, mamy kod i tak dalej.
Więc model wodospadowy to jest taki
bardzo lubiany przez kierowników projektu.
Łatwo jest zarządzać, łatwo jest harmonogram przygotować
dla takiego modelu.
Teraz, proszę Państwa, to może być dla Państwa troszkę niespodzianka,
bo mówiłam Państwu na poprzednim wykładzie
o formalnych transformacjach
i tutaj te formalne transformacje to mamy też pewne fizycznie istniejące
byty w cudzysłowie, prawda, czyli mamy specyfikację formalną,
mamy pewne raporty sprawdzające spójność,
niesprzeczność takiej specyfikacji formalnej.
Być może mamy kod, który został wygenerowany na jej podstawie,
czyli też mamy tutaj takie dokumenty czy po prostu artefakty,
które fizycznie istnieją.
Które widać, więc też jest dosyć dobry.
Dobry jest również możliwość obserwowania tego procesu produkcji
w tym modelu spiralnym, o którym przed chwileczką Państwu mówiłam.
Dlatego, że mówiłam Państwu o tych czterech segmentach spirali.
Ten pierwszy segment to jest jak gdyby przygotowanie tego planu,
a więc mamy też dokument, który mówi co jest celem tej spiralki,
jakie są ograniczenia,
jakie są metody realizacji.
Potem ta druga, drugi sektor, gdzie mamy analizę ryzyka.
No to musimy dla poszczególnych tych proponowanych w segmencie pierwszym rozwiązań
tak oszacować to ryzyko,
stwierdzić czy to rzeczywiście łatwo będzie stosować tą metodę czy trudno.
Czyli też powstają dokumenty w każdym segmencie tej spirali,
a więc też stosunkowo łatwo jest należeć.
Stosunkowo łatwo jest nadzorować taki projekt,
który według tej organizacji jest realizowany.
Teraz z drugiej strony.
Modele o słabej obserwowalności.
Jak Państwo myślicie, co tutaj będzie?
A jak Państwo oceniacie tę budowę z tych komponentów?
Będzie łatwo obserwować?
Czy nam jeszcze trzeba do końca tego procesu produkcji?
Czy trudno?
Za każdym razem będzie trochę inaczej.
No za każdym razem będzie trochę inaczej.
I tak jak Państwu mówiłam,
tam różne rzeczy mogą się dziać.
Mogą być interakcje pomiędzy tymi komponentami,
na które nie jesteśmy przygotowani.
Więc też trudno jest prowadzić takie projekty.
Natomiast najgorsza rzecz,
najgorzej jest,
to o tym mówiłam Państwu na poprzednich zajęciach,
ten model ewolucyjny, prawda?
Kiedy tak na szybko dodajemy coś, dodajemy coś, prawda?
I to nie jest zresztą model,
który pozwala na przygotowanie systemu,
który byłby używany przez wiele lat.
Tylko tak jak Państwu mówiłam,
zwykle w ten sposób po prostu odkrywa się wymagania systemu.
Powstaje taki prototyp operacyjny,
na którym działa klient,
a my być może będziemy wtedy już zajęci
jakimś innym sposobem produkcji tego systemu,
na przykład wodospadowy.
Proszę Państwa, teraz tak.
Ja tutaj chciałam zasygnalizować pewne rzeczy
związane z egzaminem,
który będzie w lutym,
dwa terminy.
Jeden termin we wrześniu.
No i teraz egzamin się będzie odbywał w INSPE,
że przynajmniej tak było do tej pory,
w postaci pytań zarówno otwartych,
jak i pytań związanych z możliwością wyboru.
Być może przy niektórych pytaniach czy zadaniach
trzeba będzie, nie wiem, włączyć plik.
Ja tutaj Państwu pokazuję,
jakieś przykładowe pytania otwarte,
które mogłyby się pojawić,
jeśli chodzi o tą część wykładu,
które pokazywałam Państwu na poprzednim wykładzie,
na poprzednim spotkaniu i na dzisiejszym spotkaniu.
Po prostu jako taki przykład,
jako również taki materiał,
który możecie Państwo przelecieć
przez tą listę pytań,
no i zastanowić się,
czy jesteście w stanie na nie odpowiedzieć.
Czy jesteście w stanie na nie odpowiedzieć,
gdyby trzeba było tą odpowiedź napisać po prostu w formie tekstu,
albo czy będziecie w stanie na nie odpowiedzieć,
gdyby były tam jakieś możliwości wyboru i wtedy.
No to na przykład,
wady i zalety modelu wodospadowego,
ktoś z Państwa pamięta?
Łatwa kontrola, bo widać postępy.
Dobra, łatwa kontrola.
Dobra, to jako zaleta, tak?
A wada?
Jakaś przykładowa?
Długi czas realizacji.
Tak, tak.
Długi czas, brak kontaktu z klientem może być tak.
Błędy na początku,
później wymagają dużo pracy i czasu,
żeby je naprawić, bo...
Bardzo dobrze, bardzo dobrze.
Błędy w tych pierwszych fazach, prawda,
wymagają niesłychanie dużo,
nas kosztują, żeby je poprawić.
No więc na przykład,
kiedy można stosować model wodospadowy,
tak jak Państwo widzicie tutaj pytanie trzecie?
Jesteśmy w stanie zdefiniować wszystkie wymagania.
Super, dobra.
A prototypowanie, kiedy używamy?
Kiedy nie jesteśmy w stanie.
Na przykład w modelu ewolucyjnym.
Tak, kiedy nie jesteśmy w stanie.
Co więcej, kiedy chcemy coś szybko zademonstrować, prawda?
Mówiłam Państwu, że interfejs użytkownika graficzny.
Zwykle modelujemy właśnie,
pokazujemy na prototypie.
Kiedy coś jest łatwiej pokazać,
niż, prawda, opisać, jak to miałoby działać.
Formalne specyfikacje.
Dla jakiego typu oprogramowania stosujemy?
No, w przypadku systemów,
w których kwestia niezawodności, bezpieczeństwa
jest niesłychanie istotna.
Pamiętacie Państwo takie określenie używałam?
Safety critical systems.
Czyli takie właśnie systemy,
gdzie błąd może powodować bardzo duże szkody,
czy wręcz zagrożenie życia ludzi,
czy środowiska.
A więc na przykład, prawda,
nadzór nad ruchem pociągów jakimś,
czy sterowanie pociągiem,
czy kontrola lotów,
czy elektrownia jądrowa,
fabryka, linia produkcyjna w fabryce chemicznej jakiejś.
A teraz takie dwa słowa.
Tutaj pokazywałam Państwu
walidacja i weryfikacja.
Na czym polega różnica
pomiędzy walidacją i weryfikacją?
Ktoś pamięta może?
Waliduje klient?
Super, waliduje klient.
A weryfikuje firma, która produkuje kod?
Tak. Ważne jest, co w weryfikacji,
ważne jest, że musimy mieć specyfikację, prawda?
Czyli musimy mieć pewien dokument,
który określa, co to oprogramowanie miało robić.
Bez tego nie jesteśmy w stanie zrobić weryfikacji.
I właśnie zwykle ta weryfikacja jest robiona
w firmie, która produkuje.
Walidacja wymaga obecności klienta lub kogoś,
kto tego klienta będzie reprezentował.
Dzisiaj mówiłam Państwu o tym modelu iteracyjnym,
który jest używany przy produkcji
takich dużych, złożonych systemów,
których produkcja może trwać kilka lat.
Pamiętacie Państwo, jakie kryteria wyboru
możemy stosować?
Wyboru funkcji do realizacji.
Czyli mamy teraz taką iterację zrobić
z produkcją pewnej nowej funkcji,
dodać ją do tego systemu.
Mamy tych funkcji tam na początku ileś, prawda?
Przygotowanych i teraz którą wybierzemy?
Jakie kryteria?
Łatwe do wykonania.
Dobra, co jeszcze?
Potrzebne w następnych iteracjach.
Super i priorytet dla...
Najbardziej potrzebne?
Tak, priorytet dla klienta.
Takie trzy...
Złożoność?
Tak.
Tak, tak.
Też ryzyko techniczne.
No tak, tak, słusznie.
Też na to zwracamy uwagę.
Dobra, to proszę Państwa,
w ten sposób, żeśmy troszkę powtórzyli
te rzeczy, które mówiłam dzisiaj
i na poprzednim wykładzie.
I teraz, proszę Państwa,
taki moment, troszkę inne informacje,
czy troszkę inne rzeczy.
Mianowicie tak zwane czynniki nietechniczne
w inżynierii oprogramowania.
Ja mówiłam Państwu na poprzednich zajęciach,
że inżynieria oprogramowania zajmuje się
produkcją oprogramowania przez zespoły, prawda?
Przez grupy ludzi.
No i w związku z tym, że pracuje nad oprogramowaniem,
pracuje pewien zespół, pewna grupa,
no to musimy się liczyć tutaj również,
nie tylko z problemami technicznymi,
no ale po prostu z problemami,
które wynikają z kontaktów takich międzyludzkich tej grupy.
I tutaj chcę zasygnalizować kilka takich problemów.
Czyli właśnie tutaj, jeżeli kierujemy projektem,
no to musimy sobie zdawać sprawę z tego,
że kierujemy pewną grupą ludzi,
którzy mogą mieć,
każdy z nich ma pewien swój charakter,
pewne cechy indywidualne,
pewne indywidualne możliwości.
Również w zespole ważne są interakcje,
kontakty pomiędzy poszczególnymi członkami tego zespołu.
No i teraz, jeżeli kierownik sobie zdaje sprawę tutaj,
czy trochę wie, jakie są te interakcje,
kto z kim się dogaduje,
a kto z kim się nie dogaduje, tak?
Kto co potrafi, a kto czego nie lubi,
czy z czym sobie nie radzi,
to jest w stanie, no lepiej,
jak gdyby przydzielać te zadania do wykonywania
poszczególnym członkom tego zespołu
i stawiać im pewne realne cele
i jak gdyby ma większe szanse na to,
że te cele zostaną dobrze zrealizowane.
To jest jak gdyby jeden aspekt.
Czyli to jest aspekt, no tego zespołu,
który projektuje oprogramowanie,
buduje to oprogramowanie.
Ale, proszę Państwa, te systemy są też użytkowane przez ludzi.
I tutaj my musimy, no projektując system,
zdawać sobie sprawę również z możliwości,
z ograniczeń użytkowników,
którzy będą z tego systemu korzystać, tak?
I pod tym kątem, prawda,
czy ten interfejs użytkownika projektować tak,
żeby on był ergonomiczny na przykład dla tego użytkownika,
żeby był dla niego intuicyjny, łatwy.
Więc to jest też ważne, żeby jak gdyby wiedzieć,
że mamy do czynienia z użytkownikiem
i jak gdyby jego możliwości, jego ograniczenia.
No i teraz, jeżeli jak gdyby te czynniki społeczne,
te nietechniczne,
zdajemy sobie sprawę z tego,
no to troszkę łatwiej nam jest,
jak gdyby dobry system wyprodukować
i zmieścić się w czasie i w hormonogramie.
Proszę Państwa, teraz zastanówmy się nad
proporcjami czasu, tak?
Czyli, no pewnie większość z Państwa pracuje,
albo prawie wszyscy.
I teraz, tak, zastanówmy się,
jak ten czas w pracy możemy podzielić.
Pierwsza sekcja to jest praca,
czyli faktycznie, ile czasu zajmuje Wam,
nie wiem, no realizacja tych zadań,
które zostały Wam przydzielone.
Druga grupa to są czynności nieprodukcyjne,
czyli na przykład, nie wiem, wychodzicie na papierosa,
czy pijecie kawę patrząc się w okno,
czy idziecie do talerza.
Czynności nieprodukcyjne.
I trzecia grupa to są interakcje,
czyli na przykład pijecie kawę, ale nie sami,
tylko z kolegami, z koleżankami,
czy z kolegą, z koleżanką, tak?
I w czasie tego picia kawy, tak, rozmawiacie.
Rozmawiacie na bardzo różne tematy,
na razie nie wchodzimy w to, czego te rozmowy dotyczą,
ale są jakieś interakcje.
Interakcje pomiędzy, pomiędzy, pomiędzy Wami.
No i teraz chciałabym, żebyście Państwo spróbowali,
zakładając, że mamy sto procent, tak,
to te sto procent jakoś podzielić, tak?
Powiedzmy, że to jest jeden, to jest dwa, to jest trzy.
No i spróbujmy to podzielić.
Jeden, dwa, trzy.
W sumie ma wychodzić sto procent.
Słucham jakiejś propozycji.
Sześćdziesiąt, trzydzieści, dziesięć.
Sześćdziesiąt, trzydzieści, dziesięć.
Dobra, to jest jedna z propozycji.
Ktoś może ma inny pomysł?
Ktoś może ma inny pomysł?
Jest bardzo duży udział tej pracy własnej w tym, co Pan powiedział,
a bardzo małe te interakcje.
Ja bym może jednak zamienił w sumie interakcje i czynności nieprodukcyjne
na odwrót, czyli dziesięć, trzydzieści, nie trzydzieści.
Trzydzieści, nie trzydzieści, dziesięć.
Pan proponuje dziesięć.
Nie, żeby to było sześćdziesiąt, dziesięć, trzydzieści albo nawet pięćdziesiąt, dziesięć, czterdzieści.
Sekundeczkę, wytrę to, co tutaj zaczęłam i jeszcze raz Pan mi dyktuje teraz, co mam tu wpisać.
Pięćdziesiąt, dziesięć, czterdzieści.
Pięćdziesiąt, dziesięć i czterdzieści.
Dobra, tu mamy zupełnie inny udział.
Ja bym zaproponował pięćdziesiąt, dwadzieścia, trzydzieści.
Tu też pięćdziesiąt Pan proponuje, tak?
Dwadzieścia i trzydzieści.
Tak, i trzydzieści.
Dobra, no więc widzicie Państwo, że tu jak gdyby Wasze spojrzenie na to jest, no, różne, prawda?
Za, u tutaj jednego z Panów był minimalny udział tych interakcji,
tutaj u drugiego Pana był minimalny udział tych interakcji, tutaj u drugiego Pana był minimalny udział tych interakcji,
tutaj u drugiego Pana był minimalny udział tych interakcji,
tutaj u drugiego Pana był minimalny udział tych interakcji,
tutaj u drugiego Pana był minimalny udział tych interakcji,
tutaj u drugiego Pana był minimalny udział tych interakcji,
tutaj u drugiego Pana był minimalny udział tych interakcji,
tutaj u drugiego Pana był minimalny udział tych interakcji,
tutaj u drugiego Pana był minimalny udział tych interakcje,
tutaj u drugiego Pana był minimalny udział tych interakcji,
tutaj u drugiego Pana był minimalny udział tych interakcji,
tutaj u drugiego Pana był minimalny udział tych interakcji,
tutaj u drugiego Pana był minimalny udział tych interakcje,
tutaj u drugiego Pana był minimalny udział tych interakcji,
Obserwowano, pracownicy nawet nie wiedzieli o tym, w dużych firmach, w IBM-ie było, obserwowano, powiedzmy, okiem kamer, co się dzieje i zostało to podzielone z tych filmów, z tych obserwacji, wyszło, że praca własna to jest tylko 30%, czynności nieprodukcyjne 20%, aż 50% interakcji.
No więc możecie Państwo sobie wyobrazić, że jeżeli szefom w IBM-ie takie wyniki pokazano, to się troszkę zdenerwowali i stwierdzili, no zaraz, zaraz, to za co my płacimy tym pracownikom, jak widać, że oni tutaj jedynie 1 trzecią tego czasu pracy wykorzystują faktycznie na wykonywanie tego, co powinni robić,
a tutaj przychodzą do pracy po to, żeby sobie pogadać o pogodzie, polityce.
I kawę wypić i tyle.
No więc proszę Państwa, wtedy powiedziano, zrobiono kolejny eksperyment, powiedziano pracownikom, słuchajcie, obserwuję Was tutaj oko wielkiego brata, no i w zależności od tego, jak będziecie pracować, ile będziecie pracować faktycznie sami, no to na przykład kwestia premii może być od tego uzależniona, może być ta premia większa czy mniejsza.
No i teraz proszę Państwa, co się okazało, spodziewano się, że taki projekt, który właśnie, no byłby, chodziło o to, żeby jak gdyby zmniejszyć ten czas na interakcje, zwiększyć ten czas na pracę własną.
I wydawało się, że no, że taki projekt powinien być po prostu skończony szybciej znacznie.
Rzeczywiście te, no.
No w tej grupie projektowej te czasy interakcji zostały obniżone, tak, czas pracy własnej znacznie wzrósł, tutaj te proporcje zostały być może zamienione.
Natomiast zdumiewające było to, że w sumie ten projekt wcale nie został ukończony szybciej niż podobnej złożoności projekty, które były realizowane bez tego sztucznego nadzoru, prawda.
Bez tego sztucznego wymuszania.
No więc to wtedy poproszono socjologów, żeby jeszcze raz przejrzeli te taśmy, prawda, te nagrania.
No i żeby wytłumaczyli, dlaczego tak się stało, dlaczego ten projekt, który był realizowany bez takiego nadzoru i tutaj był duży udział tych interakcji.
Dlaczego on był realizowany w podobnym czasie, co projekt, w którym te interakcje znacznie spadły, a znacznie wzrosła ta praca własna.
No i tutaj już to wymagało dokładnej analizy, dokładniejszej analizy tego, na czym te interakcje polegały.
No i oczywiście szybko stwierdzono, że te interakcje to faktycznie jest czasem trochę o pogodzie czy o polityce, ale że duża część tych interakcji to są rozmowy, wymiany informacji dotyczące realizacji projektu.
Że często jest tak, że przy tej kawie ktoś mówi, no mam taki i taki problem.
Nie wiem, jak go rozwiązać albo nie wiem, szukam efektywnego algorytmu, który by robił to i to.
I ktoś mu podrzuci, a ja to kiedyś robiłem i tutaj jest algorytm tam Kowalskiego czy Jankowskiego, który to dobrze robi.
Popatrz sobie, tak to się robi.
Czy jest jakaś biblioteka, w której możesz użyć takiej to a takiej funkcji, która to za ciebie wszystko zrobi.
Więc stwierdzono, ten czas przeznaczony na interakcje jest potrzebny.
No i przestano go w taki sposób sztuczny ograniczać.
Tutaj ja troszkę muszę powiedzieć, że byłam zdziwiona, jak Państwo podawaliście mi przed chwilą te dane i tutaj niewielki udział był tego czasu przeznaczonego na interakcje przez Was podawanego.
To samo pytanie zadaję regularnie od wielu lat studentom.
No i w czasach, kiedy zajęcia się odbywały.
Wykłady się odbywały stacjonarnie w sali.
To muszę powiedzieć, że tutaj niektórzy właśnie podawali te interakcje powyżej 50%, niektórzy podawali 60%.
Więc widocznie w niektórych firmach aż to rośnie do takiego.
To może już jest trochę za dużo, ale powiedzmy to utrzymanie tych interakcji na wysokim na tym poziomie do 50% jest.
Dziękuję.
Jest w sumie korzystne z punktu widzenia realizacji projektu, bo jeszcze raz powtarzam, owszem jest ta wymiana informacji o tym, że dzisiaj mamy śliczną pogodę, słońce świeci, może warto by pójść na spacer, ale również jest to wymiana informacji i pomoc wzajemna członkom tego zespołu, tej grupy.
W ramach interakcji też się wliczają wszystkie spotkania?
Tak, spotkania również tej grupy, która realizuje projekt, więc to ten czas też te spotkania znacznie podnoszą tutaj procentowo.
No dobra, to teraz proszę Państwa jeszcze jak gdyby kontynuuję.
Kontynuując dzisiaj, bo to jedynie dzisiaj mówię o tych czynnikach nietechnicznych, to jeszcze kwestia różnych osobowości, które mamy, więc tak, mamy czasem takie osoby, które są jak to się mówi zorientowane na zadania, czyli dla nich motywacją jest sama praca.
Oni żyją tym projektem, tą pracą, którą realizują.
To jest bardzo, bardzo przydatny typ pracownika, prawda?
Sama praca jest dla niego motywacją.
On lubi to, co robi, on się w tym dobrze czuje, on się w tym spełnia.
Druga grupa pracowników to będą pracownicy, jak to się mówi, zorientowani na siebie.
Tutaj dla nich motywacją jest osiągnięcie.
Zdążenie do osiągnięcia sukcesu, a praca jest tylko pewnym jego środkiem.
Czyli na przykład takie osoby, jeżeli system płacowy będzie tak ustawiony, że jeżeli oni dobrze pracują, to będą na przykład lepiej zarabiać albo będą mieli szansę na awans powiedzmy w kolejnym projekcie, to oni będą dobrze pracować.
Ale jeżeli w danej firmie, prawda, no tutaj widać, że na przykład awans.
Nie jest zależny od tego, jak się pracuje, tylko nie wiem, od czegoś innego, no to im się nie będzie, nie będzie im się opłacało, jak to się mówi, dobrze pracować.
Także system płacowy również nie bardzo jest z tym związany.
Więc jeżeli mamy dobrze ustawione pewne reguły działania pracy, również płacy, no to taki pracownik też jest pracownikiem bardzo ceny.
No i teraz, proszę Państwa, mamy trzeci typ pracownika.
Trzeci typ pracownika to jest pracownik zorientowany na interakcję, czyli to są osoby, które, prawda, przychodzą do pracy, no po to, żeby być w grupie, żeby się spotkać.
No i teraz ten, jak gdyby ten nasz typ pracownika, czy jesteśmy zorientowani na zadania, na siebie, czy na interakcję, no to psychologowie,
no to psychologowie, dając nam dowód.
No i teraz, znowu można by sobie powiedzieć tak, no to ten typ pracownika zorientowany na interakcję jest najmniej przydatny przy realizacji projektu.
No więc znowu robiono, proszę Państwa, takie eksperymenty, że pewne projekty, do pewnych projektów pracownicy byli dobierani,
poprzez, no właśnie najpierw to testowanie, tak, i że przy pewnych typach, przy pewnych projektach pracownicy uczestniczący w tym projekcie to byli tylko pracownicy z tych dwóch grup.
I znowu, proszę Państwa, wyszło, że no mimo, że to ci, prawda, lepsi pracownicy, w cudzysłowie lepsi, tak, wydawałoby się bardziej efektywni byli wybrani,
tam system motywacyjny był dobrze ustawiony, tak, że jak dobrze pracujesz, to dobrze zarabiasz.
Tak, tak, tak.
Zrealizowane szybciej niż taki projekt o podobnej skali złożoności, ale gdzie ci pracownicy byli, no, nie dobierani w taki sztuczny sposób, tylko, jak gdyby, no,
zjawiali się tam.
No, na wejściu i po prostu tak było.
Więc, więc właśnie, więc się okazało, że nie ma co, jak gdyby, w taki sztuczny sposób dobierać tych pracowników.
Te osoby, które są zorientowane na interakcje, to to są te osoby, które powodują, że, no, że jest dobra atmosfera w grupie, że jest dobra wymiana informacji, że te interakcje są, są dobre.
Natomiast, no, dobrze byłoby, że...
Żeby właśnie przywódcą takiej grupy była ta osoba, która jest zorientowana na zadania, na pracę, prawda, bo ona będzie ciągnęła cały zespół do tego, żeby tą pracę wykonać.
No właśnie, więc tu mówiłam Państwu o eksperymencie, że były, no, nieudane próby realizacji projektów, może nie tyle nieudane, co projekty realizowane przy...
Jedynie tych dwóch typach pracownika, zorientowany na pracę i zorientowany na siebie, wcale nie były realizowane szybciej niż te przy takim doborze naturalnym.
Z tego eksperymentu, to zresztą był eksperyment, był kilkakrotnie powtarzany, no, jak gdyby wyszło, że, no, po prostu powinny być w grupie realizującej projekt, powinny być wszystkie te trzy typy osobowości.
Proszę Państwa, na uniwersytecie...
Na uniwersytecie takim technicznym w Holandii, w Delft, są realizowane projekty zespołowe, jako jeden z elementów, jako jeden z przedmiotów, który tam jest realizowany i tam te projekty zespołowe są, proszę Państwa, bardzo fajnymi projektami, bo to zlecenia do tych projektów przychodzą z przemysłu.
I studenci realizują...
Realizują coś, co potem faktycznie w większości wypadków jest używane przez przemysł.
I tam przy realizacji tych, przy doborze tych grup do, właśnie do tych zespołów, są studenci, wypełniają te testy, są przez psychologów testowani, ale po to, żeby te grupy były, no, w miarę równomierny sposób, tak gdyby, no, osobowości rozdzielone.
Czyli, żeby nie było na przykład jednego zespołu, w którym będą osoby tylko zorientowane na pracę, bo w cudzysłowie oni się pozabijają przy realizacji tego projektu, tylko chodzi o to, przy tym projekcie zespołowym, żeby były różne typy właśnie tej osobowości, żeby to równomiernie tych studentów na te grupy projektowe podzielić.
No i tak jak Państwu wspomniałam, to efekty realizacji...
...projektów są naprawdę zdumiewająco dobre, że właśnie większość tych projektów realizowanych przez studentów faktycznie potem wchodzi do realizacji przemysłowej.
Teraz, proszę Państwa, chciałam poruszyć jeszcze taką sprawę, to się nazywa Ego Less Programming.
Otóż...
Proszę Państwa, jeżeli zrobimy, napiszemy, nawet napiszemy jakiś prosty program, tak, albo zrobimy, nie wiem, coś sami, to, no, mamy prawo być dumni z tego, co żeśmy zrobili i to jest, to jest oczywiście dobrze, prawda, mamy prawo i powinniśmy być dumni z własnego dzieła, natomiast musimy sobie zdawać sprawę z tego, że jak gdyby nie powinniśmy się tak bardzo z tym swoim dziełem,
identyfikować, nawet jeżeli żeśmy dużo czasu spędzili przy realizacji tego projektu, to nie możemy zakładać, że on jest idealny, najlepszy i że w ogóle, tylko musimy starać się, jak gdyby popatrzeć na to nasze dzieła z boku, jako to nasze dzieło z boku, tak, nie, jak gdyby spróbować się od tego naszego dzieła, tak, no, jak gdyby wyjść z niego.
I dlaczego? Dlatego, że w takiej sytuacji jesteśmy w stanie nawet sami zauważyć, że no coś zrobiliśmy tak, a teraz widzimy, że może można było to zrealizować lepiej, szybciej, albo krócej, tak, albo, no, jak gdyby inną metodą, w inny sposób, więc, więc chodzi o to, żeby się tak bardzo nie identyfikować,
ze swoim dziełem, tylko już jak coś zrobimy, to spróbować, jak gdyby z boku popatrzeć, czy z góry popatrzeć na to coś, co żeśmy zrobili i mieć oczy otwarte, uszy, również dopuszczające słowa krytyki i jak gdyby mieć, no, takie, w cudzysłowie, trzeźwe spojrzenie na to coś, co zrobiliśmy.
Teraz, proszę Państwa, jeśli chodzi o przywódcę grup.
No to po pierwsze mamy zawsze jakąś osobę, która jest administracyjnie, prawda, pełni funkcję, nie wiem, kierownika projektu, szefa projektu, ale wiemy również, że jeżeli mamy nawet już, nie wiem, dwie osoby, tak, coś robią, no to zwykle jest tak, że któryś z nich jest już tutaj szefem, czy jak gdyby, no, przywódcą, więc zawsze jest również taki przywódca grupy,
który jest przez grupę wyłaniany i często przy realizacji projektu ta osoba się zmienia, prawda, że i na inną osobą, takim przywódcą grupy jest ktoś na takim, w tych pierwszych etapach realizacji projektu, na przykład zbierania wymagań,
ktoś inny nagle jest jak gdyby uznany jako przywódca grupy.
Na etapie projektowania, czy jeszcze inny na etapie testowania.
Także tutaj musimy sobie zdawać sprawę z tego, że ten przywódca wyłaniany przez grupę może się zmieniać, ten wyznaczony administracyjnie, no, jest jeden, no i dobrze by było, żeby, prawda, oni ze sobą byli w stanie jakoś współpracować, a przynajmniej się dogadywać i wtedy realizacja projektu przebiega sprawnie.
Teraz,
proszę Państwa,
wspominałam o tych
interakcjach,
że one są
jednak przydatne,
prawda, bo w ten sposób pracownicy
sobie pomagają,
no, często
dają jakieś tam wskazówki,
podpowiadają
pewne rzeczy
i, no,
więc niewątpliwie taka
lojalność, dobra
integracja grupy,
to jest, plusem jest
współpraca, pomoc.
Stąd też firmy często organizują jakieś wyjazdy integracyjne, czy spotkania integracyjne właśnie po to, aby te kontakty w grupie,
te kontakty w grupie, prawda, poprawić, czy zwiększyć.
Ale, proszę Państwa,
też chodzi o to,
żeby, no, tutaj nie doszło do takiej,
no, w cudzysłowie to można nazwać, towarzystwa wzajemnej adoracji.
Prawda, że cała,
no, tak bardzo jesteśmy
zintegrowani z życiu
w grupie, że w ogóle
nie dopuszczamy
żadnej, żadnych,
no,
żadnej krytyki co do
tego, jak kto pracuje i co kto
robi, prawda, żeby, bo to może
doprowadzić do bardzo niebezpiecznych sytuacji,
na przykład
pracujemy nad jakimś
systemem, który jest systemem safety
critical, no i
nasz kolega
jest odpowiedzialny i realizuje
tą część za bezpieczeństwo
systemu, w danym momencie ma jakieś
problemy, nie wiem, życiowe
takie i widzimy, że ta praca
mu wyraźnie nie idzie, tak, ale my
zamykamy uszy, zamykamy
oczy, no, bo to jest nasz
kolega i udajemy, że nic nie widzimy.
Nie, nie może tak
być, prawda, tutaj musimy,
no, bo to może spowodować bardzo
potem duże konsekwencje.
Czyli
tu nie chodzi o to, żeby jak gdyby
kryć, że komuś coś
nie idzie, tylko może mu pomóc, tak,
czy go zastąpić, czy
zmienić tą osobę,
tak, żeby w sumie to dzieło nasze było
jednak dziełem dobrym.
No i teraz,
proszę Państwa, jeszcze tutaj taki
ostatni element
dotyczący tych czynników
no, nietechnicznych.
Mówiłam Państwu o tych
interakcjach, prawda, że one są
istotne, że powinny być efektywne.
Więc
co wpływa na efektywność
tych interakcji, no tutaj
mówiłam o tych,
jak gdyby, lojalności tej
grupy, ale również
kwestia wielkości tej grupy,
prawda, czyli jeżeli mamy grupę
na przykład n osób,
tak, no to
liczba potencjalnych
ścieżek komunikacyjnych,
jak mamy n osób, to jest
n razy n minus 1.
Ale to jest
wtedy, kiedy
te, no,
każdy z tych członków tej grupy
ma podobny, jest jak gdyby na
podobnym poziomie, ma podobną pozycję
w tej grupie, wtedy każdy z każdym
może się komunikować.
Czasem, proszę Państwa, mamy grupy,
które mają pewną
określoną strukturę, czyli na przykład
mamy tutaj jakiegoś
szefa, tak, on ma tutaj
trzech podwładnych, tak,
tak,
i ci tutaj też na przykład
mają kilka osób, które jakoś
tam z nimi współpracują i
robią. I mamy
pewną strukturę, nie taką każdy
z każdym, tylko mamy taką strukturę
na przykład drzewiastą.
No i proszę Państwa, często jest tak, że
jeżeli mamy taką strukturę grupy
tego typu, taką drzewiastą,
no to potem mamy często podobną
strukturę oprogramowania,
bo jak gdyby łatwiej jest wtedy
te zadania przydzielić
właśnie też przy takim,
przy takiej
strukturze tych członków grupy.
Także
tutaj na tą strukturę grupy
ma wpływ status,
osobowość pracowników.
Często jest tak, że mamy na przykład jakiś
właśnie mały zespół, który
tam ma powiedzmy trzy czy cztery
osoby i nagle do realizacji
pewnego projektu ten zespół jest
znacznie rozbudowywany,
zwiększany, prawda.
Czyli nowi członkowie są albo zatrudniani,
albo przychodzą nowe osoby,
więc jak gdyby one są już troszkę
niżej w tej hierarchii, więc
tworzy nam się jakaś taka struktura
drzewiasta.
Na te
interakcje w grupy ma
wpływ również środowisko
pracy, to już o czym Państwu
mówiłam, że
często, no teraz już
firmy zdają sobie sprawę z tego, że
te interakcje są
pozytywne i że
no na ogół właśnie są
też jakieś przestrzenie takie
w cudzysłowie rodzaj
przestrzeni socjalnych dostępne, czy
jakieś takie spotkanie, pokoje spotkań,
w którym zarówno się spotkania mogą
odbywać tej grupy projektowej,
jak i właśnie te interakcje,
ta wymiana informacji, wzajemna
pomoc może się odbywać.
Tutaj wiedząc o tym,
że no przy takiej
przy jak gdyby równym
statusie każdego z członków
tej grupy, ta liczba potem
potencjalnych dróg komunikacyjnych
to jest właśnie ten wzór,
no to musimy pamiętać o tym, że to
N nie powinno być zbyt duże, bo z kolei
jeżeli będzie zbyt duże,
no to będzie wtedy zbyt
jak gdyby duży narzut
tych, no czy te
ścieżki komunikacyjne mogą być
wtedy po prostu zbyt
długie i to spowoduje
znowu zwolnienie pracy nad
projektem. I to by było
proszę Państwa na tyle, jeśli chodzi
o te czynniki nietechniczne,
tylko to co dzisiaj powiedziałam,
już więcej do tego tematu wracać
nie będę, tylko dalej będziemy się
zajmować już aspektami
technicznymi. Czy może
ktoś z Państwa ma do tego jakiś
komentarz, swoje
uwagi?
Jeśli nie,
to proszę Państwa
zrobimy
przerwę. Przepraszam, że parę minut
chyba przeciągnęłam,
ale chodziło mi o
skończenie tego, także,
ale przerwa będzie
w normalnej długości.
Więc
ogłaszam przerwę
do godziny
5 minut po, czyli
do godziny 10.05.
Dziękuję.
---------------------------------------------Dziękuje za uwagę.
Mówiłam Państwu o różnych modelach procesu produkcji oprogramowania. Większość tych modeli to były takie modele, które nadają się, żeby przygotowywać pewien plan do nich i tam mieliśmy na przykład te problemy takie, że jak jest przerwa w kontaktach z klientem,
to możemy zrobić system, który nie będzie uwzględniał wszystkich możliwości i wszystkich oczekiwań tego klienta.
Więc zaczęto szukać innych troszkę metod organizacji tej produkcji. Pojawiły się takie metodyki zwinne, tak to się tłumaczy na polski.
Słowo angielskie chyba jest przyjemniejsze, bo nazywa się to techniki agile.
I teraz zacznę może od takiego syndromu loop. Skrót te literki pochodzą od late – późno, o – od over budget, o – od overtime i p – od poor quality.
Proszę Państwa, wiele projektów koniec lat 90. właśnie było realizowanych w ten sposób, że projekt był opóźniony, że projekty były przekroczone.
Tutaj od razu podam Państwu takie dane, mianowicie wychodziło, że 80% projektów przekracza budżet o 100%, prawda?
Czyli widzimy, że tutaj…
Ogromna część, no większość projektów realizowanych miała przekroczony budżet i to w znaczący sposób.
No ponieważ projekty były opóźnione, więc starano się to jakoś nadgonić, ludzie pracowali w nadgodzinach, tak?
I co, czym to skutkowało? Skutkowało to poor quality, czyli kiepską jakością tego oprogramowania.
No i ten syndrom loop, koniec lat 90. coś starano się z tym zrobić.
No i ten syndrom loop, koniec lat 90. coś starano się z tym zrobić.
No i ten syndrom loop, koniec lat 90. coś starano się z tym zrobić.
No i ten syndrom loop, koniec lat 90. coś starano się z tym zrobić.
No i ten syndrom loop, koniec lat 90. coś starano się z tym zrobić.
I w roku 2001 został opublikowany przez tutaj też takie znane nazwiska w inżynierii oprogramowania jak Kent Beck, jak Alister Cockburn, jak Martin Fowler,
I w roku 2001 został opublikowany przez tutaj też takie znane nazwiska w inżynierii oprogramowania jak Kent Beck, jak Alister Cockburn, jak Martin Fowler,
Książki związane z refaktoryzacją, również o UML-u.
Cockburn za taką książkę dotyczącą przypadków użycia
też takiego UML-owego fragmentu.
Kent Beck też wiele tutaj wniósł, jeśli chodzi o inżynierię oprogramowania.
Zaproponował karty CRC, czyli Class Relations Collaborations.
Więc zaproponował metodę XP, o której dzisiaj troszkę powiem.
I Jim Hicksmith też.
I oni ogłosili tak zwany właśnie w roku luty 2001
na takiej konferencji międzynarodowej, ogólnoświatowej,
tak zwany manifest zwinności.
Stwierdzili, że ważniejsze są jednostki i interakcje
niż procesy i narzędzia do realizacji tych procesów.
Ja tutaj chciałam Państwu, gdyby wspomnieć o tym,
mówiłam na pierwszym naszym spotkaniu o tym,
że celem inżynierii oprogramowania jest produkcja oprogramowania wysokiej jakości.
Mówiliśmy o opowieściach, dyskusja była dotycząca atrybutów oprogramowania wysokiej jakości.
Tu chciałam Państwu zwrócić uwagę, że jest norma ogólnoświatowa,
tu jest numer tej normy.
Która właśnie dotyczy jakości oprogramowania.
Normy są nudne, więc ja o tej normie mówić nie będę.
Poza tym, że takie normy istnieją, że niektóre firmy
wprowadzały właśnie proces produkcji w oparciu o te normy.
Co powodowało zresztą 30% wzrost kosztów produkcji.
Ale jak gdyby jaka jest istota?
Istota tej normy, mianowicie, że no właśnie, że trzeba dokumentować różne rzeczy.
Dokumentować, mierzyć, analizować i tak dalej.
Więc jak gdyby stosowanie się do tych norm,
no znacznie usztywniło ten proces produkcji oprogramowania.
Tak jak Państwu już mówiłam, zwiększyło koszty produkcji.
Firmy się przyznają do 30% wzrostów wtedy, kiedy są one oparte o normy.
Ale z drugiej strony,
dla niektórych klientów, prawda, to dobrze wyglądało,
jeżeli firma się mogła pochwalić, że realizuje projekty zgodnie z ogólnoświatową normą.
Teraz, proszę Państwa, te modele, o których w większości Państwu mówiłam,
no to można powiedzieć, że one są to modele dostosowanego do takiej produkcji oprogramowania
w oparciu o pewien plan, który sobie oczywiście przygotujemy.
Tutaj o przygotowywaniu planów, harmonogramu,
programowaniu i tak dalej ja mówić nie będę,
bo mają Państwo przedmiot, który się nazywa zarządzanie projektami software'owymi
i zakładam, że tam tego typu informacje są Wam pokazywane.
Ale generalnie można powiedzieć, że właśnie przy takim tworzeniu, oprogramowaniu w oparciu o pewien plan,
no to mamy taki proces inżynierii wymagań, o którym będę mówić, pewnie już dzisiaj troszkę zacznę,
którego rezultatem jest tutaj… te czynności się odbywają w pewnym cyklu,
ale rezultatem jest przygotowanie dokumentu, który opisuje te wymagania, specyfikuje te wymagania.
No i w oparciu o ten dokument przygotowujemy projekt, implementujemy go.
Jeżeli następuje zmiana w wymaganiach, tak, no to cały ten proces trzeba przejść od początku do końca i to, prawda, powoduje no właśnie duże koszty wprowadzenia,
jakichś nowych funkcji, bo trzeba zacząć od początku.
Ta idea tego zwinnego procesu produkcji, tego agile,
jak gdyby polega na tym, że mamy ten proces inżynierii wymagań,
zbierania wymagań, specyfikacji tych wymagań,
ale od razu te wymagania implementujemy.
I to jest taki, jak gdyby w takim cyklu się odbywa.
Wspomniałam o tym manifestie zwinności z roku 2001.
Wspomniałam o tym, że tam panowie napisali,
że ważniejsze są jednostki i interakcje niż procesy i narzędzia.
Że ważniejsze jest, żeby działało oprogramowanie,
niż to, żeby była opisana, żeby była dokumentacja obszerna.
Ale w oparciu o tę specyfikację wymagań,
przygotowuje się.
Kontrakty z klientem.
No więc oni znowu powiedzieli,
no tu ważniejsza jest współpraca z klientem,
niż właśnie ten kontrakt, niż jego negocjacje.
I że w tej metodzie chodzi o to,
aby nadążać za zmianami, które klient będzie chciał wprowadzić.
No i tutaj wspomniałam już tego Kenta Becka,
który napisał zresztą bardzo fajną książeczkę
pod tytułem Extreme Programming.
Jako taka właśnie pierwsza metodyka takiego agile'owego tworzenia oprogramowania.
Jak to mniej więcej wygląda?
Otóż proszę Państwa, wygląda to tak,
że wybieramy pewne historyjki przygotowane przez użytkowników
i pewne takie historyjki, jak gdyby mówimy,
one będą w danej iteracji oprogramowania będą realizowane.
Tak?
Tak?
Tak?
Tak?
Tak?
Tak?
Tak?
Tak?
Tak?
Tak?
Tak?
Tak?
Tak?
Tak?
Tak?
Tak?
Tak?
Tak?
Tak?
Tak?
Tak?
Tak?
Tak?
Tak?
Jak gdyby te pewne scenariusze dzieli się na pewne zadania
i przygotowuje, planuje się plan takiego wydania,
który by właśnie te funkcje realizował.
No następuje opisanie, napisanie tego, integracja, testowanie
i dostarczamy ten kawałeczek, prawda, to wydanie dostarczamy użytkownikowi.
Użytkownik,
na tym działa, być może nam dostarcza kolejnych takich właśnie historii,
które my wprowadzamy znowu do tej. Czyli też to jest taki model ewolucyjny,
z tym, że tutaj jeszcze będę mówić o pewnych różnicach z tym podstawowym
modelem ewolucyjnym. Co tutaj jest istotne? Otóż, proszę Państwa, mamy cały czas
klienta na miejscu, kogoś reprezentującego klienta, który właśnie będzie nam
te historyki, te zadania, te scenariusze będzie nam opisywał. Te przyrosty,
to jest taki inkrementalny sposób produkcji oprogramowania, ale te przyrosty
są bardzo krótkie. Kolejna sprawa to jest taka, że jak mamy już taki scenariusz
przygotowany.
Który mamy zaprogramować, to od razu dla niego przygotowywane są przypadki
testowe. Czyli najpierw mamy testy, a potem dopiero piszemy kod, który będzie
te funkcje realizował. Konieczne jest tutaj posiadanie narzędzia, które by
automatyzowało proces wykonywania testów. Tutaj, proszę Państwa, często tak to
wygląda, że na koniec dnia musi być ten projekt zbudowany. Pracownicy idą sobie
do domu, a przez noc wykonywane są zbiory testów. Rano przychodzą do pracy, mają
raporty z wykonania tych testów, widzą, który test przeszedł, który nie przeszedł.
Nie ma w tej metodzie produkcji, nie ma takiej dokumentacji, jak to przy tych
plan-based development, tylko tutaj dokumentacją to jest po prostu kod, który został
napisany i przypadki testowe.
Duże zespoły mogą w ten sposób pracować, czyli gdzieś tak 6-8 osób.
I co tutaj jest również ciekawego, mianowicie programuje się tutaj parami.
Popatrzmy tutaj z książki profesora Jana Somerwila właśnie to, o czym mówiłam.
To te testy, ale tutaj zwracam uwagę na refactoring. Otóż, proszę Państwa, tutaj
nie ma takiej własności kodu, jak normalnie w takich projektach, że powiedzmy
kod tego modułu to napisał Pan Jankowski, a kod tego modułu napisał Pan Kwiatkowski.
Tylko tutaj ten projekt jest wspólną własnością wszystkich członków zespołu.
I mało tego, że należy do wszystkich, to jeszcze w dodatku każdy z tych członków zespołu
powinien ten kod zmienić. Nie tylko swój, ale ten kod napisany przez innych także.
I tu cały czas dokonuje się refaktoryzacji kodu, czyli no właśnie, wyszukuje się
pewne wspólne miejsca, które, nie wiem, czy podobny kod, który już był napisany,
stara się ten kod wyciągnąć, potem wywołać w postaci funkcji, czy wywołać jakiego modułu.
Czyli cały czas tutaj jest ciągle, odbywa się refaktoryzacja tego kodu.
Po prostu chodzi o to, żeby ten kod był kodem prostym, przejrzystym.
Żeby była możliwość pielęgnowania tego kodu.
Pamiętacie Państwo, jak mówiłam o tym modelu ewolucyjnym, że szybko dodajemy kolejne możliwości
do tego oprogramowania, no to dochodzi do tak zwanego spaghetti code, czyli właśnie takiego,
wiem, może dojść do takiego momentu, kiedy nie będziemy w stanie w ogóle zapanować nad tym, co się,
co się dzieje w tym systemie, jak to zostało napisane, prawda?
Że w ogóle w jakimś momencie nie będziemy w stanie już dodać czegoś nowego.
Tu chodzi o to, żeby nie doszło do takiej sytuacji.
Czyli właśnie ciągła refaktoryzacja tego kodu musi mieć miejsce.
Teraz, proszę Państwa, przy tej metodzie XP, XP programming, programowanie odbywa się w parach.
Czyli.
Przy jednym komputerze siedzi, siedzą dwie osoby.
Jedna osoba pisze kod, a ta druga patrzy się na ekran, tak?
Może coś podpowiada, może znajduje błędy.
Więc, no wydawałoby się, że to jest trochę jak gdyby strata, prawda, siły roboczej,
bo mamy dwie osoby, które jedną rzecz robią.
Okazuje się, że nie, że, że w ten sposób, jak gdyby, no ta druga osoba podpowiada,
one się zmieniają zresztą, podpowiada jakieś dobre rozwiązania,
czy od razu znajduje w tym pisanym kodzie, od razu znajduje błędy i te błędy są poprawiane.
Wspomniałam o tej własności całego kodu już, że w ogóle mamy, musimy mieć,
mamy prawo zmienić dowolny fragment kodu, jeżeli tutaj celem takiej zmiany, prawda,
ma być uproszczenie tego kodu.
Spowodowanie, że ta struktura będzie bardziej przejrzysta, bardziej zrozumiała.
Istotne jest, i to już też o tym Państwu mówiłam, że jak gdyby jest ciągła integracja tego,
że, no, że na przykład firmy działają w ten sposób, te małe zespoły,
bo to, to nie może być zespół większy niż tam jakieś 8 osób,
że jak gdyby na koniec dnia musi być skompilowany ten system, właśnie oni idą do domu,
bo tutaj też nie pracuje się w nadgodzinach, w tej metodzie nie mamy nadgodzin.
Tylko, właśnie, nie ma pracy w nadgodzinach.
Tylko, tylko, no, w tych godzinach pracy, co, co, co mamy w nocy,
ta automatyzacja wszystkich testów się odbywa i potem poprawiamy to, co zostało wykryte
i cały czas, prawda, ten klient, reprezentant klienta jest nadgodzinny.
Na miejscu.
Tutaj jeszcze też, oczywiście, jak są dodawane nowe funkcje, nowe możliwości do tego oprogramowania,
prawda, dochodzi nowa historyjka, którą trzeba oprogramować,
to dochodzą, tak jak Państwu mówiłam, nowe testy do tego.
Za każdym razem jest wykonywany zestaw wszystkich testów, które do tej pory były przygotowane,
dlatego, że wprowadzenie nowej zmiany to, to jest,
czy dodanie nowego kodu, to nie tylko trzeba przetestować ten nowo dodany element,
ale muszą przejść wszystkie testy, które wcześniej też były wykonane.
O tym dwóch osobach przy komputerze to już Państwu mówiłam.
No i jednak jest to efektywne, bo okazuje się, że kod, który w ten sposób powstaje,
jest kodem krótszym, jest kodem bardziej efektywnym niż taki kod pisany przez pojedyncze osoby.
Jest tu wymiana wiedzy, znacznie mniejsze ryzyko popełniania błędów.
Od razu pewne błędy są, prawda, identyfikowane w trakcie pisania tego kodu.
Mówiłam Państwu, że no tutaj też robiono badania, które stwierdziły, że o dziwo te programy,
które w ten sposób powstają, są programami mniejszymi niż te programy krótszymi,
jeśli chodzi o rozmiar, niż te programy, prawda, no nie realizowane w ten sposób.
Ze względu właśnie na tą ciągłą refaktoryzację tego kodu, to ciągłe upraszczanie.
No i znowu ten raport wykazał, badając takie systemy, że te systemy są po prostu efektywne,
że jest dobra jakość tego kodu.
Mamy do tego podejścia, oprócz tego XP Programming, mamy też pewne metody zarządzania takimi projektami.
Jedna z takich bardziej znanych metod to jest metoda, która się nazywa SCRUM,
która ma takie trzy fazy.
Faza taka początkowa, w której się,
no jak gdyby określa cele tego projektu i architekturę się projektuje,
a potem mamy całą serię takich sprint, takich cykli,
gdzie każdy taki sprint powoduje zbudowanie jednej,
jak gdyby jednego przyrostu tego systemu, czyli właśnie te kolejne przyrosty systemu.
I ostatnia faza, zamknięcie tego, jak gdyby uzupełnienie do dokumentacji
i jakiś tam podręczników dla użytkownika, to jest ta faza zamknięcia.
Tutaj też, jeśli chodzi o taki zespół, to też, tak jak Państwo widzicie,
nie więcej niż jakieś 7-8 osób.
Tutaj każdy taki inkrement powinien być to taki, jak gdyby,
taka funkcja, która potencjalnie może być, jak gdyby oddana użytkownikowi,
chociaż nie zawsze, nie zawsze tak bywa, ale jak gdyby powinna być ona zakończona,
czyli zarówno wszystkie testy na niej przeprowadzone.
Są tutaj również pewne określone rzeczy, które się robi,
mianowicie prowadzi się tak zwany projekt,
czyli backlog, to jest taka lista tego, co trzeba jeszcze zrobić,
czym się trzeba zająć.
Tu mamy również pojęcie, jak gdyby, pewnych osób,
które są, jak gdyby, właścicielami tego produktu
i które tutaj mogą, jak gdyby, no dokonują przeglądu tego backlogu
i określają pewne cele, które należy wykonać.
No i właśnie takie...
Też codziennie odbywają się takie krótkie spotkania tej grupy,
gdzie przegląda się postęp tego projektu,
określa się priorytety, co ma być zrobione danego dnia.
Mamy pojęcie tak zwanego Scrum Mastera,
który jest odpowiedzialny za właściwe użycie tej metodyki i jak gdyby...
No i tak jak Państwu mówiłam,
taki sprint, czyli to jest no pewna funkcja zrealizowana,
która potencjalnie może być dostarczana już klientowi
i takie te sprinty też nie powinny być zbyt długie,
czyli mówi się, że powiedzmy góra do miesiąca,
ale może być to tydzień czy dwa tygodnie również.
No właśnie, czyli właśnie z takiego backlogu określa się, co ma być zrobione,
wybiera się pewne elementy, planuje się te elementy,
planuje się ten sprint, tak, potem dokonuje się jego przeglądu
i jak gdyby kolejne takie sprinty są realizowane.
Prowadzi się właśnie też tutaj takie, no tą listę tych rzeczy,
które mają być zrobione w całym projekcie,
w danym sprincie mają być zrealizowane
i tak jak Państwu mówiłam, chodzi o to, aby rezultatem takiego sprintu było coś,
co potencjalnie może być dostarczane.
To jest to, co jest dostarczane klientowi.
Ktoś coś mówi, ale niezbyt dobrze słyszę, więc nie wiem,
czy to po prostu komuś się coś łączył mikrofon.
Jeśli ktoś z Państwa ma jakieś swoje uwagi czy komentarze, to zapraszam.
Ja mówiłam Państwu o tej metodzie XP Programming,
tego programowania, prawda, w parach, klient cały czas dostępny na miejscu.
Natomiast, no pewne, i mówiłam Państwu, że jest dobra efektywność tego kodu,
że on jest krótki, że on jest szybko działający.
Natomiast, no mamy tutaj również pewne problemy,
no nie robi się tutaj dokumentacji.
Ten system może być idealnie dostosowany,
ale do potrzeb jednego typu klienta, bo takiego jeden typ klienta
jest dostępny na miejscu.
Jeżeli tych potencjalnych użytkowników jest kilka typów,
no to wtedy może być problem, że te funkcje przydatne innym typom użytkownikom
po prostu nie zostaną zrealizowane albo zostaną za mało realizowane.
Tutaj mamy, proszę Państwa, też problemy przy tworzeniu oprogramowania
tymi metodykami.
To, co już też mówiłam, że jest kwestia, problem z zawarciem takiego kontaktu,
problem z zawarciem takiego kontraktu,
więc nie może w ten sposób, na ogół nie są przygotowywane
jakieś bardzo duże systemy, tylko jeżeli mamy dobre relacje z klientem,
on ma do nas zaufanie, my mamy do niego zaufanie,
no to taka, jak gdyby takie niezbyt złożone oprogramowanie
może być w ten sposób przygotowywane.
Natomiast, no tutaj ta możliwość wprowadzania tych zmian,
dążania za zmianami jest bardzo taka intrygująca i przydatna
i, proszę Państwa, no i stara się, starają się to często firmy jakoś tak pomieszać,
czyli z jednej strony ta produkcja oprogramowania w oparciu o pewien plan, prawda,
z którą się wiążą pewne problemy jednak i brak tej elastyczności.
Tutaj mamy tą elastyczność, ale mamy znowu problemy,
że no nie może być to zbyt duży system, że mamy problemy z kontraktem,
no więc próbuje się te dwie rzeczy, jak gdyby jedną z drugą pomieszać,
no i różnie to wychodzi, ale generalnie ostatnie lata to jest właśnie
jak gdyby moda na te metodyki zwinne, chociaż no w ostatnich latach
widać, że te metodyki zwinne nie zawsze są możliwe do zastosowania
i nie zawsze powinny być stosowane.
Jeszcze raz może ktoś z Państwa ma jakieś swoje komentarze,
może ktoś z Państwa pracuje właśnie w ten sposób w swojej firmie.
Chyba największym problemem Agila jest to, że każdy interpretuje go według siebie
i czasami idzie to w złym kierunku.
No tak, stąd właśnie te próby takiego jak gdyby usystematyzowania,
czyli z jednej strony ma być prawda zwinnie i wygodnie,
a z drugiej strony wiemy, że z tym się wiąże wiele problemów
i próbujemy znowu tego Agila włożyć w jakieś ramy, schematy, dokumenty, prawda,
tak jak tutaj nawet w tym skrumie Państwu pokazywałam.
Jeszcze są inne metodyki, takie produkcje oprogramowania zwinne.
Druga taka znana to jest chyba Kanban, to się nazywa z tego co pamiętam,
więc jest próba, prawda, takiego gdzieś znalezienia takiego złotego środka,
co oczywiście nie zawsze jest możliwe.
Taki entuzjazm dla tych metodyk to był ten początek XXI wieku,
ale już w ostatnich czasach,
no to właśnie no jednak dostrzega się również problemy związane z tym podejściem
i stąd próba takiego połączenia tej jak gdyby tworzenia oprogramowania
w oparciu o pewne plany, dokumenty, schematy,
a z drugiej strony no próba, żeby jednak to było elastyczne.
No i nie zawsze to się udaje.
To się kończy na przykład tym, że daily, które codzienne spotkania,
które powinno być króciutkie, na przykład trwa 40 minut, 3 godziny.
Tak, tak, no i to już prawda nie o to chodzi,
bo to w tych wersjach takich początkowych mówiono się,
mówiono, że no właśnie to spotkania powinny być takie szybkie,
tak, ustalamy co dzisiaj robimy, kto co robi
i każdy się bierze ze swojej pracy.
No już jak to spotkanie trwa półtorej godziny,
czy nawet więcej, no to właśnie.
Także to firmy starają się jakieś tam swoje wzorce wypracować,
jak organizować tą produkcję w oparciu o niby takie zwinne podejście,
które no przy tej organizacji, tak jak już mówiłam,
no nie jest takim zwinnym podejściem.
Nie jest takim zwinnym podejściem do końca.
Dobra, to by było tyle.
Natomiast teraz, no właśnie i teraz proszę Państwa
chcę przejść już do kolejnego tematu.
Takim jest inżynieria wymagań.
Ale tutaj będę chciała powiedzieć o kilku sprawach,
zanim dojdę do tych wymagań faktycznie jako wymagań.
To najpierw powiem Państwu,
to już to hasło faza strategiczna się pojawiło na pierwszym wykładzie.
Pokażę Państwu takie liczbowe dane,
które pokazują niepowodzenia projektów,
czy przyczyny niepowodzeń projektów.
Pokażę Państwu również takie współczynniki,
które pokazują, określają koszty usuwania błędów
wykrytych w poszczególnych fazach realizacji projektu,
czy również takie przeciekanie błędów.
Przeciekanie błędów popełnionych w jednej fazie do kolejnych faz.
I potem przejdziemy do wymagań, ich typu, sposobów zbierania i tak dalej.
Czyli do takiej requirements engineering, inżynierii wymagań.
Zacznę od tej fazy strategicznej.
To jest proszę Państwa, to są czynności,
które są wykonywane często przez firmy,
i rezultatem tej fazy strategicznej ma być decyzja,
czy w ogóle bierzemy się za realizację pewnego przedsięwzięcia.
Czyli na przykład, jeżeli mamy jakiś przetarg na budowę,
na dostawę oprogramowania, przy takim oprogramowaniu zamawianym,
lub negocjujemy z klientem jakiś kontrakt,
no to właśnie też powinniśmy tutaj sobie wykonać tą fazę strategiczną,
żeby na przykład wiedzieć, ile chcemy w tym przetargu zarządzać,
albo żeby tutaj te negocjacje jakoś przebiegały w oparciu o pewne konkrety.
Troszkę inaczej ta faza strategiczna wygląda wtedy,
kiedy rozważamy produkcję oprogramowania,
na przykład nowej wersji oprogramowania takiego rynkowego,
czy na przykład nowej wersji jakiegoś edytora,
czy nowej wersji jakiegoś systemu do projektowania tam czegoś.
Ale istotne jest, żeby właśnie w obu tych przypadkach
wykonać tak zwane studium wykonalności,
nazywa się to feasibility study.
I o co tutaj chodzi?
Pierwsza rzecz, to musimy złapać jak gdyby taką ogólną wizję tego systemu,
czyli widzieć cele tego przedsięwzięcia,
ale z punktu widzenia klienta,
z punktu widzenia przyszłego użytkownika.
Więc taka ogólna wizja tego systemu,
w jaki sposób ją złapać, w jaki sposób ją uzyskać.
No na przykład w ten sposób, że przeprowadzać wywiady, rozmowy,
przyglądać, powiedzmy, pracy tych przyszłych użytkowników.
Dlatego, że tutaj celem jest właśnie określenie takiego zakresu,
czyli jak gdyby wizji takiego systemu,
ale również kontekstu tego przedsięwzięcia,
czyli pewnych ograniczeń, pewnych zależności.
I jak gdyby stąd powstaje takie zgrubna analiza tych wymagań,
zgrubny projekt tego systemu.
Zgrubne to znaczy, że te funkcje są bardzo ogólnie określone,
tylko czemu ma służyć ten system, co ma robić, bez szczegółów.
I właśnie tutaj zwykle rozważa się różne sposoby realizacji.
Czyli na przykład zastanawiamy się,
czy będziemy w stanie zbudować ten system, powiedzmy, z gotowych komponentów,
czy musimy wszystko pisać sami,
czy może da się zastosować jakąś gotową wręcz aplikację
i tylko ją sparametryzować.
Także tutaj szukamy różne możliwe sposoby realizacji.
Na tym etapie powinniśmy dokonać takiego wstępnego szacowania kosztów,
bo mówiłam Państwu, że tutaj na przykład wykonujemy te czynności
wtedy, kiedy chcemy przystąpić do przetargu.
I wtedy istotne jest, musimy podać pewną cenę tego oprogramowania,
więc musimy oszacować, ile nas będzie kosztowa produkcja tego systemu
w taki sposób, żeby tu jakąś sensowną kwotę podać,
no i żeby na tym nie stracić.
Te proponowane metody realizacji trzeba przeanalizować,
trzeba zastanowić się nad tym, jakie ryzyko wiąże się
z wyborem konkretnej metody realizacji.
W tej fazie robi się różnego rodzaju prezentacje tych wyników,
różne formy graficzne po to, żeby właśnie łatwiej było
pewne decyzje podjąć, żeby można było jakiś wstępny harmonogram określić,
bo przystępując do przetargu, my musimy powiedzieć, prawda,
w jakim czasie i za ile jesteśmy w stanie to zrealizować, prawda?
Natomiast może również określić pewne standardy.
Natomiast istotne jest, że my musimy być przekonani,
że się nam to opłaca i że jesteśmy w stanie to zrealizować,
że my to będziemy potrafili zrealizować.
Czyli muszą tutaj zapaść różnego rodzaju decyzje,
bardzo ważne, stąd ta nazwa decyzje strategiczne,
dlatego że niewłaściwie podjęte takie decyzje mogą,
po prostu mogą spowodować upadek tego projektu
albo brak możliwości zakończenia tego projektu czymś,
co dostarczymy, prawda, klientowi.
Jakiego typu te decyzje strategiczne mogą zapadać?
A więc właśnie, poznaliście Państwo różne modele realizacji
procesu produkcji oprogramowania, więc na przykład zdecydować się
na który z tych modeli wydaje nam się optymalny w danej sytuacji.
Teraz trzeba się tutaj również zastanowić nad technikami
stosowanymi w analizie, w projektowaniu.
Będziemy się tego uczyć troszkę później,
ale no tutaj dzisiaj mogę Państwu wspomnieć,
że są jak gdyby takie dwa podejścia do projektowania.
No zgrubnie, faktycznie tych podejść jest więcej,
ale jak gdyby takie dwie grupy technik stosowanych,
mianowicie techniki obiektowe i techniki funkcjonalne czy strukturalne.
Więc tutaj na przykład którą z tych technik,
na przykład którą z tych technik,
którą z tych technik będziemy stosować potem w fazie analizy i projektowania.
A w jakim środowisku będziemy to realizować? Bardzo istotna decyzja to jest narzędzie,
w jakim będziemy ten projekt realizować. Tymi literkami CASE określa się skrót
Computer Edit Software Engineering. To jest bardzo ogólne określenie różnego rodzaju narzędzi,
które są pomocne w procesie projektowania, produkcji oprogramowania.
Czyli są tutaj w skład tych narzędzi typu CASE, wchodzą zarówno narzędzia,
które i taki przykładowy wzwód z takiego narzędzia Państwu pokażę.
Czy dzisiaj, czy na następnym wykładzie, które służą do zbierania wymagań.
To są narzędzia, które służą do realizacji projektu. Jak będę Państwu omawiać UML-a,
no to pokażę Państwu jakieś fragmenty takiego projektu właśnie w takim narzędziu realizowanym.
Dzisiaj wspomniałam Państwu na przykład o tym, że potrzebne są na przykład wtedy,
jeżeli korzystamy z tej metodyki zwinnej.
Potrzebne nam jest narzędzie, które automatyzuje proces testowania.
Więc są takie narzędzia, które nam pozwalają ten proces testowania po prostu przeprowadzić bez naszego udziału.
Tam tylko jak gdyby uruchamiamy to.
Więc do testowania.
Także mamy całą masę takich, również środowiska programistyczne, w których prawda piszemy, wykonujemy testy.
To też są właśnie to takie narzędzia typu CASE.
Czyli mamy bardzo różnorodne narzędzia.
Na różnych etapach tworzenia projektu, które w to wchodzą.
I tutaj wybór takiego narzędzia jest bardzo też istotną sprawą.
Dlatego, że wiele z tych narzędzi typu CASE to są narzędzia, które są drogie.
To są narzędzia, trzeba zapłacić licencję za korzystanie z tego narzędzia.
I to wcale nie jest tanie.
I też zdecydować się, czy to narzędzie, nie wiem, kupujemy do naszej firmy licencję i będziemy użytkować.
Czy może korzystamy tylko z takiej licencji na ileś godzin pracy i wtedy powiedzmy nie mamy tej instalacji u siebie.
To narzędzie gdzieś działa w chmurze, a my tylko z niego korzystamy.
Także wybór tego narzędzia.
Sposób w jaki z niego korzystamy jest to bardzo też istotna decyzja, za którą muszą iść pewne środki finansowe.
Dzisiaj mówiłam Państwu o tych gotowych komponentach.
Mówiłam Państwu, że jest bardzo istotne, żebyśmy zawsze starali się użyć tych gotowych komponentów.
Ile się da, czy określić w jakim stopniu będziemy z nich korzystać.
Więc to też jest taka decyzja strategiczna, bo też od tego zależy koszt produkcji tego oprogramowania.
Od tego może zależeć czas, w jakim będziemy w stanie to oprogramowanie zrealizować.
No i teraz, proszę Państwa, czasem trzeba po prostu współpracować czy z innymi producentami,
czy zatrudnić jakichś ekspertów zewnętrznych.
Czasem się mówi, że informatyk to się musi znać na wszystkim, prawda?
No bo jak realizuje system dla księgowej, no to musi się znać na księgowości.
A jak, nie wiem, powiedzmy system dla telekomunikacji, no to na tych sprawach telekomunikacyjnych, czy na jeszcze jakichś innych.
Więc oczywiście nie znamy się na wszystkim. Musimy się troszkę w tej dziedzinie orientować, ale nie znamy się na tych wszystkich dziedzinach.
I stąd, no często jest potrzeba poproszenia.
Po prostu zatrudnienia ekspertów z danej dziedziny, w której ten system będzie działał,
po to, aby oni nam różne rzeczy opowiedzieli, pokazali, aby dopilnowali, żebyśmy jakichś głupich rzeczy w tym projekcie nie zrobili.
Proszę Państwa, mówiłam dzisiaj o tym modelu spiralnym.
I tam mówiłam Państwu, że w tej fazie planowania trzeba określić cel, co będzie celem, ale również jakie są możliwe rozwiązania.
I to jest właśnie też rzecz, na którą zwracam uwagę, że zawsze powinniśmy widzieć kilka możliwych rozwiązań.
I te kilka możliwych rozwiązań.
I te kilka możliwych rozwiązania powinniśmy przeanalizować.
Czyli właśnie określić, jakie ryzyko wiąże się z wyborem danego rozwiązania.
A więc ile to rozwiązanie będzie kosztowało, ile będzie trwało, czy my się na tym znamy, czy nie, prawda?
Więc trzeba właśnie te ryzyka wyboru poszczególnych rozwiązań bardzo dokładnie zanalizować i określić.
No i tutaj bierze się pod uwagę różnego rodzaju czynniki.
Na przykład takie, no, jakie, ile to maksymalnie może kosztować.
Jaki mamy personel, prawda?
Co ci ludzie, których mamy, co oni potrafią?
A czego nie potrafią?
Wspominałam Państwu o tych narzędziach typu CASE.
Mówiłam również, że często te licencje są bardzo drogie.
Ja nie wiem, jakie są ceny aktualne, ale parę lat temu takie narzędzie, które Państwo zresztą macie,
taki zbiór narzędzi dostępnych w szkole w ramach takiej inicjatywy akademickiej,
no to w firmie dla jednego programisty to to narzędzie, licencja miała kosztować, ileś lat temu kosztowała 3 tysiące dolarów.
Czyli trzeba sobie zdawać sprawę z tego, że te narzędzia są drogie.
No i również wziąć pod uwagę ograniczenia czasowe, prawda?
I na podstawie tych różnych tutaj czynników,
no wybrać właściwe rozwiązanie.
Wybrać rozwiązanie, które ma szansę być zrealizowane, prawda?
Spośród tych, które żeśmy proponowali.
Tutaj w tej fazie strategicznej często, proszę Państwa, przygotowujemy różnego rodzaju wykresy.
To, co Państwo widzicie, to jest wykres Ganta, który no właśnie pokazuje,
tutaj mamy, tu mamy oś czasu, tak? Mamy czas.
I pokazuje tutaj.
Jak gdyby różne elementy, które mają być zrealizowane w tym czasie.
Tutaj widzicie Państwo, że jak gdyby pewne, od pewnego momentu pewne czynności mogą być zrównoleglone.
Na przykład już jak mamy, prawda, tutaj projekt systemu,
ten system, tutaj ta analiza, taki projekt ogólny zrobiony,
to teraz już tutaj takie rzeczy jak dziedzina problemu, interfejsu użytkownika, bazy danych,
to te rzeczy mogą być wykonywane, prawda, równolegle.
Także tego różnego rodzaju właśnie takie grafy, grafy zależności poszczególnych czynności,
ustawienie to w osi czasu, określenie również zadań dla poszczególnych członków zespołu czy dostępności.
No to różnego rodzaju takie właśnie wykresy, zależności, grafy na tym etapie robimy.
Na tym etapie wstępnym, ale to jest jak gdyby również prowadzone w czasie trwania tego projektu
i wtedy no te szacunki, które robimy w miarę rozwoju projektu są coraz to dokładniejsze.
Wspomniałam Państwu o tym, że są normy jakości oprogramowania.
Tutaj się odwołuję do takiej, no to są wszystko grube bardzo takie książki,
o których właśnie mówię.
Również właśnie dotyczą jakości, również dotyczą pewnych metryk.
To są takie metryki, które jak gdyby widzi użytkownik, takie widowne na zewnątrz.
To są metryki wewnętrzne, które też wpływają na jakość tego projektu,
no po to, żeby w sumie, prawda, uzyskać jakieś oprogramowanie dobrej jakości.
O syndromie loop to już mówiłam, więc to pominę.
Natomiast tutaj popatrzmy, proszę Państwa, co prawda te dane, jak Państwo widzicie,
są bardzo stare.
Co pewien, co kilka lat, czy co kilkanaście lat są takie dane zbiorcze,
projekt nagle by proponowany, przepraszam, udostępniany.
Ostatnie takie dane, z których ja kojarzę, być może, że są również jakieś współczesniejsze,
ale takie, które ja kojarzę, to jest rok 2014.
I te dane wyglądały podobnie.
Stąd jak gdyby tutaj pokazuję Państwu pewne dane liczbowe,
które są sprzed iluś lat, ale tak jak mówiłam, potem te z roku 2014
były podobne dane liczbowe.
Proszę Państwa,
Standish Group to taka, w Stanach Zjednoczonych są nadal gromadzone dane
dotyczące różnego rodzaju projektów software'owych,
które są realizowane na terenie Stanów Zjednoczonych i na terenie Kanady.
I jedną z rzeczy, które właśnie, jedna z informacji,
które tam są dotyczące tych poszczególnych projektów gromadzone,
no to właśnie, powiedzmy, jakie są przyczyny, projekty, które się nie zakończyły sukcesem,
dlaczego się nie zakończyły sukcesem.
I tutaj proszę popatrzeć.
Spośród tych projektów, tam są tysiące projektów uwzględnione,
więc to są dane, które mają pewną wartość statystyczną.
To nie jest jeden, dwa czy trzy projekty,
tylko naprawdę spośród bardzo, bardzo wielu.
Spośród bardzo, bardzo wielu projektów.
To proszę popatrzeć.
Oceniają firmy, że 13% projekt się nie udał,
dlatego, że brak było pewnych danych wejściowych.
12%, że wymagania i specyfikacje były niekompletne, niepełne.
12%, dlatego, że w trakcie tego projektu,
12% dlatego, że w trakcie tego projektu,
12% dlatego, że w trakcie tego projektu,
w trakcie realizacji projektu,
były jakieś zmiany wymagań czy zmiany specyfikacji.
4% był ten harmonogram, który został przygotowany,
czy plan okazał się nierealny,
czyli widzimy stosunkowo niewiele.
Tylko 6%, to jest kwestia niewłaściwych ludzi,
którzy zostali zatrudnieni do tego projektu,
tylko 7% nieznajomość technologii.
tylko 7% nieznajomość technologii.
Tylko 7% nieznajomości technologii.
Proszę popatrzeć, te pierwsze 3 rzeczy dotyczą problemów z wymaganiami,
Proszę popatrzeć, te pierwsze 3 rzeczy dotyczą problemów z wymaganiami,
czy zarządzaniem wymaganiami.
A więc określeniem tego, co ten system ma robić
A więc określeniem tego, co ten system ma robić
i przy jakich ograniczeniach pracować.
i przy jakich ograniczeniach pracować.
To jak sumujemy, to to jest 25-37%,
To jak sumujemy, to to jest 25-37%,
To jak sumujemy, to to jest 25-37%,
czyli ponad 1 trzecia projektów,
czyli ponad 1 trzecia projektów,
stwarza problemy, właśnie związane z gromadzeniem, zarządzaniem, dokumentowaniem tych wymagań.
stwarza problemy, właśnie związane z gromadzeniem, zarządzaniem, dokumentowaniem tych wymagań.
stwarza problemy, właśnie związane z gromadzeniem, zarządzaniem, dokumentowaniem tych wymagań.
stwarza problemy, właśnie związane z gromadzeniem, zarządzaniem, dokumentowaniem tych wymagań.
stwarza problemy, właśnie związane z gromadzeniem, zarządzaniem, dokumentowaniem tych wymagań.
Pokazuję to Państwu po to, żeby zwrócić uwagę na to, jak właśnie istotna ta inżynieria wymagań.
żeby zwrócić uwagę na to, jak właśnie istotna jest ta inżynieria wymagań,
a więc wyodrębnianie tych wymagań, przechowywanie ich, gromadzenie, zarządzanie, dokumentowanie.
Jedna trzecia projektów upadła ze względu na jakieś problemy związane z wymaganiami.
Teraz, proszę Państwa, badane są również projekty, które się zakończyły sukcesem.
No i tutaj te projekty kończące się sukcesem, jak Państwo widzicie, w dużych firmach to jest ich niewielki udział.
Może teraz jest to troszkę lepiej, w małych firmach jest to trochę lepiej.
I znowu firmy oceniają, oczywiście ze swojego punktu widzenia, co spowodowało,
że ten projekt zakończył się sukcesem.
I mówią tak, 16% dlatego, że było zaangażowanie użytkownika w tym projekcie.
12% było jasne określenie wymagań.
Czyli znowu proszę popatrzeć, 14% z patrzenia kierownika.
Czyli to razem daje nam 28%, czyli prawie znowu jedna trzecia tych projektów zakończonych,
zakończonych sukcesem, to ten sukces był związany właśnie z tym,
no jak gdyby jasnym i precyzyjnym, bo mamy również użytkownika tutaj, określeniem wymagań.
Teraz proszę Państwa, tutaj pokazuję Państwu taką tabelkę,
która, po pierwsze zwróćmy uwagę na tą skuteczność usuwania błędów.
Skuteczność usuwania błędów.
I teraz proszę popatrzeć tak, przygotowujemy wymagania, tak?
Przygotowujemy wymagania, przeglądamy te wymagania, recenzujemy je.
No, 70% błędów, które zrobiliśmy jest, jak gdyby możemy wykryć.
Więc część tych błędów po prostu w tych wymaganiach przechodzi do dalszych etapów.
Teraz projekt.
Projekt również podlega recenzowaniu.
Tutaj skuteczność usuwania błędów, jak widzicie Państwo, już jest trochę wyższa, jest 85%,
ale no też część tych błędów przechodzi dalej, jak gdyby zostaje w tym projekcie.
Kod.
No tutaj widzimy, mamy wysoką skuteczność usuwania tych błędów, ponad 90%, 95%,
więc jak gdyby stosunkowo mało błędów przechodzi tych, jak gdyby pozostaje w kodzie.
No, jeśli chodzi o dokumentację, to tutaj już jak gdyby jest to mniej istotne,
czy niewłaściwe poprawki, które wykonujemy.
To teraz, proszę Państwa, popatrzmy na takie dane, które też pojawiły się dawno temu,
jak gdyby te liczby, korzysta się z nich do dnia dzisiejszego.
Mianowicie, jakie są koszty usuwania błędów, tu skuteczność tych błędów,
żeśmy przed chwileczką widzieli, na różnych etapach realizacji projektów.
Proszę popatrzeć, na etapie określania wymagań, tu mamy praktycznie takie fazy projektu
zgodne z modelem wodospadowym, na etapie określania wymagań, specyfikacji wymagań,
adalahexceptorium, preparatu.
Zresztą Bunsen spiera nam jeszcze do tego, które robią to wszystko.
I mam tam, nie wiem, ile osób zamarło w tutaj organizacji,
około tych 10 osób.
Jak widzisz, skupiamy tutaj nasınoscenia.
I to się pojawiło.
Więc, pod vivre, to tak jak powiedziałem do tego sam wzięto tam,
chcącfront чувacy, ale to nie jest mogące w państwa przedstawić,
żebyuThenllau, musimy typowo uwzgluzbyćから palba.
Szkoda.
projektu, też widzimy, że te koszty są też niewielkie. Ale proszę Państwa,
proszę popatrzeć, to szybko rośnie. Na etapie testowania jednostek,
czyli tutaj tych jednostek kodu, ten koszt usuwania błędów już jest wyższy.
A jeżeli te błędy wykonujemy, lokalizujemy w firmie na etapie testowania,
tutaj jest 5 w tej chwili podane, natomiast w tej chwili się często przyjmuje,
że to jest troszkę więcej, że tutaj te liczby są wyższe, że one są tutaj gdzieś
powiedzmy 10 do 15. Natomiast na etapie pielęgnowania systemu, wtedy kiedy system
już jest oddany użytkownikowi do wykonania.
To widzimy, że tutaj jeżeli błędy zostały wykryte przez użytkownika i mamy je poprawić,
to są bardzo wysokie koszty właśnie usuwania tych błędów.
Co z tego wynika? No z tego wynika, że powinniśmy, prawda, i tutaj te przyczyny
projektów nieudanych, czy przyczyny projektów, które się udały.
To proszę Państwa, to z tego wynika, że musimy się przyłożyć do tej fazy,
pierwszej fazy związanej z określaniem i ze specyfikacją wymagań,
bo to nam daje realne korzyści, prawda. Tutaj ten koszt usuwania błędów jest niski,
więc mimo, że tutaj usuwanie tych błędów i jak gdyby ich lokalizacja,
ta skuteczność wykrycia tych błędów jest niewielka, no to trzeba się jednak w to zaangażować,
zaangażować, żeby jak najwięcej.
Właśnie w tych błędów, wymaganiach wykryć, żeby one nie przeciekały do tych dalszych faz,
bo im dalej one, prawda, będą przeciekać, tym wyższe będą koszty jego usuwania.
Tutaj proszę Państwa, jeszcze chcę zwrócić uwagę na to, że jak gdyby mamy możliwość,
mamy jak gdyby różnego rodzaju błędy możliwe, czyli na przykład może być sytuacja taka,
że mamy dobry,
poprawny zbiór wymagań, ale po prostu projekt zbudujemy na nim błędny.
No to jest, jeszcze jakoś tam daje się te błędy poprawić.
Natomiast tragiczna sytuacja jest wtedy, kiedy mamy błędy w wymaganiach
i na tych błędach, wymaganiach zbudujemy projekt, po prostu wykonamy ten projekt,
no i to może być wtedy, mogą być bardzo poważne konsekwencje.
Bo tak, może być sytuacja taka,
że te błędy będą na tyle poważne, że cały projekt zostanie odrzucony,
że trzeba będzie go przerabiać, a więc będzie to nas kosztowało bardzo dużo czasu, wysiłku,
no i no to kosztuje.
Może być również tak, że pewne błędy jak gdyby są ukryte w projekcie
i one dopiero no zostaną zauważone po długim czasie użytkowania tego projektu,
takie błędy ukrytej.
Oczywiście.
Oczywiście też wtedy koszty tych eliminacji tych błędów, poprawy tych błędów,
no będą bardzo wysokie.
A więc znowu jeszcze raz podkreślam, naszym celem jest budowa poprawnych wymagań.
Wspominałam Państwu o tym przeciekaniu błędów.
Tutaj są dane dotyczące no firmy,
no firmy, która oprogramowanie dla samolotów i proszę popatrzeć,
jak gdyby 4% błędów z projektu wstępnego, 7% z projektu szczegółowego,
jak gdyby przecieka i firmy określają, proszę popatrzeć,
ta firma właśnie budująca oprogramowanie dla samolotów określa, że błędy w wymaganiach,
nawet do 40% sumy budżetu, ich usuwanie może nas kosztować.
Dlaczego?
Dlatego, że błąd w wymaganiach może być potrzebna ponowna specyfikacja projektu,
jak zostanie on wykryty.
No jak mamy tą ponowną specyfikację, to być może trzeba będzie ponownie,
prace projektowe wprowadzić.
No na pewno trzeba będzie jakiś kod napisać.
No jak kod, no to na pewno trzeba będzie nowe testy wykonać.
No to trzeba również zmiany w dokumentacji wprowadzić.
No i teraz proszę Państwa, jeszcze no oby nie było tego,
ale może być potrzeba likwidacji jakichś błędów.
Jakieś uszkodzeń na przykład, no jeśli to jest oprogramowanie jakiejś linii produkcyjnej
i wychodzą złe produkcje, no to jest problem, prawda?
A kto ma pokryć te koszty tych niedobrych wyrobów?
No i może to dochodzić nawet do jak gdyby sytuacji takiej,
kiedy trzeba będzie anulować ten kod, który był przygotowany na błędnych wymaganiach,
czy wycofać pewne gotowe wersje oprogramowania,
czy tak jak wspomniałam, że mogą być, być może w wyniku działania tego oprogramowania
powstały jakieś wadliwe produkty, no i trzeba będzie tutaj ponosić jakieś koszty gwarancyjne, prawda?
No i dochodzą tutaj koszty serwisowania, czyli na przykład instalacja nowej wersji.
No i w przypadku jakichś bardzo poważnych błędów mogą być, prawda,
wręcz jakieś sprawy związane z instalacją nowej wersji.
Sprawy związane z odpowiedzialnością karną, no związaną z tym wadliwym produktem.
Także widzimy, że tutaj możemy mieć no bardzo, bardzo jak gdyby no dużo różnych problemów
i kosztownych czynności, które trzeba będzie zrobić.
Czyli naszym celem po raz, nie wiem, kolejny, powtarzam,
jest zbudowanie dochodów.
Dobrego zbioru wymagań, właściwego wymagań.
No to powiedzmy sobie, a co to jest to wymaganie?
Proszę Państwa, tutaj pokazuję Państwu definicję Taylora.
Co to jest wymaganie?
Więc widzimy, że wymaganie to jest możliwość rozwiązania problemu, tak,
i osiągnięcia celu, która jest wymagana.
Przez użytkownika, czyli no właśnie to jest coś, co ma pewną wartość dla użytkownika.
Z jednej strony to jest wymaganie.
Ale to jest także możliwość spełnienia umowy, normy, specyfikacji lub jakiejś innej dokumentacji,
którą ten system powinien posiadać.
No i teraz proszę Państwa, tutaj już o tym wspomniałam, że jak gdyby pewne problemy,
wiążą się z przechowywaniem, z zarządzaniem tymi wymaganiami,
więc właśnie musimy tymi wymaganiami zarządzać.
To nie jest nie tylko, że jak gdyby je trzeba zebrać,
ale trzeba również nad tymi wymaganiami panować, zarządzać nimi.
Po prostu te wymagania nie tylko trzeba pozyskać, uzyskać,
trzeba je zorganizować, trzeba je udokumentować.
No i właśnie często one są podstawą umowy pomiędzy klientem,
a firmą, która realizuje to przedsięwzięcie.
Zarządzanie wymaganiami to jest tak, jak tutaj Państwu podałam definicję,
zbiór zorganizowanych, uniwersalnych, usystematyzowanych,
procesów i technik zajmowania się wymaganiami stawianymi
złożonemu dużemu przedsięwzięciu.
To jest jak gdyby definicja tego zarządzania wymaganiami.
No i nie tylko, prawda, trzeba te wymagania zebrać,
ale trzeba nimi zarządzać.
O różnych aspektach tego zarządzania jeszcze też będę tutaj Państwu opowiadać,
o różnych cechach.
Proszę Państwa, pojawiało się tutaj już wielokrotnie słowo analiza.
Analiza wymagań, czy analiza problemów.
To jest proces rozumienia rzeczywistych problemów,
potrzeb użytkownika,
oraz proponowanie rozwiązań, które by pozwalały nam spełniać te potrzeby.
No i teraz określenie, co jest potrzebne temu użytkownikowi
i w jaki sposób można by to, co jemu jest potrzebne, zrealizować.
I tutaj, proszę Państwa, też mamy różne, jak gdyby, aspekty tego.
A więc po pierwsze,
no, trzeba ten problem zdefiniować,
trzeba go uzgodnić, prawda, co jest potrzebne temu użytkownikowi.
Teraz, proszę Państwa, często jest tak,
że mamy jakiś problem,
widzimy, obserwujemy pewien problem,
ale za tym problemem, no, kryją się być może jakieś inne problemy.
Więc tutaj to też jest istotne,
żeby, no, żeby właśnie widzieć,
jak te problemy jeden od drugiego są zależne,
co się za którym kryje.
Proszę Państwa, pojawia się tutaj słowo udziałowiec, prawda.
Użytkownik, no to wiemy, tak, tworzonego systemu.
Natomiast my nie tylko musimy,
jak przystępujemy do budowy jakiegoś systemu,
nie tylko musimy zidentyfikować użytkowników tego systemu,
czyli kto będzie w tym systemie pracował,
kto z niego będzie korzystał,
ale również identyfikujemy udziałowców tego systemu.
Taka szybka definicja udziałowiec systemu,
nazwa angielska, którą powinniście Państwo znać.
Ktoś pamięta, jak się nazywa udziałowiec po angielsku?
Stakeholder.
Stakeholder, stakeholder, tak.
Więc to jest stakeholder, to się razem pisze.
I proszę Państwa, taka ogólna definicja tego stakeholdera mówi,
że to jest ktoś, kto może wpływać na ten system realizowany.
To jest również ktoś, na kogo ten system może wpływać.
Czyli takim udziałowcem jest użytkownik systemu,
ale udziałowcem może być ktoś, kto wcale nie będzie z tego systemu korzystał.
Czyli na przykład ktoś, kto będzie finansował ten system,
ale niekoniecznie będzie z niego korzystał.
To może być również ktoś, na kogo ten system ma jakiś wpływ,
nawet czasem od niego.
Czyli wyobraźmy sobie,
że jeżeli mamy system kontroli lotów na określonym lotnisku,
to udziałowcami tego będzie zarząd tego lotniska,
czy właściciel tego lotniska,
ale udziałowcami będą również mieszkańcy terenów,
które są w pobliżu tego lotniska,
w szczególności na przykład terenów,
nad którymi samoloty podchodzą do lądowania czy startują.
Czyli oni w żaden sposób nie korzystają z tego systemu,
ale ten system na nich wywiera pewien wpływ.
Także to jest też taka rzecz, którą trzeba określić.
Kto będzie z tego systemu korzystał, kto jest jego udziałowcem.
Właśnie bardzo istotne jest,
aby określić granice systemu.
Co jest wewnątrz tego systemu, co ma być realizowane,
a co jest na zewnątrz.
Również zidentyfikowanie różnego rodzaju ograniczeń,
które na ten system mają być nałożone.
I tutaj chodzi zarówno o ograniczenia finansowe,
bo mamy na przykład ten system zrealizować
za nie więcej niż tam ileś,
ale również jakieś ograniczenia czasowe.
Na przykład w jakim czasie to trzeba.
Czyli różnego rodzaju ograniczenia.
Tutaj mogą być również jakieś ograniczenia,
które wynikają z dziedziny problemu,
w której ten system ma działać.
Czy wręcz jakieś prawa fizyki, jakieś wzory.
Także różnego rodzaju ograniczenia tutaj trzeba wziąć pod uwagę.
No i proszę Państwa,
tutaj stosuje się różnego rodzaju formaty,
które pozwalają nam pewne rzeczy
w jakiejś takiej bardziej czytelnej formie przedstawić, opisać.
Czyli na przykład właśnie,
żeby tą definicję problemu jakoś uzgodzić.
No więc przygotowujemy sobie takie różnego rodzaju,
jak gdyby takie tabelki.
I opisujemy na czym polega ten problem.
Kogo dotyczy.
Jakich mamy udziałowców tego problemu.
Co ma być jego rezultatem.
Jak gdyby ma to wpłynąć na udziałowców,
na przedsiębiorstwo.
Jakie są korzyści z rozwiązania tego problemu.
No właśnie, jakie proponujemy rozwiązanie.
Jakie podstawowe korzyści.
Wspomniałam Państwu,
że często jest tak,
że mamy pewien problem.
I za tym problemem się kryją jakieś inne problemy.
I często, proszę Państwa,
stosujemy taki diagram,
żeby sobie to jakoś lepiej uzmysłowić,
który po angielsku nazywa się
Fishbone Diagram.
Czyli taki diagram,
dosłownie tłumacząc takich ości ryby.
Nie wiem, czy jest jakieś lepsze określenie.
Tego typu diagramu w języku polskim.
Jeśli ktoś z Państwa zna,
to może się z nami podzieli tą wiedzą.
Ale wyobraźmy sobie,
że mamy pewien problem.
Mamy problem, że na przykład
jest za dużo odpadów w jakimś tam systemie.
I teraz dlaczego?
Skąd się biorą te odpady?
Na przykład dlatego,
że są zwroty od klientów.
A dlaczego są te zwroty od klientów?
Na przykład dlatego,
że są uszkodzenia w transporcie.
Czyli jak gdyby to jest problem,
który się za tym kryje.
Albo dlaczego są te zwroty od klientów?
Na przykład dlatego,
że zamówienia były niezbyt dokładne,
które do nich wysłaliśmy.
Więc stąd mamy za dużo.
Mogą być jakieś wady produkcji.
Może być starzenie się wyrobów.
A więc szukamy tutaj różnych problemów,
które są związane z tym problemem,
że mamy, nie wiem,
za dużo tych odpadów.
I te diagramy typu Fishbone Diagrams
bardzo nam się przydają tutaj
do właśnie uzmysłowienia sobie
tych różnych problemów.
Bo być może przy pierwszym podejściu
widzimy tylko to, prawda?
Że czegoś, coś jest niedobrze z czymś.
Ale jak analizujemy ten problem,
no to jak gdyby jesteśmy w stanie wykryć
inne problemy, które się za nim kryją,
które są jego przyczyną.
Wspomniałam Państwu,
że tutaj to określenie stakeholder,
udziałowiec, każdy na kogo implementacja
tego systemu ma zasadniczy wpływ, prawda?
Niekoniecznie użytkownik tego systemu.
No ale właśnie takie potrzeby
tych innych udziałowców też powinny być
określone i uzgodnione.
Natomiast oczywiście dla nas
decydującą sprawą jest,
kto będzie z tego systemu korzystał.
.
No i tutaj .
Tutaj widzicie Państwo taką listę
pomocnych pytań, które no zwykle sobie
zadajemy przystępując do właśnie
specyfikacji wymagań systemu.
Kto jest użytkownikiem tego systemu?
Kto jest klientem?
Jakie role oni pełną?
Bo tutaj często tych użytkowników
mamy kilka typów.
Właśnie na kogo jeszcze wyniki działania
tego systemu będzie miały wpływ?
Kto będzie ten system oceniał?
Kto będzie go zatwierdzał?
Tutaj również trzeba się zastanowić nad tym,
czy są jacyś inni zewnętrzni,
może wewnętrzni użytkownicy systemu,
których potrzeby też powinny być uwzględnione.
Kto będzie ten system pielęgnował?
No i proszę Państwa z tego jak gdyby
mamy tutaj proces identyfikacji aktorów,
czyli właśnie użytkowników tego systemu.
I tu znowu mamy listę takich przydatnych pytań,
na których no które powinniśmy sobie zadać
po to, żeby różne klasy tych aktorów,
różne kategorie aktorów zidentyfikować.
Żeby nie pominąć jakiejś kategorii aktorów.
Aktorem tutaj jest no właśnie może być użytkownik systemu,
ale może być również jak gdyby ktoś,
kto dostarcza, odbiera pewne dane z systemu.
Właśnie to jest taki kluczowy element analizy tego problemu.
Kto używa z tego systemu?
Kto dostarcza informacje?
Kto je usuwa? Kto obsługuje?
Kto utrzymuje ten system?
Kto go pielęgnuje, konserwuje?
A gdzie ten system będzie działał, tak?
Gdzie będą wprowadzane dane?
Te dane mogą pochodzić z jakichś innych zewnętrznych systemów.
Czyli tutaj jeśli chodzi o aktora,
to może nim być użytkownik systemu,
ale tutaj może być, czyli to może być,
ja tu napiszę user, user.
Ale tutaj aktorem może być również inny system,
który będzie na przykład odbierał dane z naszego systemu
czy dostarczał pewne dane.
Czyli właśnie jakie inne systemy zewnętrzne
będą z naszym systemem oddziaływać, współpracować.
Teraz wspomniałam Państwu, że na tym etapie
jest, no,
potrzeba również zidentyfikowania ograniczeń,
różnego rodzaju ograniczeń,
które na to rozwiązanie są nałożone.
I teraz popatrzmy tutaj na kategorie takich ograniczeń.
Czyli mamy kategorie ograniczeń ekonomicznych.
No więc tutaj właśnie ograniczenia finansowe, tak?
Ile nas to może kosztować? Jaki mamy budżet?
Ale mogą być tutaj również jakieś ograniczenia,
ograniczenia licencyjne, ograniczenia polityczne.
Tutaj też często wchodzą sprawy, jak gdyby ograniczenia licencyjne.
Że w związku z pewnymi decyzjami politycznymi, tak?
To na przykład nie możemy korzystać, powiedzmy,
z jakichś tam, nie wiem, patentów, metod, urządzeń, części,
które są, nie wiem, produkowane, powiedzmy, w kraju, tym a tym.
Ograniczenia techniczne, właśnie bardzo istotne,
wpływają na wybór technologii, właśnie na jakiej platformie to ma działać,
jakie pakiety możemy kupić, zainstalować.
Ograniczenia systemowe, no na przykład właśnie musimy się dostosować
do istniejących systemów, tak?
Musimy być w stanie z innymi rozwiązaniami,
które w tej firmie są, działają, pracują, tak?
Nasz system będzie musiał się jakoś z tymi innymi systemami komunikować,
odbierać dane, przekazywać dane, więc musimy tutaj też mieć pewne ograniczenia
właśnie związane z tymi środowiskami, które są w tych innych systemach,
czy ze sposobami komunikacji z nimi.
Też trzeba wziąć pod uwagę jakieś ograniczenia środowiskowe,
czyli właśnie bezpieczeństwo, prawo, które działa, normy,
do których musimy się zastosować.
No i tutaj również kwestia planowania i zasobów,
czyli ograniczenia w zasobach.
Tutaj na przykład takim zasobem, powiedzmy, jest zespół,
który może to oprogramować,
który może to oprogramowanie realizować.
No i teraz kwestia, prawda, czy też jakieś ograniczenia tego zespołu,
powiedzmy, mogą powodować, że będzie potrzeba zatrudnienia,
nie wiem, nowych osób spoza firmy, bo na przykład nasi pracownicy
pewnych rzeczy nie potrafią i musimy mieć tutaj kogoś,
kto taką wiedzę i takie umiejętności posiada, prawda?
I teraz znowu decyzja, czy to zwiększenie tych zasobów,
powiedzmy, ludzkich, to będzie zwiększenie chwilowe,
tylko na czas trwania tego projektu, czy może, nie wiem,
widzimy w tym jakąś szansę rozwoju tej firmy i na przyszłość
i będziemy chcieli to utrzymać.
Także widzicie Państwo, że tutaj jest bardzo dużo różnych aspektów,
które trzeba wziąć pod uwagę.
I, no, w tej firmie...
W tej fazie początkowej, wstępnej rozważyć.
Czy może do tego mają Państwo jakieś uwagi, komentarze?
Nie słychać. Tak, nie słyszę nic.
Proszę Państwa, mamy 5 minut do końca.
Natomiast następny temat to będzie uzyskiwanie wymagań.
I ja, no, ponieważ to wymaga trochę więcej czasu,
więc ja może na tym dzisiejsze zajęcia zakończę.
I spotykamy się za 2 tygodnie, 2 listopada,
i wtedy będę kontynuować ten temat inżynierii wymagań.
Zacznę od tego, w jaki sposób można te wymagania, co system ma robić,
przy jakich ograniczeniach pracować, w jaki sposób można je uzyskać.
Także to z mojej strony byłoby tyle na dzisiaj.
Jeżeli Państwo macie jakieś pytania, uwagi,
to mamy chwilkę czasu jeszcze, żeby porozmawiać o tym.
Zatrzymam nagrywanie.
Dzięki.
---------------------------------------------I tutaj kontynuowania tematu, którym dwa tygodnie temu już zaczęłam Państwu opowiadać,
mianowicie o tak zwanej inżynierii wymagań.
Dwa tygodnie temu mówiłam Państwu, jak niezwykle ważna jest to faza w procesie produkcji oprogramowania,
właśnie dobre zebranie wymagań, bo od tego zależy sukces albo klęska projektu.
Mówiłam Państwu również o dwóch typach wymagań.
Wymagania funkcjonalne, czyli to, co to oprogramowanie ma robić.
Wymagania niefunkcjonalne, a więc różnego rodzaju ograniczenia, w jakich to oprogramowanie ma pracować.
Chciałabym jeszcze tylko jakiś sygnał z Państwa strony, żeby mnie słychać,
że widzicie prezentację.
Słychać i widać.
Słychać i słychać.
Super, bardzo dziękuję.
Bardzo dziękuję i w takim razie przechodzimy do tutaj spraw teraz związanych z tym tak zwanym requirements engineering.
Nie ukrywam, że jest to chyba najludniejszy etap w procesie produkcji oprogramowania,
przynajmniej ja takie odnoszę wrażenie, dla mnie tak to jest.
Ale no wiedząc jak niezwykle jest to ważne i wiedząc to co Państwu mówiłam 2 tygodnie temu,
że 1 trzecia projektów upada właśnie ze względu na to, że te wymagania były niezbyt dokładnie zgromadzone.
No to teraz przyjrzyjmy się jakie mamy metody uzyskiwania wymagań.
A więc tutaj takim najczęściej jest,
Najczęściej stosowanym to jest wywiad z potencjalnym użytkownikiem tego systemu, z naszym klientem i tutaj istotne jest, żebyśmy o te wywiady prosili, o te rozmowy prosili różne klasy użytkowników, różne grupy przyszłych użytkowników tego systemu,
żeby można było potrzeby ich widzieć nie tylko jak gdyby z punktu widzenia jednej grupy użytkowników, ale szerokiej.
Często ci przyszli użytkownicy proszeni są również o wypełnienie pewnej ankiet i teraz tutaj mogą być takie pytania otwarte w tych ankietach, czyli w stylu co chciałbyś, żeby ten system robił.
Lub takie pytania z jakąś tam listą wyborów, czy po prostu z odpowiedzią tak, nie.
No i proszę Państwa, niestety tak jest, że tak, jeżeli tutaj w tej ankiecie my dajemy pewne konkretne pytania, czy chcesz, żeby ten system robił to lub to lub to, no to jak gdyby my mamy pewną wizję tego systemu i narzucamy tę wizję, narzucamy tę funkcję użytkownikowi.
A być może...
Jest tak, że ta nasza wizja, no nie jest właściwa.
Jeżeli z kolei dajemy takie pytania otwarte, czyli w stylu co chcesz, żeby ten system robił lub jakoś podobnie, no to proszę Państwa praktyka jest taka, że bardzo, bardzo mało osób na takie pytania otwarte odpowiada.
No od lat prowadzony jest system takiej oceny zajęć.
I no ja będąc pracownikiem etatowym Politechniki Warszawskiej skoncentruję się na tym, jak to tam wygląda.
I proszę Państwa, po pierwsze, jeżeli dajemy taką ankietę do zajęć, to znaczy nie my, tylko to dziekana takie ankiety tworzy, no to po pierwsze, no kierowany jest na przykład do 60 osób, które były na tym przedmiocie,
a na tą ankietę, tą ankietę wypełnia, no jak dobrze pójdzie to 6 osób,
ale zwykle mniej, 3-4. Następna sprawa jest taka, że jeśli chodzi jeszcze o zaznaczenie czegoś, to jakoś te osoby wypełniające to zaznaczają, natomiast bardzo mało osób wpisuje te swoje własne uwagi.
Czyli w takich ankietach studenckich też zwykle jest takie pole, co uważasz, czy co chciałbyś, co powinno być zmienione, czy co Ci się podoba, nie podoba. No to proszę Państwa, to tutaj znikoma liczba osób takie swoje uwagi pisze.
Zwykle piszą to osoby, które są z jakichś tam względów bardzo niezadowolone z prowadzenia tego przedmiotu, natomiast w przypadku, jeżeli pytamy użytkowników, co chcesz, żeby ten system,
to też tutaj niezbyt dużo osób nam faktycznie odpowie, bo się po prostu ludziom na to nie chce odpowiadać. Czyli robimy to, ale musimy sobie zdawać sprawę z niezbyt dużej skuteczności tego i również z tego, że nie będziemy w stanie uchwycić całości tego systemu, czy potrzeb, jakie ten system powinien wypełniać z punktu widzenia różnych grup użytkowników.
No to proszę Państwa.
Proszę Państwa, można robić tak zwaną burzę mózgów, czyli no właśnie poprosić i zaprosić ileś osób, które być może w przyszłości będą użytkowały ten system albo zamawiają ten system i mają pewną jego wizję i zorganizować taką burzę mózgów, jak to się zwykle robi.
No musi być jakaś osoba, która będzie tym całym procesem kierowała.
Natomiast te osoby zgromadzone w trakcie tej burzy mózgów, prawda, proponują różne swoje funkcje. Tutaj istotne jest, żeby nie było żadnej oceny w trakcie tego, jak oni tam coś proponują, czyli na przykład ktoś tam zaproponował funkcję 1, tak, ktoś zaproponował funkcję 2.
I te funkcje mogą być bardzo, bardzo, czy powiedzmy tutaj 1.
Osoba, tak, tutaj druga, osoba B, osoba C, D i tak dalej.
I zgłaszają swoje potrzeby.
Przy czym proszę Państwa, w trakcie takiej burzy mózgów, tak jak już mówiłam, nie wolno w żaden sposób ograniczać jej użytkowników, jej uczestników.
Czyli nie można w trakcie, ktoś nam powie na przykład, że chce, żeby tło na ekranie komputera było w kolorze fioletowym.
No to iluś osobom może się to wydawać zupełnie nieistotne albo głupie.
Albo wręcz niedobre, bo to nie jest dobry kolor, ogranicza nam czytelność napisów.
Ale nie wolno nam tego w trakcie tej burzy mózgów powiedzieć, prawda?
Musimy tylko po prostu przyjmować te kolejne propozycje i tyle.
No i ta pierwsza faza tej burzy mózgów to jest po prostu zgłaszanie bardzo różnych propozycji przez właśnie tych uczestników.
No i teraz mamy ileś takich funkcji, które mamy.
Które zostały zgłoszone przez tych uczestników.
Tak jak tutaj już Państwu mówiłam, niektóre z nich mogą być zupełnie nieistotne.
Bo mogą dotyczyć jakichś kolorów czy czcionki.
Ktoś by chciał mieć czcionkę Arial, a ktoś inny Times Roman.
Więc mogą być to, wydaje się, zupełnie nieistotne żądania.
Ale tak jak powiedziałam, na tym etapie pierwszym tego w żaden sposób nie komentujemy.
Teraz drugi etap.
Drugi etap to jest pewna redukcja tych pomysłów, które tutaj powstały.
Które zostały zgłoszone.
I zostawienie tylko takich pomysłów, które faktycznie są istotne, potrzebne tym przyszłym użytkownikom, wartościowe.
No i jak to można robić?
Robi się to przez różnego rodzaju głosowania.
Które się tutaj organizuje.
Czyli na przykład jedna z metod jest taka, że każdemu tutaj mam powiedzmy użytkownika A.
Tu mam użytkownika B, C i D.
I teraz na przykład każdemu z użytkowników powiedzmy dajemy 100 złotych.
Czy jakieś tam jednostki pieniężne.
I mamy ileś tych funkcji, które zostały zaproponowane.
I teraz ten użytkownik decyduje.
Jak on rozdzieli te pieniądze, które ma na te proponowane funkcje.
No więc na przykład użytkownik A powiedzmy postawi 50 tutaj na funkcję pierwszą.
Powiedzmy, że postawi 40 na funkcję.
I tutaj na przykład 10.
A tej funkcji trzeciej w ogóle nie chce.
Użytkownik B może to zrobić zupełnie inaczej.
Tak na przykład.
Bo dla niego ważna jest na przykład ta funkcja druga.
A na przykład tutaj powiedzmy te kolejne mają dla niego podobną wartość.
No i każdy z użytkowników wydaje te przydzielone sobie pieniądze na poszczególne funkcje.
No co dalej możemy zrobić?
Dalej możemy oczywiście zsumować jaka liczba pieniędzy na poszczególne funkcje została zaproponowana.
Przez tych uczestników tej burzy mózgów.
No i z tego na przykład nam wyjdzie powiedzmy, że ja tutaj mam.
Że powiedzmy ta funkcja pierwsza to na przykład zebrała 200 złotych.
A funkcja druga na przykład zebrała 100 złotych.
A funkcja trzecia na przykład tylko 50.
A funkcja czwarta no ileś tam na przykład 120.
Co nam dają te kwoty?
No te kwoty nam pokazują jakie są priorytety tych funkcji.
Prawda?
Jaka jest ważność tych funkcji.
Dlatego, że no wcale nie jest powiedziane, że jeżeli tutaj na przykład użytkownik B zaproponował powiedzmy funkcję trzecią.
Ale on widząc jakie tu inne funkcje się pojawiły.
To może zmienił zdanie.
I może stwierdził, że ta funkcja którą on zaproponował.
Jest mniej ważna od powiedzmy tej funkcji drugiej.
Którą ktoś inny zaproponował.
Czyli mamy w ten sposób mamy określone priorytety tych poszczególnych funkcji.
No i teraz można tutaj podjąć jakieś decyzje.
Na przykład można stwierdzić, że ta funkcja trzecia jest funkcją mało istotną.
Bo mało osób na nią głosowało.
I że tak powiem wykreślić ją.
Z tej linii wymagań, które ten system będzie realizował.
Tutaj mówi się o tak zwanej linii bazowej.
Czyli próbujemy ustalić te wymagania.
Właśnie taką linię bazową tych wymagań.
To jest tak zwane cumulative voting.
Czyli takie głosowanie kumulacyjne.
A inna z metod to jest takie.
Że na przykład każdy z tych uczestników.
Może zagłosować ale tylko na jedną funkcję.
Więc jak gdyby te metody tutaj głosowania mogą być bardzo różne.
Ale jaką metodę byśmy nie stosowali.
Chodzi po prostu o to żeby się zorientować.
Jakie priorytety mają te funkcje.
No wśród osób biorących udział w tej burzy mózgów.
Jeszcze raz podkreślam, że w tej burzy mózgów.
Powinny brać udział tutaj osoby reprezentujące.
Różne grupy użytkowników tego systemu.
Czyli zarówno takich zwykłych użytkowników.
Jak i osoby które będą tym systemem administrowały.
Więc bardzo chodzi o to żeby funkcje były proponowane.
Z różnych punktów widzenia.
Przez różnych użytkowników.
To jest ta burza mózgów.
Teraz inna z możliwości.
To są takie warsztaty.
Takie że na przykład my się przyglądamy pracy osób.
Cichutko sobie tam przyglądamy się.
Czy wręcz możemy filmować pewne rzeczy.
Które robią ci użytkownicy.
I na tej podstawie.
Tutaj wyciągamy pewne funkcje.
Które im są potrzebne.
Czy funkcje które mogłyby ich pracę usprawnić.
Ułatwić.
Więc można i w ten sposób.
Można stosować takie odgrywanie ról.
Czyli jak gdyby postawić się.
W roli.
No na przykład.
Kasjerki.
Jeżeli powiedzmy robimy system bankowy.
Czy postawić się w roli jakiegoś doradcy.
Kredytowego.
Który w tym banku pracuje.
I próbować.
Odgrywać rolę takiej osoby.
I wtedy też.
Przyjmując tą rolę.
Próbując ją odgrywać.
Też będziemy tutaj proponować.
Różne funkcje.
Które dla tej konkretnej osoby.
Są potrzebne.
Przyglądamy się też.
Przypadkom użycia.
Czyli no właśnie.
Jak gdyby pracy tych użytkowników.
Tak od pewnej funkcji.
Aż do końca.
Co ta osoba robi.
Ja mówiłam Państwu już na.
Chyba pierwszym naszym spotkaniu.
O prototypach.
I mówiłam Państwu że.
No.
Prototypy się tworzy.
W trakcie produkcji oprogramowania.
Że zwykle powinniśmy.
Zrobić taki prototyp.
Jeśli chodzi o interfejs użytkownika.
Ale robimy też takie.
Już po tych.
No po tych kilku krokach.
Po tych kilku metodach.
Stosowanych zbierania wymagań.
Często buduje się.
Taki prototyp.
Który będzie miał te funkcje w środku.
Znaczy nie do końca zaimplementowane.
Ale tylko tak zasymulowane.
Że one są.
I teraz bawiąc się.
W cudzysłowie bawiąc się.
Ale pracując prawda.
Na takim prototypie.
Też dochodzimy do wniosku.
Że na przykład patrzymy.
Czy wszystkie z tych funkcji zostały użyte.
Czy tylko niektóre.
Które są potrzebne.
Także te prototypy.
Też niezwykle nam pomagają.
W uzyskiwaniu wymagań.
Jeszcze chcę zwrócić Państwa uwagę na to.
Że.
W trakcie właśnie tych rozmów.
Z przyszłymi użytkownikami systemu.
Czy.
Proszenia ich o wypełnienie ankiet.
Oni będą być może.
Zgłaszać nam różne funkcje.
Różne funkcje.
Które im są potrzebne.
Które chcieliby widzieć w tym systemie.
Ale.
Pewne bardzo ważne funkcje.
Bardzo istotne dla dziedziny problemu.
Często dla nich są tak oczywiste.
Że oni tego nam.
W ogóle nie zgłoszą.
Być może my tego również.
Nie zaobserwujemy w trakcie.
Może zaobserwujemy w trakcie tych warsztatów.
Ale może nie.
Być może one.
Nie zostały również tutaj.
Wyartykułowane.
W trakcie tej burzy mózgów.
Także proszę Państwa.
Na tym prototypie.
Często wychodzi.
Że w tych naszych wymaganiach.
W wymaganiach funkcjonalnych.
W funkcjach jakie system ma realizować.
Że często brakuje.
Bardzo podstawowych funkcji.
Bardzo ważnych.
Dla przyszłego użytkownika.
No właśnie dlatego.
Że one są dla tych użytkowników.
Tak oczywiste.
Że oni zapominają nam.
O tym powiedzieć.
Czy w wywiadach.
Czy w burzy mózgów.
Jak gdyby nie widzimy tego również.
Bo się nie znamy na tej dziedzinie.
I właśnie takie.
Takie funkcje.
Często są tutaj.
Wychodzi na tych prototypach.
Że nie ma czegoś.
Niezwykle istotnego.
Dla przyszłego użytkownika.
Proszę Państwa.
Nie ma jednej.
Skutecznej metody.
Na pozyskiwanie tych wymagań.
Żeby mieć.
Jak najwięcej tych wymagań.
Zgromadzonych.
Trzeba stosować.
Wszystkie możliwe środki.
Czyli jak gdyby.
Jak najwięcej tych metod stosować.
Bo wtedy mamy szansę.
Że te wymagania.
Które zgromadzimy.
Będą pełne.
Będą odzwierciedlały faktyczne potrzeby.
Przyszłych użytkowników.
Jeszcze raz przypominam.
Że jedna trzecia projektów.
Upada.
Ze względu na błędy.
W wymaganiach.
Dlatego ten proces.
No może niezbyt.
Prawda interesujący.
Taki.
Żmudny.
Jest bardzo.
Bardzo potrzebny.
I trzeba go dobrze.
Wykonać.
Czy może coś mają Państwo.
Jakieś swoje własne obserwacje.
Czy ze swojej pracy.
Jakie metody są w Waszych firmach stosowane.
Ktoś coś ma.
Nie ma.
To przechodzimy.
Do następnej sprawy.
Proszę Państwa.
No mamy zgromadzone.
Pewne wymagania.
Prawda.
Tutaj.
Gromadzimy.
Te wymagania.
Korzystając.
Z tych różnych metod.
O których Państwu przed chwileczką.
Wspomniałam.
Oczywiście.
Jak zaczynamy.
Zbierać wymagania.
Dla systemu.
Który mamy realizować.
To musimy troszeczkę.
Trochę się orientować.
W dziedzinie.
W jakiej ten system ma działać.
Dlatego że część tych wymagań.
Wynika ze zrozumienia.
Dziedziny w jakiej ten system ma działać.
Prawda.
Że coś musi tam być koniecznie robione.
Że nie wiem.
Czy częściej.
Czy co parę godzin.
Więc my musimy jak gdyby tutaj.
Pewne rzeczy związane z dziedziną.
Wiedzieć o nich.
Troszkę się tego nauczyć.
Wiadomo że nie znamy się na wszystkim.
Więc właśnie często się współpracuje.
Tutaj z jakimiś osobami.
Z ekspertami z danej dziedziny.
Żeby nam pomogli.
W pewnych takich rzeczach dziedzinowych.
Gromadzimy te wymagania.
Ja już troszkę Państwu mówiłam.
Że te wymagania.
Są jakoś tam priorytyzowane.
Nadawane im są priorytety.
Ale też.
Tak jak widzicie Państwo.
Ten proces jest takim procesem.
Iteracyjnym.
Że tutaj.
Jak gdyby klasyfikujemy te wymagania.
Być może pewne odrzucamy.
Być może pewne nowe.
Dochodzą nam tutaj.
Wszystko widzicie Państwo.
Że te strzałki są w obie strony.
Bo to jest taki proces iteracyjny.
Nie idziemy od początku do końca.
Tylko ciągłe są powroty.
Nawroty.
Teraz proszę Państwa.
Tutaj jeszcze proszę popatrzeć.
Oprócz tego bloku.
Tą klasyfikację.
Czyli tutaj w tej klasyfikacji można rozumieć.
Na przykład określenie priorytetów.
Które z tych wymagań są bardzo ważne.
A które są mniej ważne.
Z punktu widzenia przyszłych użytkowników systemu.
To tutaj jeszcze mamy.
Taki bardzo ważny bloczek.
Conflict resolution.
Rozwiązywanie różnych konfliktów.
To jest też bardzo istotne.
Dlatego, że te wymagania.
Które my tutaj gromadzimy.
Bardzo często są ze sobą sprzeczne.
A więc.
W przypadku takich.
Sprzecznych wymagań.
Trzeba się zdecydować.
Które z nich przejdzie do tej linii bazowej.
A które odpada.
Pewne wstępne rzeczy.
Które są związane z priorytetami.
To już tutaj Państwu mówiłam.
Przy okazji tego gromadzenia tych wymagań.
Na przykład poprzez taką burzę mózgów.
Ale jak tutaj po tych etapach.
Takich.
Dzielenia tych wymagań.
Na pewne grupy.
Na pewne klasy.
Usuwania wymagań.
Które są sprzeczne.
To już potem mamy taką listę.
Już dosyć dobrze.
Akceptowalną przez przyszłych użytkowników.
I taką już bliską.
Tego co będziemy realizować.
I tutaj.
Wtedy jeszcze raz.
Jak gdyby.
Trzeba się tym priorytetom przyjrzeć.
Czy wręcz trzeba ustalić te priorytety.
Prawda.
Nie wszystkie z nich w trakcie tej burzy mózgów.
Miały tam przydzielone te wartości.
Ale tutaj mamy.
Musimy te priorytety nadać.
Wszystkim funkcjom.
Które w różne sposoby zostały zgromadzone.
Czyli teraz.
Które mamy.
No to przydzielamy priorytety.
Poszczególnym funkcjom.
Oczywiście tutaj w tym procesie.
Przydzielania priorytetów.
My musimy też współpracować.
Z tym klientem.
Dla którego ten system.
Będzie realizowany.
Bo to od niego musimy wiedzieć.
Czy pewna funkcja.
Powinna mieć priorytet.
Tu zwykle się korzysta.
Na przykład z takich trzech kategorii.
Że priorytet jest high.
Jest średni.
Medium.
Czy priorytet jest low.
Tak więc.
Do której z tych kategorii.
Dane wymaganie należy zaliczyć.
Mamy tutaj też takie.
Jak widzicie Państwo.
Taki bloczek.
Czyli taka.
Walidacja tych wymagań.
Właśnie często to się odbywa.
W postaci prototypu.
Który prosimy.
Żeby w takim prototypie.
Trochę popracował.
Przyszły użytkownik tego systemu.
No i żebyśmy tutaj dostali.
Pewne informacje zwrotne.
Na przykład czy zauważył.
Że tu czegoś brakuje.
Czy pewne rzeczy są tutaj.
Niepotrzebne.
No i po tym.
Tak jak Państwo widzicie.
Wszystko to są procesy.
Takie iteracyjne.
Które się powtarzają.
Są dokładnie opisane.
Nie tylko są opisane.
Na czym ta funkcja ma polegać.
Ale są również pewne atrybuty.
Tego wymagania.
No właśnie takie jak tutaj Państwo widzicie.
Priorytet czy może jeszcze jakieś inne.
O tych atrybutach wymagań.
Jeszcze dzisiaj będę mówił.
Czy może do tego.
Coś mają Państwo jakieś.
Komentarze swoje.
Tutaj jeszcze.
Chcę zwrócić uwagę.
Na to że ten dokument.
Który tutaj powstaje.
Tutaj był.
Taki bloczek.
Walidacja tych wymagań.
Tutaj był bloczek.
Rozwiązywanie konfliktów.
A skąd wykryć.
Jak wykryć.
Że te wymagania są jakoś ze sobą.
W sprzeczności.
Jeżeli te wymagania.
Jeżeli pracujemy na dokumentach.
No to tutaj.
W tej chwili już.
Sztuczną inteligencję.
Można też zatrudnić do wykrywania.
Sprzeczności.
Czy jakiś konfliktów.
Ale taka podstawowa metoda.
To jest po prostu.
Takie recenzowanie.
Taki review tego dokumentu.
Który te wymagania opisuje.
I tam po prostu czytając ten tekst.
Próba znalezienia.
Takich konfliktów.
Czy.
Właśnie jakichś.
Nieprecyzyjnych opisów.
Czyli.
Tutaj proszę Państwa.
Ten dokument który tworzymy.
On musi być.
Wielokrotnie przeglądany.
Czytany przez różne osoby.
Które będą szukały w nim.
Braków.
Będą szukały w nim.
Jakiś błędów.
Konfliktów.
Sprzeczności.
Czy będą wykrywały.
Błędy w tych wymaganiach.
Proszę Państwa.
Robienie.
Systemu.
Na błędnych wymaganiach.
To jest bardzo groźna rzecz.
Też o tym mówiłam.
Dwa tygodnie temu.
Może to spowodować.
Dojście do takiej sytuacji.
Że zrobimy system.
Tylko że zupełnie.
Nie o to w tym systemie chodziło.
Także musimy tutaj.
W tym systemie.
W którym wymagania są opisane.
Jest wielokrotnie.
Powinien być recenzowany.
Czytany przez.
Analizowany.
Przez wiele osób.
Żeby wykryć.
Wszystkie sprzeczności.
Braki.
Błędów.
Proszę Państwa.
Już wspominałam o tym.
Dwa tygodnie temu.
Czyli to jest właśnie.
To co ten system będzie robił.
To są te usługi.
Które oczekuje użytkownik.
Prawda?
To jest to co system ma robić.
To co jest potrzebne użytkownikom.
Opisując.
Te wymagania funkcjonalne.
My tylko opisujemy.
Co ma być robione.
Nie dodajemy tutaj.
Absolutnie żadnych.
Wskazówek.
Uwag implementacyjnych.
To jest określenie co system robi.
Co system ma robić.
Teraz.
Druga grupa wymagań.
Które też są niezwykle istotne.
To są tak zwane.
Niefunkcjonalne wymagania.
Non functional requirements.
To są różnego rodzaju.
Ograniczenia.
W jakich ten system.
Ma pracować.
Jakie standardy ma spełniać.
I tutaj.
Wymagań niefunkcjonalnych.
Państwu wymieniłam.
Na przykład.
Jakie mają być parametry niezawodnościowe.
Czy jak długo.
Użytkownik ma maksymalnie czekać.
Na realizację swojego żądania.
Ale tutaj.
Jeszcze też o tym.
Chyba za chwileczkę.
Jeszcze coś.
Niektóre z tych wymagań niefunkcjonalnych.
One mogą dotyczyć.
No pewnych procesów.
Tak jak mówiłam.
Niestełnienie tych ograniczeń.
Może całkowicie ten system dyskwalifikować.
Także.
Musimy o tym pamiętać.
Że te wymagania niefunkcjonalne.
Też są bardzo ważne.
No i może się zdarzyć.
Że niespełnienie tych wymagań niefunkcjonalnych.
Może po prostu.
Doprowadzić do tego.
Że system będzie systemem nieużytecznym.
Tak jak już mówiłam.
Te wymagania funkcjonalne.
To co system robi.
Co system robi.
To jest.
Jak gdyby tutaj.
Dla nas niezwykle istotne.
I.
Powinny one być pełne.
To co pokazywałam Państwu.
Ten proces tworzenia tych wymagań.
Takie powroty.
Wielokrotne przeglądanie.
Tego dokumentu.
Różne metody.
Prototyp.
Bo chodzi o to.
Co ten użytkownik.
No by chciał.
Potem może się okazać.
Że jednak nie wszystko będziemy realizować.
No ale dobrze byłoby.
Żeby te wymagania były pełne.
Te wymagania powinny być spójne.
I nie powinny być sprzeczne.
I tutaj właśnie.
Wykrywanie tych sprzeczności.
No to albo poprzez.
Recenzowanie tego dokumentu.
Albo no.
Modele sztucznej inteligencji.
Jak mogą pewne sprzeczności.
W tekstach zapisanych też wykrywać.
Jeżeli je odpowiednio wytrenujemy.
Musimy w jakiś sposób.
Te wymagania opisywać.
No i tutaj.
Mamy też różne.
Metody opisu tych wymagań.
Często firmy mają.
Swoje własne formularze.
Czy takie formatki.
Przygotowane do.
Opisu tych wymagań.
Ja.
Na ten moment.
Będę Państwa uczyła.
Zobaczycie Państwo.
Tam są diagramy przypadków użycia.
Więc właśnie w ten sposób.
Również pokazujemy funkcje.
Wymagania funkcjonalne.
Które system ma realizować.
Dzisiaj troszkę powiem Państwu.
Również o metodach formalnych.
Więc zobaczycie.
Że można w pewnym języku matematycznym.
Też funkcje.
Które system ma realizować.
Opisać.
I również.
Bardzo różnych.
Dotyczą różnych kategorii.
I tutaj.
Takie różne kategorie.
Tych wymagań.
Chcę Państwu pokazać.
Akurat te.
Które tutaj Państwo widzicie.
No właśnie.
To za chwilę się zastanowimy.
Do której grupy wiemy.
Że są wymagania funkcjonalne.
I że są wymagania niefunkcjonalne.
To jest grupa wymagań.
Dotyczących produktu.
Czyli tego co mamy realizować.
I tu jest jakiś przykład.
Że komunikacja między systemem.
A użytkownikiem.
Powinna być w określonym kodzie wyrażonym.
Jak Państwo myślicie.
Jaki typ jest to wymagania.
Funkcjonalne czy niefunkcjonalne.
Niefunkcjonalne.
Dobrze.
Niefunkcjonalne.
Dlatego, że tu jest ograniczenie.
Co użytkownik ma robić.
Tylko pewne rzeczy związane z.
No tu akurat już potem.
One wejdą do implementacji.
Ale to jest wymaganie niefunkcjonalne.
Często istotne są.
Wymagania organizacyjne.
Że na przykład.
Dokumenty muszą być zgodne.
Z jakąś tam normą.
Mogą być również.
To też jest oczywiście niefunkcjonalne wymaganie.
Mogą być również.
Jakieś ograniczenia.
Wymagania zewnętrzne.
I tu mamy taki przykład.
System nie powinien ujawniać.
Operatorom żadnych danych osobowych.
Klientów.
Oprócz nazwisk.
Numerów identyfikacyjnych.
Więc to jest dosyć szczegółowe wymaganie.
Też niefunkcjonalne.
Które też będziemy musieli.
W tym systemie zrealizować.
Także widzimy tutaj.
Proszę Państwa.
Że te wymagania niefunkcjonalne.
One dotyczą różnych kategorii.
Właśnie tych wymagań.
Dotyczących produktu.
Bo tutaj też będą te ograniczenia.
Dotyczące na przykład czasu odpowiedzi.
Zajętości pamięci.
Niezawodności.
I tak dalej.
Ale mogą być to również wymagania organizacyjne.
Czy zewnętrzne.
I teraz może się okazać.
Że nie spełnienie któregoś z tych wymagań.
No to będzie.
Będzie to na tyle istotne.
Że po prostu.
System może być.
Dokrytowany w przyszłości.
No właśnie.
Popatrzmy tutaj na przykładowe.
Wymagania niefunkcjonalne.
Takie bardzo typowe.
Na przykład.
Czas odpowiedzi użytkownika.
Który może być podawany.
W jakiś jednostkach czasu.
Ale może być to również szacowane.
Na przykład.
Przez liczbę transakcji.
Które w jakiejś tam jednostce czasu.
Są przetwarzane.
Ile.
Jaki rozmiar.
Ten system powinien zajmować.
Łatwość użycia.
Prawda.
Często dajemy takie ograniczenie.
Jaka jest łatwość użycia.
Tego systemu.
Także ma być nie wiem.
Łatwy w użyciu.
Czy trudny w użyciu.
No i proszę państwa.
Popatrzmy.
Taka rzecz jak czas odpowiedzi użytkownika.
No to mając gotowy system.
Też.
Więc.
Jeżeli tutaj określamy.
Wymagania niefunkcjonalne.
To dobrze byłoby je tak formułować.
Żeby one były mierzalne.
Żeby dało się je zmierzyć.
No bo.
Wtedy będziemy wiedzieli.
Czy one są spełnione czy nie.
No i tutaj z tą szybkością działania.
Czy rozmiarem.
Natomiast co zrobić z łatwością użycia.
Otóż tutaj podaje się.
Na przykład.
Pewne czasy.
Że.
I można to określić w taki sposób.
Że użytkownik.
Powiedzmy po 4 godzinach szkolenia.
Nie powinien popełniać.
Więcej niż na przykład.
3 błędy w trakcie.
6 godzin pracy z tym systemem.
Czyli.
To jest jak gdyby jedna z metod.
Wyrażania tej łatwości użycia.
Czy mierzenia tej łatwości użycia.
Którą możemy.
Na tym etapie wstępnym.
Właśnie określić.
Inna możliwość.
To tą łatwość użycia.
Czasem wyraża się.
W liczbie ekranów pomocy.
No bo jeżeli ta liczba tych ekranów.
Jest większa tak.
No to mamy użytkownik.
Ma więcej możliwości uzyskania pomocy.
I wtedy można powiedzieć.
Tak.
Kolejne wymaganie niefunkcjonalne.
Mierzalne.
To są parametry niezawodnościowe.
Ja na chyba.
Jednym z ostatnich wykładów.
Będę państwu mówiła.
O parametrach niezawodnościowych.
One są tutaj wymienione.
Jest to dostępność systemu.
Czyli tak zwane availability.
Jest to średni czas pomiędzy błędami.
Mean time to failure.
Jest to częstotliwość pojawiania się błędów.
Occurrence.
Czy prawdopodobieństwo błędu.
Żądanej usługi.
Probability of failure demand.
Będę państwu również mówiła.
Która z tych miar niezawodności.
Do jakiego typu systemu.
Jest odpowiednia.
Ale właśnie tą niezawodność.
Można wyrazić w jednej z tych miar.
Na przykład.
Na przykład.
Dostępność systemu.
Że powiedzmy.
System jest dostępny.
Na przykład.
Pracuje 24 godziny na dobę.
I z tego 23 godziny na dobę.
Powiedzmy jest dostępny.
Więc to są też.
Jak państwo widzicie tutaj.
Pewne miary.
Które da się zmierzyć.
One.
Do różnych typów systemów się stosuje.
Różne z tych miar.
Ale potem mając już gotowy system.
Jesteśmy w stanie zmierzyć.
Czy rzeczywiście ten system.
Prawda jest dostępny.
Na 24 godziny na 24.
Ciągłej pracy.
I.
No i dobrze byłoby.
Żebyśmy tak właśnie wyrażali.
Te wymagania niefunkcjonalne.
Żeby one były mierzalne.
Żeby można było zmierzyć.
Potem już.
Na gotowym systemie.
Czy rzeczywiście.
Te miary są spełnione.
Coś może jakieś komentarze.
Uwagi mają państwo.
Jeszcze.
Inne z takich wymagań niefunkcjonalnych.
Które tutaj państwu pokazuję.
To jest tak zwane.
Robustness.
Nie ma dobrego słowa polskiego.
Na określenie tego.
Co to znaczy.
Używa się czasem słowa solidność.
Ale o co tutaj chodzi.
Tutaj chodzi o to.
Że no.
Jeżeli jest jakaś awaria w tym systemie.
To.
Jak szybko ten czas.
Ten system to oprogramowanie.
Będzie się w stanie podnieść.
Po tej awarii.
Czyli to jest taki czas uruchomienia.
Po awarii.
To jest również.
Tutaj można również określać.
Jakieś prawdopodobieństwo.
Związane z utratą danych.
Które w awarii mogą wystąpić.
Czy jakiś.
Procent zdarzeń.
Które mogą powodować.
Tego rodzaju awarii.
No i.
Przenośność systemu.
Tutaj chodzi o.
Podanie liczby systemów.
Na których to oprogramowanie.
Ma działać.
Prawda.
No więc tutaj na przykład.
Czy to ma działać na systemach Windows.
Także to też jest.
Istotne wymaganie niefunkcjonalne.
Czy coś.
Może mają Państwo jakieś swoje własne.
Obserwacje komentarze.
Związane z wymaganiami.
Niefunkcjonalnymi.
Czy jakieś przykłady.
Wymagań niefunkcjonalnych.
Z którymi żeście się w swojej pracy spotkali.
Proszę Państwa.
Teraz.
No nie tylko musimy te wymagania.
Zidentyfikować.
Zebrać.
Ale musimy je.
W jakiś sposób dobry.
Opisać.
No bo opowiadałam Państwu o tym.
Że trzeba ten.
Że trzeba.
Trzeba sprawdzać na przykład.
Czy nie ma jakiś błędów.
Braków.
Czy nie ma sprzeczności.
W tych wymaganiach.
Więc musimy mieć te wymagania.
Dokładnie opisane.
Również na tyle opisane.
Żeby z tych wymagań.
Dało się zrobić dobry projekt.
Żeby nie było problemów ze zrozumieniem.
Tego co system ma robić.
No i jedna z takich metod.
To użycie języka naturalnego.
Do którego jesteśmy przyzwyczajeni.
Ale ponieważ.
W tym naszym języku naturalnym.
No pewne rzeczy.
Wymagają wielu słów.
Żeby je opisać.
Więc próbujemy sobie.
To troszkę.
W jakieś struktury włożyć.
I tak jak już Państwu wspomniałam.
Często firmy mają swoje własne.
Formularze czy szablony.
W których wpisuje się.
Wymagania jakie system ma realizować.
Wymagania na przykład funkcjonalne.
Można te wymagania.
Również opisywać.
Za pomocą takiego pseudokodu.
Czyli w zasadzie.
Jest to język naturalny.
Ale żeby pewne rzeczy.
Były.
Jak gdyby krótsze w opisie.
A jednocześnie precyzyjne.
To na przykład można używać.
Pewnych słów kluczowych.
Takich konstrukcji.
Które znamy z języków programowania.
Takich.
Operatorów.
Istotne jest też.
Żeby ten tekst był pisany.
Nie taki.
Nazwijmy to nabity.
Od jednej strony do drugiej.
Tylko żeby był.
Przynajmniej z jakimiś wcięciami.
Akapitami.
Podzielony na akapity.
Wtedy łatwiej będzie to czytać.
I zrozumieć.
Są proszę Państwa.
Specjalne języki opisu projektów.
One są bardzo zbliżone.
Ponieważ one.
Powstawały właściwie.
Wtedy kiedy takie oprogramowanie.
Do celów militarnych.
W Stanach Zjednoczonych.
Było tworzone w języku programowania.
Który się nazywał ADA.
Więc one używają.
Po prostu tego.
Języka programowania.
Konstrukcji języka programowania ADA.
I mają pewne.
Dodatkowe takie dyrektywy.
Czy dodatkowe słowa kluczowe.
Które pozwalają nam.
Cały ten projekt.
I wymagania również opisać.
No i są pewne notacje graficzne.
Które.
Łatwe są do czytania.
Ale prawda żeby jeszcze.
Były precyzyjne.
To za tymi symbolami graficznymi.
Zwykle no kryją się.
Również pewne.
Opisy tekstowe.
I tu będziemy się.
Takiej.
Notacji uczyć.
Mamy w UML.
Mamy use case diagrams.
I zobaczymy.
Jak tam się w formie graficznej.
Rysuje te use case.
A potem pod ten use case.
Podkłada się również.
Taki opis krok po kroku.
Jak to ma być realizowane.
Są też takie specjalne diagramy.
Które się nazywa SADT.
Które też można używać.
Do właśnie notacji.
Wymagań funkcjonalnych.
Systemu.
Teraz.
Proszę Państwa.
Jest bardzo dużo różnych.
Tak zwanych.
Specyfikacji technicznych.
I.
Może zacznę od końca.
Ja dzisiaj Państwu pokażę.
Przykłady takich specyfikacji.
Formalnych tylko.
Ale na zasadzie.
Przykładu.
Pewne rzeczy tutaj nam będą.
Występowały w trakcie wykładu.
Jeszcze ale na przykład.
Te rzeczy można opisywać.
Maszynami automatami.
Czy maszynami.
Skończenie stanowymi.
Diagramami stanów.
Można stosować tabele decyzyjne.
Przy pewnych funkcjach.
Na przykład.
Pokazywać takie tabele decyzyjne.
Czy drzewa decyzyjne.
Tych.
Takie metody.
W opisu o zmiany stanów.
To zobaczycie Państwo.
One też będą w UML-u występowały.
Poznamy niektóre z nich.
Diagramy czynności.
Czy schematy blokowe.
Też pewne rzeczy pozwalają nam opisać.
Wyspecyfikować.
Te diagramy czynności.
Występują w UML-u.
Będziemy się tego uczyć.
Modele związków ANSI.
No to pewnie Państwo żeście już to poznali.
Przy okazji baz danych.
Tak czy nie?
Tak.
Są również takie modele.
Data flow diagrams.
Diagramy przepływu danych.
Ja na jednym z wykładów.
Być może.
Wspomnę o nich troszeczkę.
No i właśnie.
Różnego rodzaju modele obiektowe.
Tym się będziemy zajmować.
Bo to jest właśnie ten UML.
Tutaj będą diagramy class.
I nie tylko.
Są również modele sieciowe.
W szczególności są różne typy sieci Petri.
Sieci Petri z czasem.
Bez czasu. Kolorowe. Niekolorowe.
Więc jest bardzo wiele.
Różnych modeli.
Właśnie po to.
Żeby można było.
W sposób precyzyjny.
Pewne rzeczy opisać.
I w przypadku niektórych z nich.
Jest możliwe.
Wręcz przejście do kodu.
Tak jest w przypadku.
Niektórych typów specyfikacji formalnych.
Tutaj.
Przy tych modelach UML.
Też diagram class.
Można automatycznie.
Mieć.
Szkielety kodu.
Wygenerowane.
W określonym języku programowania.
Także one są.
Pozwalają nam na precyzyjne opisy.
A jednocześnie.
Niektóre z nich.
Pozwalają nawet na przejście.
Tak jak wspomniałam.
Do tego kodu.
W określonym języku programowania.
W określonym języku programowania.
W określonym języku programowania.
W określonym języku programowania.
Proszę Państwa.
To co tutaj Państwo widzicie.
To jest.
Jakiś przykładowy opis.
Właśnie w postaci.
Takiego formatu.
Który gdzieś tam.
W jakimś tam systemie.
Jest stosowany.
I tutaj na parę rzeczy.
Chcę zwrócić Państwa uwagę.
Ale mamy tutaj.
Mamy tutaj pewne.
Pewne części takiego opisu.
Czyli tak.
To jest nasza funkcja.
Które system ma realizować.
Musimy nazwać tą funkcję.
Czyli to wymaganie funkcjonalne.
Teraz proszę popatrzeć.
Tutaj przed nim się pojawiły.
Pewne cyferki.
Mianowicie.
Te wymagania.
Które identyfikujemy.
Które system ma realizować.
Musimy.
No gromadzimy je w pewnym miejscu.
Zwykle stosujemy do tego.
Określone systemy.
Które nam w tym pomagają.
Ja takie przykładowe.
O takim przykładowym systemie.
Requisite Pro.
Jeszcze Państwu dzisiaj będę mówić.
I tam zrzut ekranu z tego systemu.
Państwu pokażę.
Ale istotne jest.
Że te wymagania mają swoje identyfikatory.
No właśnie to jest taki identyfikator.
Tutaj widzimy.
Trzech części.
Bo często proszę Państwa.
Te wymagania mają takie struktury hierarchiczne.
Czyli tu mamy.
Powiedzmy pierwszy poziom.
A tutaj ten poziom.
Ma jeszcze poziom niżej.
A ten poziom ma.
A tutaj ma jeszcze poziom niżej.
Czyli to jest poziom jeden.
Drugi i trzeci.
I tutaj mamy.
Jak gdyby na tym głównym poziomie.
To wymaganie jest.
Trzecim wymaganiem z rzędu.
To jest ta piątka.
To znaczy, że ono jak gdyby w swoim.
Ma aż pięć.
Co najmniej pięć lub więcej.
Takich podfunkcji.
I to jest jeszcze taka funkcja.
Niższego poziomu.
Która jest pierwszą funkcją.
W tym piątym wymaganiu.
W piątej funkcji dodanej.
Dodawanie węzłów do projektu.
Tutaj możemy sobie wyobrazić.
Że na przykład chodzi o.
Realizację takiego systemu.
System engineering.
Którym będziemy realizować.
Projekt.
Na przykład projekt obiektowy.
Będziemy rysować diagramy w WMLu.
I trzeba kolejne elementy.
Do tego projektu dodać.
Więc mamy funkcję.
Dodanie węzłów do projektu.
I teraz mamy pierwsze.
To wymaganie.
Znowu jest tutaj identyfikator jego.
Tak jak Państwo widzicie.
I pierwsza sekcja.
Testowy tego wymagania.
Edytor będzie udostępniał.
Użytkownikom udogodnienia.
Do dodawania do swoich projektów.
Węzłów określonego typu.
Teraz druga sekcja.
To jest.
Sekwencja czynności.
I tutaj jak widzicie Państwo.
Krok po kroku pewne rzeczy opisujemy.
Co ma zrobić użytkownik.
Wybrać węzła jaki ma być dodany.
Przesunąć wskaźnik.
W okolice miejsca nowego.
Zlecić jego dodanie.
Wyciągnąć węzeł.
I tak dalej.
Czyli mamy pewną sekwencję czynności.
Właśnie.
To był taki przykład.
Tutaj kawałek fragment przykładu.
Takiego właśnie.
Formularza opisu wymagania.
Bo one.
Zwyczajowo.
Składają się z takich.
Sekcji jak.
Jaką funkcję ma to realizować.
Czy nazwa tej funkcji.
Opis.
W tym przykładzie.
Który tutaj pokazałam.
Dalej była sekwencja czynności.
Ale często mamy tutaj.
Jeszcze inne informacje.
Które zamieszczamy.
Na przykład dane wejściowe.
Skąd będą szły te dane wejściowe.
Czy co jest źródłem.
Czy kto jest źródłem tych danych wejściowych.
Dane wejściowe.
Jakie mają być.
Czy gdzie mają być kierowane.
Jaki ewentualnie ma być wynik.
Być może jakieś ograniczenia.
Jeszcze dodatkowe.
Warunek wstępny.
Jeśli ma być spełniony.
Czyli co ma być spełnione.
Żeby ta funkcja mogła być realizowana.
Warunek końcowy.
Co ma być spełnione.
Po.
Realizacji tej funkcji.
A jeżeli ta funkcja.
Powoduje pewne.
Efekty uboczne.
Na przykład zmienia dane.
W jakimś tam magazynie danych.
No to trzeba.
Te efekty uboczne opisać.
No i być może jeszcze.
Jakieś komentarze i uzasadnienia.
Także proszę Państwa.
Ta specyfikacja wymagań.
Tak jak Państwo widzicie.
Składa się tutaj z wielu elementów.
Z wielu.
Sekcji.
No i tutaj właśnie mamy.
Teraz korzystając.
Do tamtego formatu.
Ten dodaj węzeł.
Właśnie w takiej formie napisany.
Dodaj węzeł.
Często tutaj się pojawia.
W sposób automatyczny.
Właśnie ta identyfikator.
Który tam widzieliśmy.
Opis.
Czyli tu jest tekst który to opisuje.
Dodaje węzeł.
Do istniejącego projektu.
Użytkownik wybiera typ węzła.
I położenie węzła.
Przesuwa wskaźnik na właściwy obszar.
Po dodaniu węzeł jest zaznaczony.
Dane wejściowe.
I identyfikacja tej funkcji.
No jaki typ węzła.
Gdzie ma być położony.
Do jakiego projektu.
Identyfikator projektu.
W którym projekcie to ma być.
Czy kto jest źródłem danych wejściowych.
Użytkownik.
Bo pewne rzeczy podaje.
Baza danych projektu.
Bo musimy ten projekt wziąć z jakiejś bazy danych.
Dane wejściowe.
I wynik.
To jest też identyfikator projektu.
Który będzie podlegał zmianie.
Przeznaczenie.
Tutaj dzieje się to w bazie danych projektu.
Wymagania.
Identyfikator określa korzeń grafu projektu.
Czyli w którym projekcie będziemy coś zmieniać.
Warunek wstępny.
Ten projekt jest otwarty.
I jest wyświetlony.
I wtedy w nim będziemy te zmiany wprowadzać.
Warunek końcowy.
Pozostałe elementy projektu nie ulegają zmianie.
Czyli dodajemy do projektu.
Jakiś nowy element.
Ale nie możemy zmienić.
Żadnych innych.
Elementów.
Fragmentów.
Które w nim są.
No i tutaj mamy.
Brak efektów ubocznych.
Nie chcemy.
Ta funkcja nie zmienia nic innego.
Proszę Państwa.
Także to po prostu.
Jako przykład.
Tu formularze wyglądają.
Czasem firmy mają takie swoje.
Specjalne formatki.
W edytorach.
W jakich to jest tworzone.
Czy to w Latechu.
Czy w jakichś innych edytorach.
Teraz proszę Państwa.
Kolejna sprawa.
O której tutaj chcę troszkę poopowiadać.
Mianowicie.
To są klasy stałości wymagań.
Ja już Państwu wspomniałam.
Dzisiaj.
Że wymagania.
Mają pewne swoje atrybuty.
I wspomniałam.
Że jednym z takich atrybutów.
Jest priorytet tego wymagania.
Ale innym z takich atrybutów.
Jest właśnie.
Jeszcze stałość tego wymagania.
Dlatego.
Że no właśnie.
Jak zbieramy wymagania.
Które system ma realizować.
To część z tych wymagań.
Które zidentyfikujemy.
To będą.
Pełne wymagania.
Dotyczące.
Dziedziny problemu.
Wynikają z podstawowej.
Działalności firmy.
Dla której to oprogramowanie tworzymy.
Czyli właśnie z modeli dziedzinowych.
Te wymagania.
Wynikają.
Czyli na przykład.
Jeżeli mamy realizować.
System dla szpitala.
Czy system dla przychodni.
No to.
Tam pewne wymagania.
Dotyczące.
Pacjentów.
Ich dokumentów.
Lekarzy.
Pielęgniarek.
I tak dalej.
Natomiast druga grupa wymagań.
To mogą być wymagania.
Nie stałe.
Czyli my tutaj je.
No uwzględniamy.
W momencie.
Zbierania tych wymagań.
Ale.
Zmianie.
W trakcie realizacji systemu.
Często są to.
Jakieś rzeczy związane.
Z prawem.
Z prawodawstwem.
Czy jakieś sprawy organizacyjne.
Które.
Czyli my się dostosowujemy.
Do tego co jest.
Ale.
Być może to się zmieni.
W trakcie realizacji.
Zmiany.
I tak dalej.
Zaraz.
Mówiłam.
O.
O tym.
Czy można.
Zmiana.
I.
Zmiana.
Teraz.
Na.
Mówiłam.
O.
Dzisiaj.
wymagań. Teraz chcę z kolei powiedzieć o różnych poziomach
tej identyfikacji wymagań, czyli to, co ja Państwu dzisiaj opowiadałam
o tych różnych metodach, burze mózgów, warsztaty wymagań,
to były właściwie potrzeby, określanie potrzeb, zbieranie potrzeb
udziałowców systemu. To są tak zwane ogólne cele tego systemu.
One często są niejasne, niejednoznaczne, musimy je potem doprecyzować.
Od tego zwykle zaczynamy, od określenia tego, jakie cele system ma spełniać.
Teraz jeszcze, co to jest udziałowiec. Otóż udziałowiec jest takie ładne
słowo angielskie, stakeholder, które czytamy,
które często stosujemy. Za chwileczkę taka definicja się pojawi,
co to jest ten stakeholder. Teraz, proszę Państwa, czyli takie ogólne cele systemu.
Można mówić tutaj o goals, jakie cele miał ten system.
Teraz drugi poziom to są usługi, których ten system ma dostarczać
po to, żeby te cele spełnić. I to jest taki też jeszcze dosyć ogólny poziom,
troszkę niżej. A to, co nam jest potrzebne do realizacji tego systemu,
to są te wymagania, jakie to oprogramowanie ma realizować,
czyli to wymagania funkcjonalne, wymagania niefunkcjonalne.
Teraz, jeśli chodzi o te atrybuty, to tutaj taki zbiór atrybutów też Państwu pokazuje.
Czyli...
Czyli na przykład, jeśli chodzi o wymagania, to one mogą być w różnych fazach,
w różny status tego wymagania. Czyli na przykład, żeśmy zaproponowali
ileś tych wymagań, które system ma realizować.
Potem będzie jakiś ten proces klasyfikacji wymagań, usuwania błędów,
braków, niespójności, sprzeczności, priorytyzacja.
I wreszcie potem...
W tym procesie, prawda, pewna część tych wymagań zostanie zatwierdzona
do tej linii bazowej, którą system będzie miał realizować.
No, a potem jeszcze może być tak, że już część tych wymagań została zrealizowana
i wprowadzona do systemu. No, czyli właśnie ten status to jest postęp,
w jakim ta funkcja, to wymaganie się znajduje.
Czy to jest ta faza wstępna zaproponowana, czy już to zostało, jak gdyby, zatwierdzone,
że faktycznie będziemy to realizować, czy może już to zostało zrealizowane.
O priorytetach już mówiłam Państwu, w szczególności, że na przykład
ten priorytet, prawda, określa na podstawie priorytetów, wybieramy z tej
dużego zbioru te wymagania, które mają być realizowane.
I tutaj mówiłam Państwu o priorytetach typu high, medium, low.
Można to również inaczej nazywać.
Na przykład, że to wymaganie jest konieczne dla użytkownika, tak, musi je mieć.
Że to wymaganie jest bardzo ważne dla użytkownika, też powinien on je mieć zrealizowane.
Czy może tylko tyle, że to wymaganie jest użyteczne, przydałoby się temu użytkownikowi,
tak, i znowu tutaj, prawda, decyzja, czy faktycznie ono będzie realizowane, czy nie.
Teraz, proszę Państwa, przy tych funkcjach, jakie...
ma realizować system,
próbujemy określić również, jaki wysiłek
się wiąże z realizacją danej funkcji.
Wysiłek określa się na przykład tak zwany person per, nie wiem,
month czy week, czyli ile osób, na przykład, ile osobo-tygodni,
czyli ile osobo-dni szacujemy, że powinno...
że jest potrzebne, żeby zrealizować tą funkcję.
Czy pewne szacunki dotyczące liczby linii kodu,
a o tym, jak się takie szacowania robi, będę Państwu mówić na ostatnim wykładzie.
Czy takie mniejsze, mniej dokładne określenie tego wysiłku,
tylko na poziomie, prawda, czy to jest wysiłek wysoki,
czy to jest taki średniej skali wysiłek, czy może niewielkim nakładem,
w tym wysiłku, prawda, pewną funkcję szacujemy, że się da zrealizować.
No i wtedy ten wysiłek, prawda, po równaniu z tym, na przykład, korzyścią,
no to może, prawda, możemy się decydować, że pewną funkcję,
która jest tylko użyteczna, ale za to nie potrzebujemy dużego wysiłku
do jej realizacji, możemy ją włączyć, prawda, i możemy ją zrealizować.
No i, proszę Państwa, kolejna dosyć...
istotny atrybut, to jest ryzyko.
To jest, proszę Państwa, prawdopodobieństwo,
że cecha spowoduje niepożądane zdarzenie.
Ten poziom ryzyka określa się zwykle albo na poziomie właśnie takim niski,
średni, wysoki, albo próbujemy to procentowo podać również,
jak...
pracujemy, to ryzyko związane z realizacją i z tym, że ta cecha może spowodować
niepożądane rzeczy.
O stabilności już Państwu mówiłam, znaczy mówiłam Państwu,
że niektóre z tych wymagań są, prawda, stabilne, niektóre będą się zmieniały,
więc tutaj też tą stabilność trzeba dotyczyć.
Teraz, proszę Państwa...
określamy, w zależności, jaką metodę procesu produkcji oprogramowania wybierzemy,
ale mówiłam Państwu, że w przypadku systemów włożonych bardzo,
no to często stosujemy taką metodę iteracyjną, prawda, inkrementalną,
że w kilku czy kilkunastu wersjach to oprogramowanie będzie dostarczane i będzie tworzone.
I na początku, prawda, no, jakieś decyzje są podejmowane co do tego,
w ilu takich inkrementach przewidujemy realizację tego systemu.
I tutaj często, no, też próbujemy już na tym etapie wstępnym określić,
w której wersji ta cecha, to wymaganie, ta funkcja pojawi się po raz pierwszy.
To są oczywiście nasze szacowania na tym etapie wstępnym.
One w trakcie...
Realizacji projektu mogą się zmieniać,
dlatego że, tak jak Państwu mówiłam,
kierownik projektu może podejmować decyzje w kolejnych tych iteracjach,
w kolejnych inkrementach, które z tych funkcji wybierze do realizacji.
I to się troszkę może zmienić.
Tutaj też można określić w przypadku właśnie pewnych wymagań,
przydzielenie do, czyli na przykład, który zespół będzie odpowiedzialny,
jeżeli mamy kilka zespołów, duży projekt realizowany,
to jak gdyby, który zespół jest odpowiedzialny za definiowanie tego wymagania,
za realizację tego wymagania.
I tutaj mogą być również pewne rzeczy związane ze śledzeniem,
które Państwu pokażę troszkę później na konkretnym przykładzie.
No właśnie, proszę Państwa, dużo, dużo różnych rzeczy.
Oczywiście trzeba to gdzieś gromadzić, przechowywać.
I to w takiej formie, żebyśmy byli, bo tak jak Państwo widzieliście,
ten proces pracy z wymaganiami jest takim procesem iteracyjnym.
Wracamy do pewnych rzeczy, zmieniamy pewne rzeczy.
Więc musimy to mieć w jakimś systemie po prostu zapisane,
żeby było.
Łatwo było te rzeczy zmieniać.
W szczególności na przykład, jeśli chodzi właśnie o te atrybuty
poszczególnych wymagań, czy cech systemu,
to tworzone są tak zwane macierze atrybutów.
I tutaj widzicie Państwo zrzut ekranu z systemu Requisite Pro,
który jest dostępny w Waszej szkole,
gdzie można właśnie określać, czyli mamy tutaj,
tu mamy, proszę Państwa,
takie cele ogólne, czyli że system powinien liczyć to i to.
Czyli takie ogólne cele systemu, ale też określamy priorytety tych celi,
czy one są wysokie, czy są średnie, czy niskie, na przykład trudność.
I tutaj możemy dodawać pewne priorytety, są przez ten system automatycznie proponowane,
ale możemy je...
zmieniać, dodawać swoje własne.
I tu jak gdyby jest nazwa tego wymagania, czy tej cechy,
a jak gdyby jest z tym związany pewien opis dokładniejszy.
Tak jak tutaj Państwo widzicie.
Tu widzimy tylko, że system, ten QBS system powinien na żądanie użytkownika
wyświetlać informacje o kliencie.
I tutaj mamy podane, jakie te informacje są.
Wspominałam o tych identyfikatorach, więc ten identyfikator jest istotny.
Czy identyfikator dotyczący wymagań, czy identyfikator dotyczący celu, czy funkcji.
Nazwa, czyli krótki tekst opisujący, pełen tekst dokładnie to opisujący
i, tak jak Państwo widzicie, atrybuty.
Zobaczmy, jak to wygląda.
Zobaczmy, jak to wygląda.
Zobaczmy, jak to wygląda. Zobaczmy, jak to wygląda.
Teraz, proszę Państwa, mamy normy jakości przez IEEE zatwierdzone.
Jedna, o której tutaj mówię, to jest 830.
Jest, potem są kolejne.
Bo chodzi o to, żeby ocenić, czy ta specyfikacja wymagalna,
w cudzysłowie, czy ona jest dobra, czy nie.
I tutaj widzicie Państwo pewne zbiory takich pożądanych cech,
czyli ten opis powinien być potrzebny.
Poprawny, jednoznaczny, kompletny.
Wszystko zawierać to, co potrzebne jest użytkownikowi.
Spójny.
Uporządkowany według ważności i stabilności,
czyli tutaj chodzi o określenie tych atrybutów.
Sprawdzalny.
I tutaj właśnie to, co Państwu mówiłam, że np. jak podajemy wymagania niefunkcjonalne,
no to postarajmy się je podać w takiej formie, żeby można było je potem pomierzyć.
No to postarajmy się je podać w takiej formie, żeby można było je potem pomierzyć.
Sprawdzić.
To się zmienia, szczególnie w tych początkowych etapach pracy nad projektem,
więc musi być to modyfikowalne.
I dlatego potrzebujemy tutaj takich specjalnych systemów,
które pozwalają nam nad tymi wymaganiami zapanować.
No i musi być to możliwe do śledzenia, do modyfikowania i do zrozumienia.
Stąd konieczne są takie systemy.
O jednym z nich tutaj wspomniałam.
Jeden z ekranów systemu Requisite Pro.
Jeszcze za chwilę Państwu pokażę kolejny ekran z tego systemu.
Teraz wspomniałam Państwu, że te wymagania są w różnych stanach,
w różny status.
Że może być wymaganie zaproponowane,
ale potem tych zaproponowanych wymagań jest dużo.
Do realizacji wybierana jest linia bazowa,
więc tylko nie wszystkie one przejdą,
więc wymagania muszą być zatwierdzane.
No i w jaki sposób to się robi?
Tutaj możliwe.
A więc po pierwsze robimy przeglądy wymagań.
Czyli właśnie ten dokument zawierający te wymagania
podlega systematycznej analizie, recenzowaniu przez pewien zespół ludzi.
Robimy prototypy.
Na których te wymagania sprawdzamy, czy one wszystkie są.
Tutaj nam to pozwala pewne rzeczy wykryć.
Na przykład tak zwane trudne usługi,
czyli takie bardzo podstawowe funkcje,
o których często użytkownicy zapominają nam wspomnieć,
że to jest istotne dla nich.
Tutaj proszę Państwa też projektuje się test,
testy akceptacyjne dla tych wymagań funkcjonalnych i niefunkcjonalnych.
Jeszcze nie ma systemu,
ale dobrze jest mieć takie testy już tutaj na tym etapie,
bo wtedy też będzie wiadomo potem jak to sprawdzać,
ale też będzie jak gdyby wiadomo o co chodzi.
Automatyczna weryfikacja niesprzeczności,
wykrywanie niezgodności w tej bazie wymagań.
Więc to tak jak Państwu mówiłam,
że elementy sztucznej inteligencji mogą być tutaj wdrożone,
żeby na przykład w tych opisach tekstowych wykrywać pewne sprzeczności,
czy pewne niezgodności,
czy po prostu człowiek czyta te opisy i szuka,
doszukuje się jakichś niezgodności, sprzeczności.
Modele formalne pozwalają nam na automatyczne sprawdzanie tego
i takie przykłady takich dwóch typów modeli formalnych,
ja dzisiaj Państwu pokażę.
Teraz planowanie zmian.
No właśnie tutaj też jak gdyby niektóre z tych wymagań
wiemy, że będą mogły być zmieniane,
więc jak gdyby tutaj to też trzeba jakoś to planować.
Mówiłam Państwu,
kilkakrotnie używałam określenia linia bazowa,
czyli właśnie ten zbiór wymagań,
które będą realizowane w systemie.
I to się może trochę zmieniać w trakcie realizacji systemu.
No i w zależności od tego, jaki model procesu produkcji systemu przyjmiemy,
no to albo będziemy w stanie tutaj rzeczywiście jakieś zmiany wprowadzać,
albo być może nie.
Tak czy inaczej musimy określić taki kanał kontroli zmian.
Czyli właśnie te żądania zmian muszą być gromadzone.
No trzeba się zastanowić, ktoś musi podjąć decyzję,
czy ta osoba, która to żądanie zgłosiła ma prawo to zgłaszać, czy nie.
Zastanawiamy się, jaki wpływ to żądanie może mieć na system.
No i trzeba podjąć decyzję,
czy rzeczywiście ta zmiana ma być wprowadzona, czy może nie.
Czy może jest to żądanie zmiany jakiejś mało istotnej,
a wprowadzenie tej zmiany wiązałoby się z bardzo dużą pracochłonnością
i powiedzmy wycofujemy tą zmianę.
W każdym razie trzeba te zmiany gromadzić, kontrolować, podejmować decyzję,
czy mają być wprowadzone, czy nie.
Musi być to wszystko oczywiście dokumentowane.
I te wymagania są, proszę Państwa, wersjonowane.
Czyli tak jak wersjonujemy w trakcie programowania, tworzenia, oprogramowania
poszczególne wersje tego tworzonego systemu,
tak również tutaj te wersje tych wymagań też powinny być gromadzone,
żebyśmy wiedzieli co się działo, prawda, dlaczego się działo.
I...
Yyy...
Kolejna rzecz, o której tutaj chwileczkę chcę wspomnieć,
to jest kwestia zależności, tak zwane traceability.
I to jest, proszę Państwa, no dosyć trudna rzecz, ale bardzo istotna.
Mianowicie pomiędzy poszczególnymi wymaganiami są pewne zależności, prawda.
I teraz dobrze byłoby, żebyśmy te zależności znali, żebyśmy mogli je śledzić.
Dlaczego?
Dlatego, że może się okazać, że na przykład któreś z tych wymagań jest,
nie będzie realizowane, jest usuwane.
No i teraz musimy wiedzieć, czy usunięcie tego wymagania, tak,
będzie wpływało na jakieś inne wymagania, które w tym systemie są.
Więc stąd te zależności, to traceability jest istotne.
Yyy...
Jakie tutaj elementy?
Czyli po pierwsze,
trzeba wiedzieć, którzy z udziałowców proponowali to wymaganie.
Wydziałowiec, udziałowiec, jeszcze raz przypominam, stakeholder,
czyli osoba, która albo korzysta z tego systemu, czyli użytkownik,
ale może być to również osoba, która nie będzie z tego systemu bezpośrednio korzystała,
używała go, ale na którą ten system ma wpływ,
lub która może wpłynąć na ten system.
Na przykład, bo finansuje produkcję tego systemu.
Istotne jest określenie powiązań pomiędzy wymaganiami.
No, tak jak już mówiłam wielokrotnie, niektóre z nich są od siebie wzajemnie zależne
i trzeba znać te powiązania, żeby właśnie w przypadku, jeżeli zmiana jest w jakimś jednym wymaganiu,
no, żeby wiedzieć, na co, na jakie inne wymagania ta zmiana może wpłynąć.
I ewentualne powiązania z projektem, czyli na przykład wskazanie,
w którym module będzie implementacja, czy jest implementacja tego modułu,
czy powiązanie z przypadkami, które będą testowały,
testami, które będą to wymaganie, tę funkcję testowały.
Proszę popatrzeć, tu jest taki przykład macierzy zależności,
czyli tak, jak Państwu mówiłam, te identyfikatory wymagań, tak, tu widzimy tylko dwa poziomy
i mamy tutaj w tej macierzy zależności, to się nazywa tej stability matrix,
mamy jakieś literki wpisane, D, dependability, czyli jest zależne albo jest jakaś relacja pomiędzy tymi wymaganiami.
Wspominałam Państwu o tym narzędziu Requisite Pro, które jest dostępne w Waszej szkole
i to jest przykład właśnie takiej,
macierzy zależności, rzut ekranu z tamtego systemu.
Tutaj mamy żądania udziałowców, stakeholder request w tej części,
natomiast tutaj mamy use cases, czyli już konkretne funkcje, które ten system ma realizować.
I teraz proszę popatrzeć, też wspominałam o takich celach ogólnych,
tego systemu i tutaj pokazana jest zależność właśnie tych use cases z tymi celami ogólnymi
w postaci takich strzałeczek, czyli execute trade, tak,
i tutaj ta cecha taka ogólna, że system pozwala na tam, nie wiem, sprzedawanie czegoś i czegoś.
I teraz proszę Państwa, tak, część tych strzałeczek, tych zależności,
narzędzie wstawia automatycznie, bo mamy opis, nie tylko nazwę tego use case'a, prawda,
ale mamy opis jego tekstowy i mamy opisy tekstowe tych cech, tak,
i teraz po prostu to narzędzie sprawdza, czy, no, tutaj coś mu się wydaje, że jest jakaś zależność.
Jeżeli tak, to, jeżeli to narzędzie wstawia automatycznie, bo mamy opis, nie tylko nazwę tego use case'a, prawda, ale mamy opis jego tekstowy i mamy opisy tekstowe tych cech, tak,
jeżeli to narzędzie wstawia taką zależność, to wstawia, ale tutaj jeszcze widzimy, że to jest podejrzane, prawda,
bo to jest nie moja propozycja, tylko to jest propozycja tego narzędzia,
więc mamy tutaj taką kreseczkę, która ma nam powiedzieć, że, no, jest to troszkę podejrzane, żebyśmy to sprawdzili.
I teraz my się przyglądamy, czy ta zależność faktycznie ma miejsce, czy nie.
I albo możemy powiedzieć, nie ma miejsca,
i po prostu usunąć tutaj tą zależność, albo ją zaakceptować.
No i wtedy ta kreseczka czerwona, prawda, znakująca, że jest to troszkę podejrzane, zniknie.
I mamy w ten sposób, prawda, możemy widzieć, jakie są zależności pomiędzy poszczególnymi elementami.
My również określamy, co, jakiego typu zależności chcemy.
My, na przykład, określamy, że chcemy tutaj...
use case'y, popatrzeć, jakie są zależności pomiędzy use case'ami i pomiędzy feature, pomiędzy tymi celami systemu.
Lub może byśmy chcieli inaczej, jakie są zależności pomiędzy use case'em, a pomiędzy żądaniami udziałowców.
Także to jest nasza decyzja, jakie zależności, czego od czego chcemy w tej macierzy zależności tutaj otrzymać.
No właśnie.
No właśnie.
I pojawiało się tutaj określenie, nazwa jednego z narzędzi, Requisite Pro, które może nam pomóc, prawda, w przechowywaniu wymagań.
Bo, no wiemy, że tych wymagań jest bardzo dużo, że one mają swoje atrybuty, że będziemy modyfikować i atrybuty, i być może opis tych wymagań.
A więc musimy mieć możliwość łatwego przechowywania i modyfikowania tych wymagań.
A więc musimy mieć możliwość łatwego przechowywania i modyfikowania tych wymagań.
A więc musimy mieć możliwość łatwego przechowywania i modyfikowania ich.
A więc musimy mieć możliwość łatwego przechowywania i modyfikowania ich.
A więc musimy mieć możliwość łatwego przechowywania i modyfikowania ich.
Stąd właśnie te narzędzia typu Case, Computer Edit, Software Engineering i jeden zrzut ekranu narzędzia Requisite Pro do właśnie zarządzania wymaganiami.
Stąd właśnie te narzędzia typu Case, Computer Edit, Software Engineering i jeden zrzut ekranu narzędzia Requisite Pro do właśnie zarządzania wymaganiami.
Stąd właśnie te narzędzia typu Case, Computer Edit, Software Engineering i jeden zrzut ekranu narzędzia Requisite Pro do właśnie zarządzania wymaganiami.
widzieliście, czyli gromadzenie, organizowanie,
przechowywanie atrybutów.
Teraz właśnie tutaj możemy mieć również narzędzia,
które służą do zarządzania zmianami w tych wymaganiach,
czyli takimi konfiguracjami wymagań, takimi wersjami wymagań.
Czy możemy również mieć jakieś narzędzia, które pomagają nam
w śledzeniu zależności.
Pewne zależności identyfikują automatycznie, tak jak Państwu wspomniałam,
ale możemy to oczywiście sobie zmieniać,
ale w każdym razie przechowują, aktualizują te wszelkie zależności.
I w ten sposób, proszę Państwa, doszłam tutaj do końca tej prezentacji
związanej z inżynierią wymagań.
Czy może mają Państwo jakieś swoje własne obserwacje,
komentarze czy pytania?
Nie słyszę, nie widzę również na czacie.
Wobec tego, proszę Państwa, zaczniemy przerwę teraz,
troszkę wcześniej, ale będzie to po prostu siedem minut,
ale zostało do przerwy, to jak gdyby jest bez sensu,
żebym ja zaczynała jakiś nowy temat.
Także ogłaszam przerwę teraz, powiedzmy, że jest dziewiąta czterdzieści,
czyli do godziny dziewiątej pięćdziesiąt pięć jest przerwa.
Także nie ma dbajania o pewne informacje i to właściwie trochę na samej centimeterze,
ja wyÁgazuję, ja będę przeprowad encoding consisting of a sharing.
I spodziewaié mnie, że to jeszcze nie jest takiego38 birthday,
jeśli jeszcze nie, to tak powiem tu, że też jest coś tam takie krótkie niż swoje dzieci,
tutaj beni zazn étant lithium-ionowe i narzędzie,
co mi vrauy fruitful.
W możliwości.
Dziękuję.
Dziękuję.
Dziękuję.
Dziękuję.
Dziękuję.
Dziękuję.
Dziękuję.
Dziękuję.
Dziękuję.
Dziękuję.
Dziękuję.
Dziękuję.
Dziękuję.
Dziękuję.
---------------------------------------------Proszę Państwa, jestem z powrotem już. Teraz przejdę do nowego tematu.
Mianowicie będę chciała Państwu pokazać mniej więcej na czym wygląda, na czym polegają specyfikacje formalne.
Po pierwsze są dwie grupy takich specyfikacji.
Mianowicie specyfikacje algebraiczne.
Specyfikacje algebraiczne i bazujące na modelu, to się nazywa model-based specification, algebraic specification.
I teraz zacznę od tych algebraicznych specyfikacji.
Tutaj to coś, co opisujemy, to opisujemy jako zbiór relacji pomiędzy operacjami na tym obiekcie.
To proszę Państwa, pierwsze pomysły to były, tak jak Państwo widzicie, dawno temu, 1977 rok.
Po raz pierwszy takie coś zostało zaproponowane do specyfikacji abstrakcyjnych typów danych,
które w owym czasie w językach programowania weszła możliwość definicji swoich typów danych.
I mamy tutaj dwie takie notacje sekwencyjne OBJ i taka specyfikacja, która nie wiem dokładnie jak się to czyta.
Jedni to nazywają LARC, inni LARCZ. Jaka jest właściwa wymowa tego, nie wiem.
I ta jest taka bardziej rozpowszechniona. Są do tego narzędzia, które pozwalają sprawdzić, zweryfikować, udowodnić.
I są również notacje współbieżne. Jest taki język LOTOS, który na przykład był używany do specyfikacji protokołów komunikacyjnych.
Na czym polega ta specyfikacja algebraiczna?
Otóż tak jak Państwu w skrócie powiedziałam, określa się relacje pomiędzy operacjami na tym obiekcie.
Więc ona składa się z dwóch części. Po pierwsze mamy taką część sygnaturową, w której definiujemy,
jakie operacje na tym czymś, co opisujemy na tym obiekcie, który specyfikujemy, można wykonać i jakie są parametry tych operacji,
ewentualnie jaki wynik jest zwracany.
I druga część, znacznie trudniejsza do przygotowania, to jest część aksjomatyczna.
Poprzez tworzenie, pokazanie pewnych relacji pomiędzy tymi operacjami, które tutaj zostały zdefiniowane, my praktycznie definiujemy te operacje.
I po prostu pokażę Państwu jakiś prosty przykład.
I po prostu pokażę Państwu jakiś prosty przykład.
I po prostu pokażę Państwu jakiś prosty przykład.
Popatrzmy właśnie na przykład współrzędnych kartezjańskich.
Może zacznę od tego, że tu jest taka formatka do opisania tych specyfikacji algebraicznych, czyli mamy taką etykietę, to co specyfikujemy nazywa się koord.
Te słowa sort, import to są takie słowa kluczowe, czyli to jest definicja.
Czyli to jest defini... definiujemy koord, a w definicji tego koord korzystamy z typów takich wbudowanych jak integer i jak boolean.
Czyli to jest defini... defini... defini... definiujemy koord, a w definicji tego koord korzystamy z typów takich wbudowanych jak integer i jak boolean.
Teraz tutaj da pierwsza sekcja.
To jest proszę Państwa komentarz i tutaj po prostu piszemy, opisujemy w języku naturalnym.
A więc specyfikacja definicji koord,
reprezentujący współrzędne kartezjańskie operacje,
reprezentujący współrzędne kartezjańskie operacje,
insulation oby кино.
dla tego koord to są operacje X i Y, które obliczają atrybuty odpowiednio X i Y
oraz operacja EQ, która porównuje dwa obiekty typu koord.
Teraz tutaj mamy część sygnaturową, czyli musimy mieć po pierwsze jakąś operację,
która tworzy ten obiekt, czyli mamy zwykle operację, zwykle nazywamy to create,
ma dwa parametry X i Y i powstaje rezultat, czyli ta zwracany typ, to jest obiekt typu koord.
Teraz mamy operacje X i Y, które działają na takim obiekcie koord i zwracają liczbę typu integer,
czyli odpowiednią współrzędną X-ową czy Y-ową.
I czwarta operacja to jest operacja porównania EQ.
W parametrach są dwa obiekty typu koord, a zwracanym typem jest typ bólowski,
czyli zwracamy informację, że te obiekty są równe lub nie.
Czyli to są sygnatury poszczególnych operacji.
I teraz najtrudniejsza do przygotowania część aksjomatyczna.
Czyli tutaj podajemy...
No, pewne relacje pomiędzy tymi operacjami i poprzez te relacje definiujemy te operacje, które są tutaj.
A więc tu na przykład pokazujemy, za pomocą tego aksjomatu, że jeżeli operacją X podziałamy na...
Widzimy, że tu operacja X to ma być obiekt typu koord.
A ten obiekt koord będzie stworzony przez operację create z parametrami X, Y.
To zostanie zwrócona wartość X, czyli tego parametru, który tu był podany.
Czyli pokazujemy tutaj relacje pomiędzy operacją X i operacją create.
Podobnie pomiędzy operacją Y i operacją create.
I definiujemy operację EQ.
Działamy na dwóch obiektach typu koord.
Pierwszy powstały z parametrów X1, Y1.
Drugi, parametry X2, Y2.
I co ma być zwrócane?
Obiekty współrzędne kartezjańskie są sobie równe, jeżeli ich współrzędne są sobie równe.
Czyli X1 musi być równe X2 i Y1 musi być równe Y2.
Czyli za pomocą tej części aksjomatycznej, żeśmy zdefiniowali te wcześniej utworzone, zaproponowane operacje.
Teraz takie krótkie wskazówki do tego, jak się tworzy takie specyfikacje algebraiczne.
Czyli pierwsza rzecz, musimy sobie pewną strukturę tutaj przygotować.
Dlatego, że my będziemy pewnie korzystać z jakichś typów abstrakcyjnych.
Więc musimy tak cegiełka po cegiełce te specyfikacje budować.
Trzeba je jakoś nazwać, określić, może będą miały jakieś parametry takie, które będą generyczne.
Musimy dla każdego z tych naszych...
obiektów specyfikowanych wybrać operacje.
Potrzebne są zawsze takie operacje, jak utworzenie tego czegoś.
Tutaj widzieliście Państwo, była operacja create.
Jak operacje inspekcji, czyli tutaj u mnie były te operacje X i Y.
No jakimś nieformalnym tekstem opisujemy te operacje.
No i definiujemy składnie parametry.
Najtrudniejsza część jest ta definicja tych aktyw.
Aksjomatów.
Poprzez określenie, definiujemy te operacje poprzez określenie warunków, które są zawsze spełnione dla różnych kombinacji tych operacji.
I tutaj widzieliście Państwo, prawda, były kombinacje X create, Y create i operacja EQ.
Ważne jest również, bo często takich aksjomatów, czyli czegoś co jest zawsze prawdziwe, można podać bardzo wiele.
Ważne jest, żeby tu w tej części aksjomatów,
Ważne jest, żeby tu w tej części aksjomatów,
Ważne jest, żeby tu w tej części aksjomatów,
Podawać minimalną liczbę takich aksjomatów.
Podawać minimalną liczbę takich aksjomatów.
Minimalną, która wystarcza do zdefiniowania tych operacji.
A żeby tego nie było, tutaj są podane trzy, no a pewnie moglibyśmy tutaj jeszcze w jakichś bardziej złożonych specyfikacjach znacznie więcej tego wymyśleć.
Więc chodzi o to, żeby podać jak najmniejszą liczbę tych zawsze prawdziwych relacji.
No i teraz popatrzmy na coś tutaj takiego bardziej zaawansowanego, mianowicie mamy tutaj specyfikację listy.
My korzystamy z typu takiego podstawowego integer i mamy opis, a więc ta specyfikacja lista.
Elementy będą do tej listy dodawane na końcu, a usuwane z początku.
Operacja create tworzy pustą listę, operacja const dodaje element do listy, no będzie dodawała na końcu, prawda, bo taka jest tu idea.
Operacja lent podaje liczbę elementów listy.
Operacja head podaje początkowy element z listy, a operacja tail usuwa pierwszy element z listy.
Część akcjomatyczna, czyli operacja create tworzy pustą listę.
Operacja const do listy dodaje element, a więc tworzy nam nową listę.
Operacja head, tak jak było tutaj napisane, tak, działamy na liście i mamy dostać element,
no i mamy też element od tej listy, no początkowy jakoś potem musimy określić, że ma być początkowy.
I operacja tail usuwa pierwszy element z tej listy, czyli jak gdyby zwraca ogon tej listy po zdjęciu pierwszego elementu, czyli działamy na liście, dostajemy listę.
No i teraz, proszę Państwa, najtrudniejsze jest określenie tych akcjomatów, które będą te operacje definiowały.
Tak jak mówiłam wcześniej na początku, to jest to, że w pewnym momencie, kiedy mamy tutaj dokument, który jest wykazany.
To jest, że w którymś miejscu nie mamy aku.
Tak jak Państwu przed chwilą mówiłam, pokazuje się tutaj relacje pomiędzy różnymi operacjami, taką liczbę tych aksjomatów, żeby wystarczało na zdefiniowanie tych operacji na precyzyjne ich określenie.
W ogólnym przypadku można by tu relacje pomiędzy wszystkimi parami podawać, ale nie zawsze aż tyle jest potrzebne.
Czyli tutaj na przykład operację HEAD, jak działamy na liście, którą tworzy operacja CREATE, to mamy tutaj przypadek, nie jest to zdefiniowane, dlatego że CREATE daje pustą listę, a HEAD ma zwracać początkowy element, czyli nie mamy tego elementu, a więc jest to sytuacja wyjątkowa.
Jeżeli natomiast…
Jeśli operacją HEAD podziałamy na liście, która była utworzona w ten sposób, że do listy L został dodany element V, no to teraz, jeżeli ta lista L jest to wynik CREATE, czyli jest to pusta lista, to powinniśmy dostać V, a w przeciwnym przypadku powinniśmy dostać głowę, ten pierwszy element z listy L.
Teraz, operacja LEND podziałana na wyniku operacji CREATE, CREATE daje pustą listę, no wobec tego długość tej listy jest równa 0.
Natomiast, jeżeli operacją LEND podziałamy na liście, która była tworzona w ten sposób, że do listy L został dodany jeden element, to powinniśmy dostać długość listy L, która była tutaj,
zwiększone o 1.
Teraz, jeżeli weźmiemy ogon z pustej listy, czyli no to nic nie mamy, mamy pustą listę, natomiast to jest dosyć trudny do wymyślenia aksjomat, ale jednocześnie nam on tutaj bardzo dużo daje, proszę popatrzeć.
Jeżeli operacją TAIL podziałamy na listę, która jest wynikiem, że do listy L…
Został dodany element V.
To.
Jeżeli to L było puste, to L było puste, no to mamy puste, prawda, bo z pustej listy zdejmujemy, usuwamy pierwszy element, więc dostajemy, tu został dodany, a tu go zdejmujemy, dostajemy puste.
W przeciwnym przypadku, jeśli ta lista nie była pusta, to proszę popatrzeć, co tutaj zrobiono.
Zamieniono miejscami operację CONS i TAIL.
Czyli biorę…
Teraz tutaj usuwam pierwszy element z listy L, tak, i do niej dodaję operacją CONS ten element V.
I ten aksjomat jest dosyć trudny do zrozumienia i trudny do wymyślania, więc w takich trudnych przypadkach zwykle sprawdzamy to, czy patrzymy, czy to działa na jakimś prostym przykładzie.
Czyli na przykład spróbujmy.
Działamy operacją TAIL na liście, która zawiera trzy elementy, trzy, cztery, pięć, tak, to jest ta nasza lista.
To, tą listę zawierającą te trzy, cztery, pięć możemy utworzyć w ten sposób, że do listy, która zawiera trzy i cztery dodajemy piątkę, prawda, i dalej idziemy.
Znowu, a jak to i teraz.
Zamieniamy miejscami tą operację, tak jak było w tym aksjomacie, ten CONS z TAIL-em.
Zamieniamy miejscami, argumenty zostają tak, jak były.
No i teraz znowu tutaj mamy TAIL, tak, do listy zawierającej trzy, cztery.
To jak taka lista powstaje?
Powstaje tak, że do listy, która zawiera trójkę, dodajemy czwórkę.
Pozostałe argumenty zostają bez zmian.
Znowu zamieniamy te dwie operacje miejscami i mamy taki wynik, tak.
Teraz, a jak powstaje taka lista?
Która zawiera trójkę.
No w ten sposób, że do pustej listy dodajemy trójkę, tak.
Zamieniamy miejscami te dwie operacje.
Lista, przepraszam, lista jest pusta tutaj, więc mamy CREATE.
I teraz już tutaj do pustej listy dodajemy czwórkę, tak.
Nam się to zamyka i dodajemy tą piątkę.
I widzimy, że mamy listę, która zawiera cztery i pięć.
Czyli rzeczywiście to działa, prawda?
Operacją TAIL podziałaliśmy na liście, która zawiera trzy, cztery, pięć.
Wynik jest, dostajemy listę, która zawiera cztery i pięć.
Czyli no działa ten, działa ten aksjomat.
Natomiast no jego postać, jak tutaj Państwo widzicie, wcale nie była taka prosta.
Stąd warto sobie takie, w takim przypadku,
takie proste przykładziki robić, żeby sprawdzić, czy to rzeczywiście działa, czy nie.
Czy może mają Państwo do tego jakieś pytania, uwagi?
Dobra, proszę Państwa, druga grupa takich specyfikacji formalnych,
to są specyfikacje, które bazują na modelu.
Model based specification.
To się nazywa.
I tutaj korzystamy z takich pojęć jak zbiory, jak funkcje.
I no modelujemy ten system właśnie za pomocą różnego rodzaju zbiorów, funkcji, różnych własnościach.
Tutaj, jeśli chodzi o techniki sekwencyjne, to mamy dwie takie najbardziej znane.
Vienna Definition Method.
To jest, proszę Państwa, coś co zostało zaproponowane przez Jonesa, tak jak Państwo widzicie, w roku osiemdziesiątym.
I jest to notacja, no w skrócie zwana notacją wiedeńską, która została zaproponowana po to,
aby opisać semantykę, czyli znaczenie języka programowania, a konkretnie języka programowania Pascal,
który w owym czasie, w tym czasie, w tym czasie, w tym czasie, w tym czasie, w tym czasie, w tym czasie.
No zaczął być bardzo popularny i były, o ile składnia, no to była precyzyjnie określona za pomocą notacji BNF.
Ale znaczenie tych konstrukcji, prawda, nie było precyzyjnie opisane i stąd zdarzało się, że różne kompilatory sobie różne założenia robiły
i można było podać przykład takiego programu, który daje różne wyniki, w zależności od tego, jakim kompilatorom,
jaki kompilator był użyty.
No więc była to rzecz niedopuszczalna, prawda, żeby ten sam program dawał różne wyniki, więc zaczęto szukać właśnie metod opisu znaczenia poszczególnych konstrukcji
i tu została zaproponowana ta metoda wiedeńska.
No problem polegał na tym, że o ile książeczka do Pascala, to była taka chuda książeczka, Niklas Wirtio napisał, która zawierała, nie wiem, tam tłumaczenie,
tłumaczenie na język polski 120 stron góra, no to opis semantyki, znaczenia tego języka Pascal w tej notacji wiedeńskiej,
to była gruba taka książka, kilkaset stron, licząca małym drukiem.
Teraz inne podejście, to są tak zwane Z-schema, które zostały zaproponowane w roku 80 przez Abriela do opisu takich,
znowu, abstrakcyjnych typów danych, ale to się, proszę Państwa, rozwijało i właśnie dla tej notacji Z mamy coś, o czym Państwu już kiedyś mówiłam,
że jest możliwość automatycznej transformacji w kod. Początkowo ta transformacja dotyczyła, była transformacja w kod w języku C, potem w C++,
tak, a obecnie mamy również,
mamy również kod w jawie i jak gdyby pewien podtyp tej notacji Z, to są tak zwane B-schema, czyli B-schematy.
Ja tutaj Państwu pokażę jakiś bardzo prosty przykład takiej notacji za pomocą Z-schematów.
Sama notacja jest dosyć złożona, trudna, no tak właściwie, żeby ją nauczyć, to trzeba by było kursy,
taki no trzydziestogodzinny, powiedzmy taki semestralny przedmiot utworzyć, żeby jej, nauczyć się posługiwania tą notacją,
ale pewne zasady są proste, więc postaram się je Państwu tutaj pokazać.
Dlaczego właśnie te Z-schema są istotne? Dlatego, że właśnie mamy tutaj programy, które po pierwsze mogą nam wygenerować ten kod w języku C,
jak i również są programy, które sprawdzają czy ta no, czy te schematy są niesprzeczne.
Tutaj to co Państwu mówiłam wcześniej o tej specyfikacji algebraicznej, to dla tej specyfikacji też są takie narzędzia,
że też jest możliwe takie są sprawdzenie czy nie ma sprzeczności, jest możliwość udowadniania pewnych rzeczy.
Więc do tego celu są narzędzia. Nawet z takiego narzędzia korzysta się na Uniwersytecie Warszawskim, na Wydziale Informatyki. Już na pierwszym roku oni korzystają z tego.
Dobra, teraz wróćmy do tych Z schematów. No właśnie, zaletą jest możliwość generacji kodu w języku źródłowym, w języku programowania.
Mamy tutaj, ta specyfikacja to będzie pewien zbiór takich schematów, więc musimy te schematy nazwać i też będą tutaj, te schematy są traktowane też jako takie cegiełki,
w których możemy z nich budować specyfikację czegoś bardziej złożonego. I właśnie taki przykład będę chciała Państwu tutaj pokazać.
Czyli tak, po pierwsze też taki Z schemat składa się z kilku części. Pierwsza część to jest nazwa tego schematu. W drugiej części mamy sygnatury, mamy albo pewne zmienne schematu,
tak jak tutaj podam.
Albo pewne operacje, które można na tym schemacie robić. I część trzecia to są predykaty, które określają też pewne zależności pomiędzy czy zmiennymi schematu, czy pewnymi operacjami schematu.
Dobra, tworzymy coś, co się nazywa pojemnik. Zmienne tego schematu mamy dwie. Mamy zawartość tego pojemnika i pojemność, tak?
Czyli ile maksymalnie mogę włożyć do tego pojemnika, powiedzmy za pomocą liczb naturalnych jakaś wielkość określona, a jaka jest jego wielkość wypełnienia aktualna.
I predykat, który mówi, czyli coś, co ma być zawsze spełnione, że zawartość tego schematu musi być mniejsza, równa od jego pojemności.
No i to jest jak gdyby nasz punkt startowy.
Tak jak już Państwu wspomniałam, z tych schematów, te schematy traktujemy jako takie cegiełki i będziemy z nich budować specyfikacje czegoś bardziej złożonego.
Będziemy je składać.
Tutaj w przypadku tych z schematów są również pewne operacje wejścia i wyjścia, tylko absolutnie bez żadnego formatowania.
A więc ja mogę na pewno zmienną.
Na przykład zmienną schematu mogę wprowadzić z wejścia, tutaj akurat wprowadzam jakąś liczbę całkowitą, mogę pewną zmienną schematu wyprowadzić też w postaci tutaj liczby naturalnej.
Teraz niektóre z tych schematów mają, czy my określamy, że mają pewne określone własności.
I w szczególności na przykład mogę.
Schemat poprzedzić liczbą grecką delta, bo tutaj właśnie te liczby greckie są do tego, przepraszam, litery greckie są do tego stosowane.
I jeżeli taki schemat poprzedzę literą delta, to to oznacza, że co najmniej jedna, ale może więcej zmiennych stanów zostanie zmienionych.
Czyli, że w tym schemacie coś się zmieni poprzez wykonanie pewnych operacji.
Można także jak gdyby określić poprzez taki znaczek prim, tak, po zmiennej jak taki znaczek napiszę, to znaczy, że to jest nowa zmieniona wartość tej zmiennej.
Czyli mamy schematy delta, które mówią, coś się będzie zmieniać w tym schemacie.
Mamy schematy typu XI.
Tutaj widzicie Państwo literkę grecką XI.
I schematy typu XI oznaczają, że nic wewnątrz tego schematu się nie zmieni przez operację.
Czyli ta nowa wartość zmiennej będzie dokładnie taka, zmiennej schematu będzie taka, jak była.
Teraz tutaj, proszę Państwa, w Z-schematach mamy bardzo duży zbiór równowagi.
Różnego typu funkcji.
Mogą być funkcje częściowe.
Są specjalne operatory, za pomocą których możemy działać na dziedzinie funkcji, na wyniku funkcji.
Można korzystać z sekwencji.
Można korzystać ze zbiorów.
Można korzystać również z takich zbiorów, które się nazywa BEC.
Czyli takich, że jak gdyby jeden element może się w nich pojawiać wiele razy.
Także mamy tutaj bardzo, bardzo rozbudowane listę dostępnych funkcji operatorów.
Operatorów na dziedzinach tych funkcji.
Relacje również można tutaj określać.
Sekwencje.
I popatrzmy teraz na nasz taki prosty przykład, który dalej będę chciała pokazać.
Mam kolejny schemat.
Czyli zdefiniowałam pojemnik.
A teraz definiuję...
Kolejny schemat, który nazywam wskaźnikiem.
I ten wskaźnik ma zmienne stanu takie jak...
Lampka, która może być ON lub OFF.
Odczyt.
To jest jakaś liczba naturalna.
Zmienna stanu, niebezpieczny poziom.
Też jest jakaś liczba naturalna.
I ta lampka będzie miała wartość ON.
Zapali się.
Wtedy i tylko wtedy.
Jeżeli ten odczyt.
Czyli to co odczytamy.
Będzie mniejszy lub równy temu poziomowi niebezpiecznemu.
No i teraz, proszę Państwa, mamy takie dwie cegiełki.
Pojemnik i wskaźnik.
I składamy je w jeden schemat, który się u nas będzie nazywał zbiornik.
A więc tutaj teraz w tej części, gdzie były zmienne schematu.
Mówię z jakich schematów ten zbiornik składam.
Biorę pojemnik i biorę wskaźnik.
One miały swoje zmienne stanu.
Żeby to złożyć w pewną całość.
No to właśnie to tymi predykatami pokazuje jak to może być złożone.
Czyli odczyt, który był we wskaźniku.
To jest zawartość pojemnika.
Zawartość była w pojemniku.
A więc to jest to samo.
Tak?
Ustawiam pojemność na pewną wartość.
Ustawiam niebezpieczny poziom na pewną wartość.
Dobra. Mam zdefiniowany zbiornik.
No, jak się możemy domyśleć, ze zbiornikiem coś bym chciała zrobić.
Czyli na przykład go napełnić.
No to definiuję sobie kolejny schemat, który realizuje tą operację napełniania.
Czyli tutaj każda rzecz, która się dzieje.
To jest, robię to za pomocą schematu, który tą operację opisuje.
Nazywam ten schemat napełnianie okej.
Czyli wtedy, kiedy da się ten zbiornik napełnić.
Proszę popatrzeć. Korzystam z definicji schematu zbiornik.
Ale poprzedziłam to deltą.
Co znaczy, że się coś w zmiennych stanu tego zbiornika nie zmieni.
Co znaczy, że się coś w zmiennych stanu tego zbiornika zmieni.
To jest, przypomnę, operacja wejściowa.
Czyli na ilość będę wczytywać coś z wejścia.
I teraz predykaty.
Czyli kiedy ten schemat ma działać.
Ten schemat ma działać wtedy, kiedy spełniony jest ten predykat.
A więc wtedy, kiedy zawartość tego zbiornika
zwiększona o tą ilość, którą podałem.
Która jest wejścia.
To jest mniej oprówna pojemność.
Czyli wtedy, kiedy ta ilość, którą chcę dołożyć do tego zbiornika
jeszcze się tam zmieści.
Natomiast teraz tutaj pokazuję nową zawartość tego zbiornika.
Że jest to zawartość, która była plus ilość.
I tutaj jest błąd.
Bo tutaj należy napisać.
Bo tutaj należy napisać.
Że ta ilość będzie wprowadzona z wejścia.
A więc zdefiniowałam operację napełniania.
No dobrze.
To zdefiniowałam wtedy, kiedy operacja napełniania.
Kiedy to napełnianie jest możliwe.
Wtedy, kiedy mi się to coś zmieści.
A co jeżeli się nie zmieści?
No jeżeli się nie zmieści.
To potrzebuję zdefiniować kolejny schemat.
Który się u mnie tutaj nazywa przepełnienie.
Też korzystam z definicji tego schematu zbiornik.
Ale tym razem go poprzedzam zmienną literą grecką xi.
Która mówi nic się nie zmieni w tym zbiorniku.
No ilość zmienna, która będzie wprowadzona z wejścia.
I tu mam pewną operację wyjściową.
Sec to jest sequence of character.
Czyli pewna sekwencja znaków.
Tak to wyprowadzana będzie pewna sekwencja znaków.
No i predykat.
Kiedy to ma działać?
A więc wtedy, kiedy pojemność.
Wtedy pojemność.
Wtedy pojemność.
Tego zbiornika.
Jest mniejsza od zawartości, która w nim jest.
Zwiększonej o tą ilość, którą chce wprowadzić z wejściem.
Czyli wtedy, kiedy się to coś co chce dodać do tego zbiornika po prostu nie mieści.
Czyli to jest predykat, który mówi kiedy ten schemat ma zadziałać.
I wyprowadzana.
Wartość.
No niewystarczająca pojemność tego zbiornika.
Napełnianie jest skasowane.
Miałam operację przepełnienie.
Miałam operację napełnianie ok.
Więc mogę teraz te dwie schematy złożyć.
I mam zdefiniowaną operację napełniania.
Więc jak widzicie Państwo.
Tak to mniej więcej wygląda.
Tak wygląda taki prosty przykład.
Budowania tej specyfikacji za pomocą z schematów.
Że po prostu składam.
Zaczynam od definicji czegoś prostego.
I składam te schematy.
I opisuję również, definiuję za pomocą schematów.
Definiuję również operację działania na czymś.
Przy czym zawsze definiuję taką operację, która może być wykonana.
I również takie sytuacje, kiedy się nie da czegoś zrobić.
Bo pewne relacje są niespełnione.
No i tak krok po kroczku to buduje tą specyfikację.
Tutaj widzieliście Państwo te operacje.
Wejścia, wyjścia były.
Ale to jest takie nieformatowane.
Więc tak jak już kiedyś Państwu mówiłam przy okazji.
Jak omawiałam Państwu formalne transformacje.
Jako jedna z metod produkcji oprogramowania.
Czy modeli procesu produkcji oprogramowania.
To mówiłam Państwu, że na przykład za pomocą takich formalnych specyfikacji.
Nie da się zdefiniować interfejsu użytkownika.
No i myślę, że to Państwo żeście w tej chwili zobaczyli, że się faktycznie nie da.
Natomiast da się w ten sposób wyspecyfikować.
Tą część taką odpowiedzialną za działanie systemu.
Za logikę systemu.
I można tutaj również też do tych z schematów.
Po pierwsze można wygenerować kod.
Taki kod automatycznie generowany.
No nie zawsze jest kodem no nazwijmy to efektywnym.
Ale, czyli mogę mieć kod taki automatycznie wygenerowany.
Tak.
Tak.
I mogę mieć kod taki, który napisał programista.
Napisał ręcznie.
I proszę Państwa można porównać.
Jeżeli nie chcemy tego kodu automatycznie wygenerowanego stosować.
Bo na przykład no boimy się, że on będzie mało efektywny.
To są narzędzia, które porównują.
Czy zachowanie tego kodu ręcznie napisanego.
I tego drugiego jest takie samo.
Czyli można w ten sposób.
Jak gdyby w tym kodzie programisty.
Wykryć jakieś błędy.
Jakieś braki.
O których on coś zapomniał.
Albo coś źle zrobił.
Bo to zachowanie będzie inne.
Również można tutaj widzieliście Państwo.
Mamy te predykaty w tych schematach.
Więc też są takie programy.
Które pozwalają nam udowadniać.
Czy wyszukiwać.
Czy nie ma sprzeczności pomiędzy tymi predykatami.
Które w poszczególnych schematach się będą pojawiały.
I jeżeli takie sprzeczności są.
No to one też zostaną wskazane.
Ja tutaj wspomniałam o tej nieefektywności.
Tego kodu automatycznie generowanego.
I powiedzmy, że to.
Kiedyś był problem.
W tej chwili już nie jest to tak dużym problemem.
Ze względu na szybkie procesory.
Ja już chyba kiedyś Państwu o tym mówiłam.
Że w Paryżu jedna z linii metra.
Oprogramowanie dla tej linii metra.
Zostało napisane właśnie w tych B schematach.
Które są pewnym typem tych Z schematów.
I kod automatycznie wygenerowany.
Został wygenerowany do Jawy.
I ten kod automatycznie wygenerowany.
Steruje ruchem pociągów na tej linii.
I jest to linia, która jeździ bez pana kierowcy.
I no nie słyszymy, żeby się tam coś złego działo.
Także proszę Państwa.
No w tej chwili te specyfikacje formalne.
Są coraz częściej w przemyśle i w zastosowaniach.
Stosowane.
Nie do całości systemu.
Ale do tej części systemu.
Która jest odpowiedzialna za niezawodność.
Za bezpieczeństwo.
Za właściwą pracę.
Szczególnie te części takie sterujące, kontrolujące.
To stosuje się te formalne specyfikacje.
I generuje się kod.
I albo się korzysta bezpośrednio z tego kodu.
Albo się porównuje.
Czy ten kod nie jest zbieżny z kodem.
Pisanym przez programistów.
Teraz no widzieliście Państwo.
Że przygotowanie takiej specyfikacji.
Wcale nie jest prostą sprawą.
Ja Państwu pokazałam.
Jakieś bardzo proste rzeczy.
No i wcale najprostsze jakie się dało.
Ale teraz prawda.
No nie będę od Państwa wymagała.
Na egzaminie przygotowania specyfikacji formalnej.
Bo wiadomo, że byłby z tym problem.
I proszę Państwa.
No musimy sobie zdawać sprawę z tego.
Że przy tych specyfikacjach formalnych.
To wymaga trochę innego myślenia.
Z naszej strony.
Prawda?
To trzeba tutaj myśleć.
I pewne rzeczy konstruować.
Poprzez funkcje, relacje, zbiory.
Nie każdy z nas potrafi takie rzeczy robić.
A w ogóle żeby to robić.
No to trzeba.
Sporo się nauczyć.
Sporo się szkolić.
Więc no nie jest to prosta sprawa.
Też chyba już wspominałam Państwu.
Że.
No jeżeli mamy formalne specyfikacje.
To one są właśnie bardzo precyzyjne.
Prawda?
Bo wiele rzeczy da się udowodnić.
Sprawdzić, wykazać.
Na przykład wykazać.
Że są sprzeczności w jakichś definicjach.
Więc.
Są również przykłady firm.
Które przygotowują formalne specyfikacje.
Ale potem.
Ten kod.
Nawet nie jest generowany automatycznie.
Tylko na podstawie tego.
Formalnych specyfikacji.
Kod jest pisany przez programistów.
Ręcznie jest pisany.
Ale.
Ponieważ te specyfikacje są dokładne.
To ten kod pisany przez programistów.
Też ma znacznie.
No.
Jest bardziej niezawodny.
Niż w czasach.
Kiedy te firmy.
Nie stosowały formalnej specyfikacji.
Więc.
No.
No.
Jest to oprogramowanie.
Jest po prostu bardziej niezawodne.
Jest lepsze.
No i.
Jak gdyby.
Z tego sobie też trzeba zdawać sprawę.
Że coraz więcej to wchodzi.
Do właśnie.
Do przemysłu.
Do konkretnych zastosowań.
Tam gdzie sprawa bezpieczeństwa.
Niezawodności.
Poprawnego działania systemu.
Jest sprawą bardzo istotną.
W przypadku.
Safety critical systems.
To tam się trzeba liczyć z tym.
Że te specyfikacje formalne.
Będą coraz szerzej używane.
Czy może.
Mają Państwo.
---------------------------------------------Dziękuję.
Dziękuję.
Dziękuję.
Dziękuję.
Dziękuję.
Dziękuję.
Dziękuję.
Dziękuję.
Dziękuję.
Dziękuję.
I ponieważ tutaj, prawda, pracujemy na różnych poziomach abstrakcji, korzystamy z pewnych pojęć abstrakcyjnych, no więc warto jest, abyśmy je opisali, żeby nie było problemu z ich zrozumieniem.
Proszę Państwa, no zaczynamy od tej specyfikacji wymagań, o której dzisiaj na poprzedniej godzinie mówiłam, prawda.
Czyli wyobraźmy sobie, że mamy ten dokument, który specyfikuje wymagania.
I teraz, proszę Państwa, tutaj taki pierwszy etap to jest przygotowanie projektu architektury tego systemu.
Czyli co to jest architektura tego systemu? No to też troszkę dzisiaj będę o tym dalej mówić, ale to jest jak gdyby określenie pewnej struktury tego systemu.
To jest również określenie, z jakich części on się będzie składał, jakie będą relacje pomiędzy tymi częściami, czy jakie będą zależności.
A więc na podstawie tej specyfikacji wymagań, ta pierwsza czynność, którą tutaj mamy, to jest projektowanie architektury systemu.
I tutaj powstaje produkt, właśnie ta architektura systemu.
Jak będę Państwu pewnie już naniosła.
Może na następnym wykładzie opowiadać o UML-u, no to zobaczycie Państwo, może nie na następnym wykładzie, ale jeszcze na kolejnym, jak można tą architekturę systemu właśnie w UML-u opisać.
Teraz, tutaj mamy architekturę tego systemu, czyli mamy jego części.
A więc na przykład czasem jest tak, że te wymagania, które system ma realizować, przydzielamy do poszczególnych części tego systemu, czy modułów.
Więc tutaj mamy właśnie tą, jak gdyby drugi produkt, który w tym kroku drugim powstaje, to mamy specyfikację oprogramowania.
A więc właśnie jak gdyby przywiązanie pewnej, związanie z poszczególnymi częściami tego systemu, no pewnej roli, jaką one mają spełniać,
czy określenie, a które z funkcji, z tych wymagań tego systemu,
ta konkretna część systemu ma realizować.
I można powiedzieć, że mamy tutaj coś, co możemy nazwać specyfikacją oprogramowania.
Teraz, ponieważ mamy tutaj pewne moduły części, z których ten system się składa,
tu wiemy za co poszczególna część jest odpowiedzialna, czyli na przykład za realizację których wymagań, który pod system jest odpowiedzialny.
No musimy zaprojektować, jak one się będą ze sobą komunikowały.
Czyli ta tutaj czynność, oznaczona trójką, to jest, proszę Państwa, projektowanie interfejsów.
Musimy zaprojektować interfejsy tych poszczególnych części tej architektury, tego naszego systemu i to musimy opisać.
A więc mamy dokument, który specyfikuje te interfejsy.
Teraz kolejny krok i tutaj, jak gdyby od tego momentu mniej więcej, to już możemy te czynności tutaj robić, no troszkę zrównoleglać,
czyli robić równolegle dla poszczególnych części tego systemu.
Dlatego, że tak, tutaj wiemy, jak te systemy się mają ze sobą komunikować.
Wiemy, za co one mogą być odpowiedzialne.
No więc teraz już możemy, jak mamy tam, powiedzmy, te trzy części, na przykład zdefiniowane, powiedzmy ABC, tak, nazwijmy sobie to, żeby mieć jakieś nazwy, jakieś podsystemy,
to teraz możemy już te czynności robić równolegle dla tych podsystemów, czyli dokładnie je wyspecyfikować, wiedząc, za co one są odpowiedzialne, co one mają robić.
Możemy tutaj już też zrobić projekt i specyfikacje danych, na których to mają pracować.
Możemy poszukać efektywnych realizacji, algorytmów realizacji poszczególnych tych usług, za które ten komponent jest odpowiedzialny.
I to już może być zrównoleglone dla poszczególnych części tej architektury systemu.
Teraz, proszę Państwa, metody projektowania.
No, tutaj trzeba sobie zdawać sprawę z tego, że słowo metoda w inżynierii oprogramowania ma troszkę inne znaczenie niż, no, na przykład w matematyce czy fizyce.
W matematyce, jeżeli mam metodę projektowania, to ja mam metodę projektowania.
No, tutaj trzeba sobie zdawać sprawę z tego, że słowo metoda w inżynierii oprogramowania ma troszkę inne znaczenie niż, no, na przykład w matematyce czy fizyce.
W metodzie rozwiązywania takiego, a takiego typu zadań, to mam pewien zbiór założeń, które mają być spełnione i mam pewien algorytm postępowania.
I jeżeli założenia są spełnione, jeżeli stosuje się do tego algorytmu, to dostaję rozwiązanie tego typu zadania.
W inżynierii oprogramowania metody to jest zbiór pewnych rad, wskazówek, podpowiedzi.
To, co z metodą często są związane również z rozwiązaniami.
Są związane również pewne notacje, które pozwalają nam ten model przedstawić.
Ale nie ma gwarancji. To, czy powstanie projekt dobry, czy projekt kiepski, no to to zależy od ludzi, którzy właśnie tych notacji używają, którzy tę radę stosują lub nie, prawda?
Więc czy to będzie dobry, sensowny projekt czy nie, no to to zależy od nich.
Dziękuję.
Natomiast mimo wszystko używa się tego określenia metody projektowania w inżynierii oprogramowania.
Teraz, proszę Państwa, mamy takie dwie grupy metod projektowania.
Pierwsze historycznie podejście to było podejście funkcjonalne, inaczej strukturalne.
Gdzie tutaj przy tym podejściu?
Ten system, który chcemy zrealizować widzimy jako pewne transformacje danych, które mają być zrobione.
Zaczynamy od takiego wysokiego poziomu i tak hierarchicznie schodzimy, coraz to bardziej szczegółowy projekt.
Znowu w zależności od czasu i układu.
Być może ja pokażę na jednym z wykładów przez chwileczkę jak takie, dzisiaj troszkę opowiem o tym, ale być może do tego tematu jeszcze wrócę pod koniec semestru, jeżeli mi zostanie trochę czasu.
I to były jak gdyby pierwsze podejście historycznie.
Wtedy były języki strukturalne, a więc język C, FORTRAN, PL1, które były stosowane w programowaniu.
I właśnie to podejście funkcjonalne.
Właśnie to podejście strukturalne, funkcjonalne.
Potem się pojawiło podejście obiektowe, w drugiej połowie lat siedemdziesiątych, gdzie aktualnie praktycznie większość systemów jest w ten sposób realizowana.
Gdzie pojawiły się języki obiektowe, pojawił się język C++ i potem inne, Java.
Gdzie system widziany jest jako zbiór obiektów.
I to co ten system robi wynika z pewnej współpracy, z komunikacji pomiędzy tymi właśnie obiektami.
I tym się głównie będziemy zajmować tutaj, na tym właśnie przedmiocie.
Teraz proszę Państwa, no wspominałam o tym, o tym, o tym, o tym, o tym, o tym, o tym, o tym, o tym, o tym, o tym, o tym, o tym, o tym, o tym, o tym, o tym, o tym, o tym, o tym, o tym.
Wspominałam o tym, że metody projektowania, ale czy powstanie coś sensownego, dobrego, czy nie, no to to zależy od ludzi, którzy tą metodę projektowania stosują.
Zarówno może być dobry projekt obiektowy, jak i dobry projekt strukturalny.
Natomiast, no znowu, tak jak na pierwszym wykładzie mówiłam Państwu, że
nie ma takiej obiektywnej metody stwierdzającej, co to jest oprogramowanie wysokiej jakości.
To podobnie, jeśli chodzi o jakość projektu, prawda?
Natomiast, no jednak, co na pewno powinien spełniać dobry projekt?
No, przede wszystkim powinien spełniać specyfikację, prawda?
Czyli powinien umożliwiać rachunek.
Powinien umożliwiać realizację tych funkcji, które mamy zapisane w specyfikacji.
Teraz, po drugie, taki dobry projekt, no to ten kod, który z niego powstanie, powinien być kodem efektywnym.
No i być może również jakieś inne pożądane własności powinien mieć, no na przykład takie, że się powinien dawać łatwo pielęgnować.
Co to znaczy łatwo pielęgnować?
To znaczy, że da się w nim łatwo poprawić błędy, które zostały wykryte w trakcie użytkowania.
I na pewno takie błędy będą wykryte.
A po drugie, być może prowadzić jakieś modyfikacje, czy dodać jakieś nowe możliwości.
No dobra, no to kiedy się projekt daje łatwo pielęgnować?
No, projekty są bardzo trudne.
No, to kiedy się projekt daje łatwo pielęgnować?
No, projekty są bardzo trudne.
Ale są też spójne, projekty, w których jest mało powiązań, mało zależności, jest łatwiej poprawić.
No i tak zwana łatwa adaptowalność, o tym za chwileczkę jeszcze będę mówić, na czym to polega.
Proszę Państwa, spójność jest bardzo szerokim pojęciem.
Po angielsku to jest cohesion.
I mamy różne typy spójności, różne poziomy spójności.
Ja tutaj Państwu cytuję takie poziomy spójności.
spójności zaproponowane przez
panów Konstantina i Jordona
pod koniec lat
siedemdziesiątych.
No po prostu po to, żebyśmy
sobie z różnych typów
tej spójności zdawali sprawę.
A więc
mamy taki najniższy
poziom spójności.
To jest poziom
przypadkowy.
O co chodzi jeszcze w tej spójności?
Chodzi o to, że na przykład mam kilka
elementów tego systemu
i jakaś spójność pomiędzy nimi
powinna być zachowana lub nie.
No więc w tej spójności
przypadkowej to na przykład
to, co
ten system ma robić,
mamy ten zbiór wymagań.
Ja na jednym z poprzednich
slajdów mówiłam Państwu, że dzielimy
te wymagania i przydzielamy,
że poszczególne komponenty
mają na przykład te wymagania realizować.
No więc na przykład
możemy to zrobić w sposób przypadkowy.
Trudno będzie
potem taki projekt
jakoś sobie
odzwierciedlić,
a w którym to z modułów
trzeba jakieś zmiany wprowadzić,
jeżeli w taki sposób przypadkowy to zrobimy.
Może być spójność tak zwana
logiczna, czyli
elementy, które wykonują
podobne funkcje są
zgrupowane w jednej jednostce.
W jednej jednostce.
Czyli jest jak gdyby
pewna logika w tym, co one
w tych funkcjach, które robią.
Może być spójność
czasowa, czyli
elementy, które
są wykonywane w podobnym
czasie, w tym samym czasie
grupujemy w jednej jednostce.
Więc często mamy, proszę Państwa,
tworzymy takie moduły
w oprogramowaniu, które
nazwiemy sobie init,
czyli będą one
wykonane na początku.
I na przykład close,
które będą wykonywane przy
zamykaniu systemu, bo może
trzeba coś zapisać,
zabezpieczyć pewne dane.
Więc spójność czasowa.
Możemy stosować
spójność proceduralną,
czyli elementy
w pewnej jednostce tworzą
pewną sekwencję sterującą.
Spójność
komunikacyjna,
bardzo przydatna, bardzo
ważna, często stosowana,
elementy, które pracują
na tych samych danych wejściowych
lub produkują dane wyjściowe,
grupujemy w jednej jednostce.
A więc na przykład mamy taki moduł,
który zapewnia dostęp do bazy
danych.
Czy na przykład taki
moduł, który się komunikuje
z użytkownikiem.
Spójność sekwencyjna,
no to wtedy,
kiedy wyjście jak gdyby jednego
elementu jest jednocześnie
wejściem do elementu następnego.
I wreszcie
taki, spójność tak zwana
funkcyjna, czyli
każda część
jest konieczna do wykonania
tej funkcji jednostki.
Przypisaliśmy jednostce pewną
funkcję i wszystko,
co jest potrzebne do wykonania
tej funkcji, grupujemy
w tej jednostce.
Teraz, proszę Państwa,
popatrzmy na powiązania.
Wyobraźmy sobie, że mamy
cztery części systemu,
które ja oznaczyłam literkami
A, B, C i D.
I tutaj mam ten
element w środku,
którym na przykład
mogą być dane,
z których te systemy
korzystają.
No więc, proszę Państwa, w takim przypadku
mamy bardzo silne powiązania.
Czyli, jeżeli
ja zmienię coś w strukturze tych
danych, to
muszę zaglądać do każdego
z tych podsystemów,
bo może tam
trzeba będzie jakieś poprawki
wprowadzić.
Czyli, takie silne
powiązania, jest to
niekorzystna cecha projektu.
No to,
co zrobić, jeżeli mamy te dane
takie wspólne, na których
te części chcą pracować?
No, lepiej to zrobić inaczej.
Na przykład, włożyć te dane
w jakąś jednostkę
i dostęp do tej jednostki
poprzez
jakiś moduł
zapewnić i wtedy
będą wywoływane
pewne funkcje dostępu
do tych danych, a nie
bezpośrednio. Wtedy, jeżeli
coś zmienimy w strukturze tych danych,
to co najwyżej, może trzeba
będzie popatrzeć
i zrobić jakieś drobne zmiany
w tej jednostce pośredniczącej.
Czyli,
warto te informacje
zamykać w pewnej jednostce
i dostęp do tych informacji
poprzez odpowiednie operacje
udostępniać.
Teraz, wspominałam Państwu
o tej łatwej adoptowalności.
Kiedy
system będzie łatwo adoptowalny?
No, wtedy, kiedy będziemy
rozumieli,
co się dzieje
w tej jednostce, prawda? I tutaj Państwu
wspominałam, że jeżeli
jakieś przypadkowe
funkcje przydzielimy jednostce,
no to ciężko będzie zrozumieć,
jak to działa.
Więc,
właśnie dlatego, jakby
jakąś funkcję jej przydzielić
i za realizację
tej funkcji ta jednostka ma być
odpowiedzialna, wtedy będzie łatwiej nam to zrobić
i wtedy w niej umieścić wszystkie
elementy związane z dostarczaniem
tej części. Teraz,
dla łatwości rozumienia,
no, istotna jest
złożoność tej jednostki, czyli
jeżeli mamy bardzo dużo,
duże jednostki,
to trudno będzie zrozumieć
ich działanie, czyli jeżeli taka
jednostka będzie liczyła parę tysięcy
linii kodu.
Ale, proszę Państwa, dla
takiego łatwości
zrozumienia istotne są nazwy,
które my w programach
stosujemy. Czyli,
jeżeli ja na przykład
mam nazwy
i będę operowała na takich
nazwach P1 do
na przykład P19,
tak, mam jakieś
zmienne takie.
I nawet mam dokumentację,
w której będzie tabelka z tymi
zmiennymi podana, co
która oznacza, to łatwo będzie
mi pomylić się i
no, powiedzmy, powinnam poprawić
coś w
zmiennej, czy w wartościach domniemanych
zmiennej P8,
tak, a przesunął mi się tutaj
i poprawiłam w P7 i wychodzą
już jakieś dziwne rzeczy. No więc,
proszę Państwa, te nazwy też powinny być
takie, żeby nam się jednak jakoś
kojarzyły z tym czymś,
tak, czy z tym polem,
co tam jest przechowywane,
czy z tą operacją, za co
ona jest odpowiedzialna.
No właśnie, bo chodzi nam o to, aby projekt
był łatwo adoptowalny.
I żeby był łatwo
adoptowalny, to powinien być spójny
powinien mieć
mało zależności pomiędzy
elementami, no i
mimo wszystko potrzebuje jednak
jakiejś podpowiedzi, czyli
pewnej dokumentacji.
Teraz, proszę Państwa,
ja już dzisiaj troszeczkę
taki pokazałam Państwu jeden slajd,
na którym pojawiały się różne
modele techniczne
i sieci Petri, i maszyny,
stanowe, i jakieś
elementy UML-u.
No właśnie, bo proszę Państwa,
bardzo istotne jest, abyśmy
zanim zaczniemy
ten system implementować,
żebyśmy najpierw go
zamodelowali.
Bo to ułatwia
zrozumienie funkcjonowania,
to pomaga przygotować dobry
projekt. I w związku
z tym potrzebne nam są różne
modele.
Z różnych perspektyw.
A więc
przed chwileczką
mówiłam Państwu o tych
czynnościach procesu projektowania
i w szczególności
mówiłam Państwu, że
potrzebna jest,
prawda,
musimy zaprojektować
architekturę tego systemu.
No, więc
do takiej architektury systemu
potrzebujemy takich modeli
strukturalnych, czy modeli danych
również może nam się przydać.
Teraz,
no, potrzebujemy
takie modele, które pokazują
kontekst systemu, otoczenie.
I to zobaczycie Państwo,
będziemy mówić o
modelach
use case i
zobaczycie Państwo, że tam też
pewne elementy zewnętrzne
współpracujące,
działające na ten system,
też będziemy pokazywać.
No i, proszę Państwa, projektując
system,
my musimy również
zaprojektować zachowanie
tego systemu. Czyli są
też pewne modele
behawioralne, na których
projektujemy, na których
pokazujemy zachowanie
systemu.
W UML-u wszystkie te trzy typy
modeli można robić, więc
no, stąd to jest.
Wygodne bardzo
projektowanie.
Jeszcze
inne typy modeli, właśnie
o tych architektonicznych już
Państwu wspomniałam,
czyli pewna struktura, pewne
podsystemy,
ale, no,
również modele
przetwarzania, modele procesów.
W przypadku danych
na przykład
i baz danych,
modele związków NCI,
modele tak zwane kompozytowe.
W UML-u też możemy takie modele
tworzyć. Modele
klasyfikacyjne, czyli
na przykład takie, w których będziemy
mogli pokazać pewne cechy
wspólne, pewne cechy
specjalizowane, szczególne.
I
modele
zdarzeniowe,
które, no, pokazują reakcję
systemu na zdarzenia.
Teraz, proszę Państwa,
mówiłam Państwu dzisiaj
o takich dwóch grupach,
znaczy wspomniałam, że
są takie dwie grupy
metod
przy projektowaniu.
Projektowanie funkcjonalne,
inaczej strukturalne
i projektowanie
obiektowe, podejście obiektowe.
I będę chciała
troszkę to Państwu przybliżyć,
na podstawie
kompilatora, który
może być zarówno tak zrealizowany,
jedną lub drugą
metodą, a przy okazji
może Państwo się nieco dowiecie
o tym, jakie są funkcje kompilatora.
No właśnie, jakie są funkcje
kompilatora, za co on jest odpowiedzialny.
Mam program napisany
w jakimś języku źródłowym,
na przykład, powiedzmy
w języku C++,
tak,
i chcę mieć tutaj
kod wynikowy,
na przykład chcę mieć tutaj
kod taki, który będzie
kodem wykonywalnym,
tak, będę mogła go wykonać
na konkretnej maszynie.
Więc, proszę Państwa,
ujęcie strukturalne,
inaczej funkcjonalne,
idea polega na tym, że
dokonywane są
różne transformacje
danych. I w takim
systemie mamy pewne punkty,
w których te transformacje
danych są wykonywane.
Mamy również pewne
przepływy danych, czyli właśnie
ten program źródłowy,
tak, jest wejściem
do analizatora leksykalnego,
który inaczej nazywa się
skaner.
Skaner albo
lekser.
...
...
I który ten
ciąg znaków, jaką mamy
w programie źródłowym,
dzieli na takie kawałki,
na tak zwane atomy leksykalne,
inaczej zwane tokeny.
...
I teraz te atomy leksykalne,
tu je Państwo widzicie,
przechodzą do analizatora
składni, czyli do tak zwanego
parsera. Niektóre
elementy, niektóre
ciągi są
zapamiętywane w pewnych
strukturach wewnętrznych
kompilatora i taką ważną
strukturą danych
kompilatora jest tablica symboli,
do której wchodzą
wszystkie identyfikatory, wchodzą
słowa kluczowe, a dalej
do tych identyfikatorów będą
wchodziły również informacje
opisujące
te identyfikatory,
czy stałe, czyli to są tak zwane
symbole, identyfikatory
stałe.
Parcer mamy tutaj,
który właśnie
bierze atomy
leksykalne, któremu podrzuca
skaner i
teraz
zadaniem tego parsera jest
zbudowanie pewnej
struktury,
zazwyczaj są to struktury
zawiaste i
również
stwierdzenie, czy to jest
poprawne składniowo,
czyli właśnie, jeśli mu się
z tego programu źródłowego uda
zbudować takie drzewo,
no to znaczy, że to było
w porządku, że ta składnia jest
poprawna i wtedy być może
dalsze etapy
generacja kodu są możliwe.
Ale analizator składniowy
wykrywa różnego rodzaju błędy,
które tutaj mieliśmy w tym programie
źródłowym i informacje
o takich błędach będzie
na pewno wyprowadzał.
Żeby on mógł działać, potrzebuje nie tylko
tych tokenów, tych atomów
leksykalnych, ale również czasem
musi sięgać do
tablicy symboli o pewne
informacje o symbolach tam
zamieszczonych.
Jeżeli udało się to drzewo rozbioru
zbudować,
no to wtedy
można jeszcze na tym
etapie prowadzić kolejne etapy,
które tutaj już pominęłam,
ale w szczególności można wygenerować
ten kod wynikowy,
no na przykład w takiej postaci,
żeby na konkretnym komputerze
można było ten kod
wykonać.
To jest ujęcie kompilatora
w ujęciu strukturalnym,
czyli mamy pewne miejsce
przetwarzania danych, skaner, parser,
generator kodu,
mamy pewne przepływy danych,
tak jak Państwo widzicie,
to są specjalne metody,
które się stosuje, żeby pokazać
te przepływy danych.
Data flow diagrams pokazują nam takie
miejsca, gdzie są przetwarzane dane
i pokazują nam również przepływy
między nimi.
Teraz proszę Państwa
ujęcie obiektowe.
W ujęciu obiektowym
system składa się
z pewnej liczby obiektów.
Te obiekty być może
są ze sobą w pewnych
związkach.
Te obiekty się ze sobą komunikują,
żądają od siebie wykonania
pewnych operacji
i
to co powstaje,
czyli tutaj chodzi nam w kompilatorze
o kod wynikowy,
to będzie rezultat wykonania
pewnej sekwencji
takich operacji.
Czyli też mam program transformacje,
program źródłowy w kod wynikowy,
ale tutaj ta transformacja
jest robiona poprzez
pewną sekwencję
wywołań operacji
w poszczególnych obiektach.
No i tutaj
takie obiekty zaproponowane
to są na przykład
strumień atomów,
tablica symboli,
gramatyka,
bo to dla danego języka programowania,
czy da się to drzewo
zbudować i według jakich
reguł je budować, to musi być
zaszyte w tej gramatyce.
No i tutaj
tutaj
tutaj
tutaj
tutaj
tutaj
tutaj
tutaj
tutaj
tutaj
No i proszę Państwa
teraz
te obiekty
mają pewne operacje,
i wtedy ten symbol
tu wejdzie do tej tablicy symboli.
Ta tablica symboli ma
operację daj symbol, tak, i wtedy kiedy jest
to potrzebne, to
mogę tą operację wywołać.
Gramatyka, obiekt gramatyka
jest tutaj jakoś opisana,
mogę tutaj wywołać
operację sprawdź, czy
pewna konstrukcja jest właściwa,
zgodna z regułami
gramatyki danego języka, jak nie
to może jakiś komunikat.
Mówiłam Państwu, że
zwyczajowo takie drzewo rozbioru,
drzewo składowe
jest zbudowane przez
kompilator.
Ono właśnie też potrzebuje,
żeby je tu zbudować, to też
trzeba sprawdzać pewne rzeczy,
czyli może sprawdź to raczej nie tutaj,
ale raczej tutaj
będzie ta operacja
sprawdź wywołana.
I jeżeli uda się takie drzewo
poprawnie zbudować,
być może z jakimiś drobnymi błędami,
które zostały wykryte, no to
teraz chodząc po tym
drzewie można będzie wygenerować
kod wynikowy
w jakimś języku
programowania.
Czy może do tego, co teraz
mówiłam Państwu, macie jakieś pytania,
uwagi?
Czyli zupełnie inne jest
ujęcie tego systemu, który budujemy
obiektowe,
jako zbiór obiektów
i komunikujących się
natomiast jeśli chodzi
o modele
strukturalne, funkcjonalne,
to są przepływy danych,
transformacje na tych danych.
Teraz
wspomniałam Państwu, że jednym z pierwszych
kroków projektowania
jest właśnie zrobienie,
zaprojektowanie
architektury systemu.
No i mamy różne
modele architektury systemu.
I w ogóle jak gdyby
różne,
też różne modele tutaj
możemy tworzyć. Czyli po pierwsze
powinniśmy
zacząć od takiego statycznego
modelu strukturalnego,
który będzie pokazywał główne
komponenty systemu, podsystemy,
moduły.
Teraz
no w tym systemie
będzie się coś tam
przebywało, więc
możemy, powinniśmy
projektować i modelować
pewną dynamikę, pewną strukturę
procesu, pewne
przepływy pomiędzy tymi procesami.
Wiadomo, że jeżeli mamy
pewną strukturę, jeżeli mamy
pewną komunikację,
współpracę tych
modułów,
to one muszą mieć,
muszą się komunikować
za pomocą interfejsu. A więc
musimy też zamodelować,
zaprojektować interfejsy
tych podsystemów.
Pomiędzy tymi
podsystemami, modułami
są
zazwyczaj pewne relacje,
pewne zależności.
Więc też takie modele
zależności powinniśmy zaprojektować,
zamodelować.
Czyli na przykład w jaki
sposób dane przepływają,
czy jaka jest komunikacja
pomiędzy tymi podsystemami.
No i to jest
jak gdyby na etapie
projektowania
systemu.
Natomiast potem już jak system
będziemy chcieli instalować,
ale to robimy już też
na tych początkowych etapach,
to musimy
zrobić model instalacyjny.
Czyli pokazać jak
te podsystemy mają być rozmieszczone.
Bo właśnie może
część tego oprogramowania ma być
powiedzmy na komputerze, klienta
instalowana, a część na serwerze,
a może gdzieś tam w chmurze,
a może jeszcze gdzieś indziej.
Więc jak gdyby to jest też ważna rzecz,
o której musimy pamiętać.
Model instalacyjny.
Teraz
ja chcę Państwu pokazać takie
bardzo podstawowe modele,
czy właściwie
style organizacji
systemu.
A więc systemy,
w których mamy dzielone
repozytorium,
takie systemy, gdzie mamy
taki styl serwerowy i serwisy,
czy strukturę
warstwową.
Popatrzmy jak to będzie wyglądało
w przypadku modelu
z repozytorium.
A więc mamy jakieś repozytorium,
mamy podsystemy,
które będą korzystały
z tych danych w repozytorium,
będą je modyfikować, będą je wymieniać.
Dane są właśnie przechowywane
w tym repozytorium w centralnej
bazie.
I dostęp do nich mają wszystkie
podsystemy.
To jest jak gdyby jedna z możliwości.
A druga możliwość
jest taka, że każdy podsystem ma
własną bazę danych
i te dane przekazuje
explicite do innych systemów.
Częściej
jest stosowany ten model,
że mamy rzeczywiście to
repozytorium jedno
i z niego korzystają
różne podsystemy.
No bo to jest bardziej efektywne.
A nie przekazywanie
explicite całych
zbiorów danych.
Czyli na przykład jak to może wyglądać.
No więc powiedzmy, że mamy
takie właśnie
narzędzie typu
case, które będziemy używali
do projektowania, a więc
zarówno tam będziemy
przechowywali
różne rzeczy dotyczące projektu.
Czyli mamy bazę danych,
mamy takie repozytorium projektu.
I teraz, tak jak Państwu
mówiłam,
możemy
tutaj wprowadzać
nowe projekty, możemy
te projekty
uszczegóławiać, edytować.
A więc mamy takie
różne
podsystemy, które
używamy, na przykład ten design editor
do projektowania.
Czy możemy tutaj również
te projekty w jakiś
sposób analizować, a więc
jakiś moduł, który służy do analizy.
Możemy
być może z tych projektów,
jeżeli na przykład one są zrobione
w UML-u, to możemy wygenerować
kod, na przykład w C++,
czy w Javi. A więc mamy
taki moduł, czy część systemu
odpowiedzialna za generator kodu.
Możemy szukać pewnych
sprzeczności w tym projekcie, czy
pewne błędy, szukać pewnych
błędów, niespójności,
a więc może, czy może generować
dokumentację, a więc może
być taka część systemu, która będzie
odpowiedzialna za generację tych
raportów.
No i one się
kontaktują, prawda, wszystkie
sięgają do tego repozytorium
projektu i jak gdyby robią,
wykonują te funkcje, które
żeśmy im przydzielili.
Jakie są zalety takiego podejścia?
No właśnie, jak mamy duże
dane, to to jest niewątpliwie
efektywna metoda.
Nie muszą wiedzieć te
podsystemy, w jaki sposób te dane
są produkowane.
Można dla tych danych tutaj,
prawda, można
przepraszam za nie poproszenie
w tą stronę, co trzeba,
można przygotować
właśnie pewne
programy, które zapewnią bezpieczeństwo
tych danych, prawda, jakieś backupy
tych danych.
Natomiast
oczywiście ten schemat
repozytorium, ta struktura
tych danych musi być
dostępna dla wszystkich
tych modułów, które się
z nich korzystają.
No i z tym może być
pewien problem, dlatego że
te różne podsystemy
mogą wymagać
różnej postaci tych
danych i
no a tutaj trzeba pewien kompromis
zachować tak, żeby ten model danych
był wspólny dla
różnych podsystemów.
W takich systemach
ewolucja danych, jakaś
zmiana w tych danych jest
bardzo trudna do realizacji
i jest kosztowna.
Więc
trudno jest te dane efektywnie
dystrybuować, brakuje tutaj
reguł zarządzania,
więc tu
z tym się wiążą pewne problemy.
Inna struktura
to może być model typu klient-serwer.
Tutaj
może być
zbiór pewnych
serwerów, które dostarczają
określonych usług.
Na przykład są odpowiedzialne
za jakieś funkcje typu
zarządzanie danymi, dostęp do
danych i mamy
jakiś klientów, którzy korzystają
z tych usług
oferowanych przez serwery.
No i musi być jakaś
sieć, która zapewnia
tutaj tą
komunikację i dostęp.
Czyli na przykład mamy internet,
mamy jakieś
serwery, które dostarczają
pewne usługi
i poprzez internet,
czy na przykład jakąś sieć
lokalną
komunikujemy się
z tymi, żądamy
wykonania pewnych usług.
Jakie są zalety?
Tutaj jest bardzo prosta dystrybucja
danych.
Dostarczamy systemy
z systemów sieciowych.
Łatwo jest, proszę Państwa,
taki system rozszerzyć.
Można tu dodać nowy serwer,
można dodać nowego klienta.
Łatwo jest takie systemy
rozbudowywać.
Natomiast jakie są wady?
Tutaj może być tak, że
brak takiego modelu
danych dzielonych,
więc te podsystemy mogą mieć
różną organizację danych
i są zupełnie efektywne.
Zarządzanie tymi danymi
musi być w każdym serwerze
zrobione niezależnie,
więc często tutaj
są dodawane do tego
jakieś rejestry
nas i usług po to, żeby łatwiej było
te usługi zlokalizować,
czy stwierdzić, czy w ogóle one są.
No i teraz
ten trzeci taki typowy model
to jest model warstwowy.
Czyli jak gdyby taki model
warstw akcyjnych
każda warstwa dostarcza
pewnego zbioru usług
i zmiana
interfejsu warstwy
wpływa tylko na warstwy przyległe.
Po raz pierwszy
taki system
o organizacji warstwowej,
pierwszy system
to był, proszę Państwa, UNIX,
który w ten sposób został zrealizowany,
czyli jądro i potem
kolejne warstwy.
Ale ten model może być stosowany
obecnie również.
Czyli na przykład
mamy tutaj system operacyjny,
który dostarcza pewnych wywołań,
pewnych usług funkcji
systemowych.
Na tym opieramy warstwę
związaną z
obsługą bazy danych, która
być może
z tego korzysta, prawda, czy wywołuje
pewne, ale ona
udostępnia z kolei
w warstwie wyższej pewien
interfejs. Tutaj mamy
jakiś system zarządzania,
taki system konfiguracyjny
i tak dalej. Każda kolejna
warstwa korzysta
z usług tej warstwy niższej
i dodaje tutaj
udostępnia znowu
użytkownikowi czy warstwie wyższej
swoje usługi, swoje
możliwości.
Także również tak.
Teraz, jeśli chodzi o
style sterowania,
jakoś musimy
rozwiązać system, prawda,
sterowanie, jak mamy ilość tych
podsystemów, więc
albo możemy stosować
sterowanie zcentralizowane,
czyli na przykład
jeden z podsystemów powiedzieć,
że jest takim menadżerem
i jest odpowiedzialny
za taki master,
za uruchamianie, zatrzymywanie
innych podsystemów, to jest jeden
z modeli, a drugi
to jest sterowanie zdarzeniowe.
Każdy podsystem
odpowiada na
wyłącznie generowane
zdarzenia z innych podsystemów
czy z otoczenia.
Jeśli chodzi o
zcentralizowane sterowanie,
czyli mam taki podsystem, który
jest odpowiedzialny za wykonywanie
innych procesów, to albo
może być to model typu
call return, czyli to jest
taki model top down
podprogramów,
których sterowanie
zaczyna się w wierzchołku
hierarchii i przesuwa się w dół.
Można tak to rozegrać.
Lub model, o którym wspomniałam,
model typu menadżer, który
może być też stosowany w systemach
równoległych. Jeden z komponentów
steruje innymi.
Taki jest nadzorca
nad innymi. Tu mamy model
typu call return, czyli taka
hierarchia.
Wywołujemy, ten
ewentualnie wywołuje kolejne.
Natomiast
może być właśnie tak, że mamy
pewien taki system,
który steruje
innymi.
I taki menadżer, kontroler.
I to zwykle jest
ten schemat stosowany w systemach
czasu rzeczywistego, czyli mamy
tutaj jakieś procesy
i on decyduje, który proces
i w jakiej kolejności, kiedy będzie
mógł się wykonać i będzie coś
robił. Jeśli chodzi
o systemy zdarzeniowe,
właśnie w systemach obiektowych,
to pojawienie się zdarzenia
nie jest kontrolowane, prawda?
Natomiast też możemy mieć
tutaj różne metody,
różne modele takich
systemów zdarzeniowych.
Model rozgłaszania,
taki broadcasting.
Zdarzenie jest rozgłaszane do wszystkich
podsystemów. I dowolny
system, który na nie oczekuje, czy
jest w stanie, może je obsłużyć.
A drugi model, to jest
model sterowany przerwaniami.
To w systemach czasu rzeczywistego
przerwania wykrywane są
i tutaj przekazywane
jest sterowanie do komponentu,
który obsługuje
to konkretne przerwanie.
Model rozgłaszania
jest to efektywne
w integracji podsystemów na różnych komputerach
w sieci. Podsystemy
rejestrują zainteresowanie
pewnymi zdarzeniami i jeżeli
się ono pojawia, to sterowanie jest
przekazywane do
podsystemu, który może je obsłużyć.
Reguły
przerwania nie są zwykle wbudowane
w ten event message handler
i podsystemy same decydują,
które zdarzenia je interesuje.
A podsystemy nie wiedzą,
czy w ogóle pojawi się jakieś
zdarzenie i ewentualnie kiedy.
Czyli mamy takie
rozgłaszanie, łapią
jak gdyby te podsystemy,
jeżeli jest coś rozgłaszane takiego,
na co one są przygotowane,
czego oczekują.
No i możemy również
korzystać z systemów
z przerwaniami.
W takich systemach
sterowania, gdzie
potrzebna jest bardzo szybka reakcja
na zdarzenia, to
jak gdyby przy wystąpieniu pewnego
typu przerwania, dla tego
przerwania zdefiniowany jest
program obsługi, on jest w pewnym
konkretnym miejscu w pamięci
i następuje sprzętowe przełączenie
na ten program obsługi.
Także jest to bardzo szybka
reakcja, natomiast jest to
dosyć trudne do
oprogramowania
i do jak gdyby stwierdzenia.
Czyli właśnie mamy
taki wektor przerwań, te przerwania
są związane z, jak gdyby konkretne
przerwanie odpowiada za pewną
sytuację, na przykład taką sytuacją
może być
błąd pamięci, czy dzielenie
przez zero, czy coś tam
innego, czy mogą być również
takie przerwania, które użytkownik
sobie definiuje do swoich potrzeb
i jest program, który obsługuje
to konkretne przerwanie, który
jest w konkretnym miejscu
pamięci, jak to przerwanie występuje
to ten program
zabiera się za swoją
realizację.
I to by było
na tyle dzisiaj.
Czy Państwo macie jakieś
pytania, uwagi dotyczące
tego materiału, który
dzisiaj zaprezentowałam?
Jeżeli nie, to
zatrzymuję teraz nagrywanie
wykładu.
No i ja za chwilę
ustawię
---------------------------------------------Dzisiaj będę chciała Państwu zacząć już przedstawiać UML-a.
Zanim do tego dojdę, to chcę Państwu kilka zdań powiedzieć na temat takiego podejścia obiektowego, jak również powiedzieć skąd się ten UML wziął i dlaczego się go uczymy.
Parę zdań powiem o takim podejściu obiektowym do projektowania.
Króciutko pokażę Państwu skąd się wziął ten UML i taki sposób widzenia systemu wtedy, kiedy chcemy ten system projektować za pomocą UML-a.
No właśnie, więc zacznę od tego co to jest ta analiza systemu, bo mówiłam tutaj o takiej analizie obiektowej.
I tutaj posłużę się cytatem z Weinberga, że analiza systemu jest badaniem problemów, celów, wymagań, priorytetów i ograniczeń,
wynikających ze środowiska wraz z szacowaniem kosztów, zysków, wymagań czasowych w celu wypracowania pierwszych propozycji rozwiązań.
Więc widzicie Państwo, że jest to bardzo szeroko tutaj mamy określone, co to jest ta analiza.
Że zarówno jest to właśnie określenie tego, co ten system będzie miał robić, ale również szacowanie kosztów, szacowanie ograniczeń czasowych
i tutaj no też analiza różnych ryzyka, które się wiąże z przyjęciem takiego rozwiązania.
Właśnie wyborem, w celu wybrania pierwszej propozycji rozwiązań.
Tutaj chodzi oczywiście o to, aby to wybrane przez nas rozwiązanie zostało zakończone.
Właśnie wyborem, w celu wybrania pierwszej propozycji rozwiązań. Tutaj chodzi oczywiście o to, aby to wybrane przez nas rozwiązanie zostało zakończone.
Wielu firmach jest stanowisko analityk i takie osoby co one robią, czym biorą udział?
Wielu firmach jest stanowisko analityk i takie osoby co one robią, czym biorą udział?
Wielu firmach jest stanowisko analityk i takie osoby co one robią, czym biorą udział?
No więc pierwsza sprawa, to jest analiza wymagań, o tym mówiłam Państwu o inżynierii wymagań, mówiłam Państwu na poprzednim wykładzie
No więc pierwsza sprawa, to jest analiza wymagań, o tym mówiłam Państwu o inżynierii wymagań, mówiłam Państwu na poprzednim wykładzie
mianowisko analityk i takie osoby, co one robią, czy czym biorą udział.
Pierwsza sprawa to jest analiza wymagań. O tym mówiłam Państwu o inżynierii wymagań,
mówiłam Państwu na poprzednim wykładzie i właśnie analitycy przygotowują te wymagania,
zbierają te wymagania, określają ich priorytety, atrybuty.
Następnie weryfikacji rozwiązań, czyli jak powstają pewne rozwiązania,
właśnie mamy tutaj pewien projekt wstępny, potem projekt szczegółowy,
to te osoby zajmują się również oceną tego projektu od strony technicznej,
przyglądają się, czy to rozwiązanie rzeczywiście ma szansę spełnić te wymagania,
które zostały przygotowane.
Teraz po zakończeniu produkcji tego oprogramowania, mówiłam Państwu,
że weryfikacja oprogramowania polega na tym, że sprawdzamy, czy oprogramowanie spełnia wymagania,
więc właśnie robią to też te osoby.
Walidacja. Zwracałam Państwu uwagę, że w walidacji oprogramowania musi brać udział strona klienta,
ale to właśnie na ogół.
Nie są zwykli użytkownicy, którzy tę walidację przeprowadzają,
tylko właśnie często są to analitycy z tej strony klienta, którzy przyglądają się,
czy ten system spełnia rzeczywiście oczekiwania użytkowników.
No i także podają pewne wytyczne co do zasad pielęgnowania systemu,
sposobów, w jakich mają być zgłaszane ewentualne poprawki do tego systemu
i tak dalej. Więc bardzo tutaj rozległy zakres obowiązków.
Tak jak Państwu pokazałam dzisiaj tą definicję Weinberga, co to jest analiza systemu,
to ta analiza, proszę Państwa, obejmuje różne sfery.
A więc pierwsza sprawa to jest dziedzina problemu, czyli właśnie tutaj się decyduje,
co ma być wykonane poprzez określenie wymagań dla tego systemu.
Teraz druga taka sfera, to jest sfera wykonalności.
A więc czy w ogóle realizacja tego systemu, tutaj mamy jakąś wizję tego systemu,
czy to jest możliwe? I to, czy to jest możliwe siłami, które nasza firma posiada?
Czy jesteśmy w stanie to zrobić? Czy jesteśmy w stanie również to zrobić w jakimś tam narzuconym czasie,
który czasem jest podany jak gdyby na wejściu?
I również mamy tutaj sferę ekonomiczną, bo mówiłam Państwu, że analiza to jest też szacowanie zysków i kosztów.
Czyli właśnie też tutaj ta sfera ekonomiczna, szacowanie jakie będą koszty produkcji tego systemu,
no i jakie zyski, czy będziemy w stanie coś na tym zarobić, na tej produkcji systemu.
Także też bardzo szeroki.
Teraz proszę Państwa, jak mamy do...
zrobienia coś, co jest bardzo złożone, duże, skomplikowane,
no to musimy do tego czegoś podchodzić w taki sposób,
zaczniemy może od hierarchicznego takiego podejścia,
czyli najpierw widzieć pewne ogólne cele tego, a potem schodzić coraz to niżej.
Czyli właśnie musimy stosować tutaj poziomy abstrakcji,
na tym takim poziomie.
Bardzo wysokim, ogólny cel systemu widzieć, a potem schodząc coraz niżej,
no właśnie widzieć te cele bardziej takie, coraz bardziej szczegółowe.
Teraz jeśli chodzi o to podejście właśnie przez stosowanie abstrakcji,
to te abstrakcje mogą być no bardzo różne.
A więc często stosujemy tak zwaną abstrakcję proceduralną.
Czyli na pewnym poziomie,
widzimy operację jako taką operację elementarną,
która no coś ma wykonać, na przykład prawda, ma dostarczyć pewnych danych
użytkownikowi czy odpowiedzieć na zapytanie użytkownika.
Natomiast wiadomo, że w rzeczywistości ta właśnie abstrakcja,
ta operacja jest realizowana przez operacje niższych poziomów.
I właśnie potem stopniowo schodząc do tych niższych poziomów,
widzimy, że ta operacja,
nie jest pewnym takim elementarną akcją,
ale że składa się z takich i z takich akcji,
z takiej i takiej sekwencji wywołań operacji niższego poziomu.
Stosujemy oczywiście również abstrakcje danych.
Czyli właśnie no definiujemy pewne typy danych
i dla tych typów danych określamy operacje,
które no będą pozwalały nam te dane powrócić.
Zabrać, zmodyfikować, zapisać, zmienić i tak dalej.
I istotne jest, żeby właśnie no, żebyśmy zaprojektowali,
żebyśmy dostarczyli operacji, które na tych obiektach danych
będą te czynności wykonywały.
No bo właśnie, bo my te dane ukrywamy w pewnych,
no właśnie w takich bytach, w pewnych obiektach.
I również właśnie przy tym złożonych,
takich bardzo dużych systemach,
no musimy to ukrywanie informacji, musimy stosować.
Dlatego, że po prostu nie jesteśmy w stanie
nad wszelkimi szczegółami zapanować,
jeżeli podejdziemy to do nich w taki sposób płaski.
Tylko właśnie no,
gdyby na przykład z pewnym, do pewnego modułu,
do pewnej części systemu, prawda,
przydzielamy mu pewne, tak jak mówiłam Państwu
na poprzednich zajęciach, przydzielamy pewne funkcje,
które ta część systemu ma realizować.
I jedynie poprzez interfejs, prawda, możemy się do tego dostać.
Czyli możemy tą funkcję wywołać, tak,
czy te funkcje, które moduł dostarcza.
Ale nie wchodzimy, jak gdyby wywołując,
te operacje, nie wchodzimy w szczegóły,
jak to w środku zostały zrealizowane, w jaki sposób.
Czyli właśnie te interfejsy musimy też tak projektować,
aby za pomocą tego interfejsu można było, no,
wykonać te funkcje, te czynności,
które danej jednostce zostały przydzielone,
ale jednocześnie, żeby nie odsłaniać
jego wewnętrznej struktury, jego wewnętrznych danych.
No i, proszę Państwa,
bardzo istotna również cecha to jest dziedziczenie.
Mianowicie, no tutaj już od samego początku mówiłam Państwu,
że musimy stosować takie podejście, prawda, hierarchiczne.
A więc właśnie też zacząć od pewnych cech ogólnych
i potem coraz to niżej schodzić do cech szczegółowych.
Czyli również w ten sposób musimy patrzeć na, no,
na pewne klasy, które w tym systemie są,
widzieć jakieś ich cechy wspólne, ogólne
i określać właśnie taką, no, taką klasę,
która będzie te cechy ogólne gromadziła w sobie,
na niej pewne operacje są wykonywane,
czy mogą być wykonywane i operacje,
i klasy dziedziczące te możliwości, te atrybuty, te operacje,
które będą już działały w taki sposób, no, bardziej szczegółowy,
i tam te rozwiązania będą bardziej szczegółowe.
No i oczywiście musimy stosować tutaj, prawda,
musimy kojarzyć wiele rzeczy, łączyć wiele idei.
A więc takie typowe zasady, które należy stosować wtedy,
kiedy mamy coś trudnego złożonego do realizacji.
No i proszę Państwa, te cechy są zbieżne z cechami modelu obiektowego,
którymi są właśnie stosowanie abstrakcji, enkapsulacji,
modularność, stosowanie hierarchii.
Stąd można powiedzieć, że takie obiektowo zorientowane projektowanie
daje nam, no, daje nam szansę na to, aby projekt,
który w ten sposób zrealizujemy, był projektem dobrej jakości.
Znowu, co to jest projekt dobrej jakości?
To też na poprzednim wykładzie mówiłam.
Teraz właśnie, bo w takim projektowaniu obiektowo zorientowanym,
no, koncentrujemy się na tym takim, mamy w bardzo dużym stopniu
to ukrywanie informacji w klasach zrealizowane.
To może prowadzić do systemów, które są bardzo spójne.
Mamy mniej zależności niż takich w takim podejściu funkcjonalnym,
a więc daje nam, no,
daje nam to szansę na to, aby projekt był projektem dobrej jakości.
Przy obiektowym projektowaniu systemów, to to system, który realizujemy,
musimy widzieć jako zbiór współdziałających obiektów.
No i teraz, proszę Państwa, no, tych obiektów może być,
powiedzmy, kilkanaście, jeśli to jest jakiś projekt studencki, tak?
Może być to, nie wiem, kilkadziesiąt,
jeśli to już jest jakiś projekt troszkę większy,
czy na przykład jakaś praca inżynierska,
ale oczywiście, no, w systemach, które używamy,
tych obiektów, czy tych klas, w których instancjach,
których obiekty w tym systemie istnieją,
może być i parę tysięcy, więc, no, musimy też, jak gdyby,
z tego sobie zdawać sprawę, że tego może być bardzo wiele
i stąd konieczne jest właśnie takie podejście,
taka modularność, podejście hierarchiczne
i takie, no, gromadzenie tych obiektów, czy tych w pewnych podzbiorach.
O zaletach już częściowo opowiedziałam,
bo właśnie przez to, że w takich systemach obiektowych
te obiekty się ze sobą komunikują poprzez wymianę informacji, prawda?
Poprzez wymianę komunikatów, czyli wywołanie operacji,
no, to mamy wyeliminowane tutaj wspólne obszary danych.
Te dane są włożone wewnątrz obiektów
i obiekt udostępnia operację działania na tych danych, prawda?
Więc nie ma tych obszarów wspólnych,
na których wiele osób mogłoby wykonywać jakieś operacje.
Ta reprezentacja informacji jest wewnątrz obiektów,
stąd jeżeli wykonujemy jakieś zmiany w tych, na przykład,
w tej strukturze danych, które są wewnątrz tego obiektu,
a nie zmieniamy tych operacji dostępu do tych danych, ich parametrów,
one mogą być zupełnie, mogą być jak gdyby zupełnie inaczej działać,
ale jeśli parametry mają zachowane,
no, to wtedy taka zmiana, prawda, jest zmianą lokalną,
nie wpływa to na inne części systemu.
Także takie systemy obiektowe są łatwo modyfikowalne.
No i kolejna zaleta, to jest taka,
że nie musimy w fazie projektowania systemu,
nie musimy podejmować decyzji,
czy ta implementacja tego systemu będzie w postaci sekwencyjnej,
czy będziemy mieć jakieś zrównoleglone czynności w tym systemie wykonywane,
bo to, ta decyzja może być odłożona do momentu, no, instalacji tego systemu.
Także to też jest bardzo duża rzecz.
Zaleta w systemach projektowanych w sposób funkcjonalny, strukturalny,
tego typu decyzja musi zapaść na początkowych etapach projektowania.
No właśnie, no więc tutaj padło określenie obiekt.
Co to jest taki obiekt?
Istotne jest, że obiekt ma pewną indywidualność,
ma stan, w którym można powiedzieć, że taki stan to jest jak gdyby taka,
no, takie zdjęcie tego obiektu w pewnej,
w pewnej chwili wykonane i w tym stanie jak obiekt się znajduje,
no to właśnie te wartości atrybutów tego obiektu, cech tego atrybutu
mają pewne określone wartości.
Również w tym stanie jest skumulowane zachowanie obiektu,
dlatego że właśnie istotne jest, że obiekt ma pewne zachowanie, tak?
Czyli jak gdyby ze stanu początkowego, w którym jest utworzony,
w którym jest tworzony, w zależności od tego,
jakie stymulacje do niego przychodzą, to zmienia te stany, tak?
I stąd jak gdyby musimy też projektować zachowanie obiektów.
I będziemy się tego uczyć, będziemy za pomocą maszyny zmian stanów
takie zachowanie obiektów poszczególnych klas projektować.
Teraz, proszę Państwa, te obiekty mogą pełnić bardzo różnorodne role.
Mówi się o obiektach typu aktor,
że są to takie obiekty, które są aktywne,
które no właśnie działają, które mogą sterować innymi obiektami,
ale to, jak one się mają zachowywać, to jest jak gdyby wewnątrz nich
już tutaj zakodowane i na takiego, na taki obiekt typu aktor
nikt inny, inne obiekty nie wpływają.
Mówimy o obiektach typu serwer, że są to obiekty, które nie sterują innymi obiektami,
ale mają pewien zbiór usług i, prawda, na żądanie innych obiektów
mogą wykonywać te usługi, mogą dostarczać te usługi.
I mówimy o obiektach typu agent, które mogą pełnić obie role,
czyli zarówno dostarczać pewnych usług, jak i sterować innymi obiektami.
Teraz, proszę Państwa, jeśli chodzi o tą analizę właśnie obiektową,
to tutaj można powiedzieć o takich podstawowych krokach,
które zawsze się wykonuje.
A więc, zaczynamy, proszę Państwa, od identyfikacji obiektów.
No, właśnie musimy określić te obiekty.
Za chwileczkę troszkę więcej na ten temat powiem.
Skąd takie obiekty brać?
Czyli już najpierw zaczynamy od, no,
wyznaczenia pewnego zbioru obiektów, które wydaje nam się,
że w tym systemie powinny się znajdować.
Teraz, proszę Państwa, też musimy te obiekty w jakiś sposób zorganizować.
Czyli właśnie na przykład tutaj znaleźć te relacje typu obiekt ogólny
i pewne specjalizacje tych obiektów, czyli znaleźć dziedziczenie.
A może te obiekty powinny być inaczej zorganizowane,
na przykład w ten sposób, że pewien obiekt jest całością,
a jakieś inne obiekty są jego częściami składowymi.
Albo może po prostu te obiekty, no, nie mają ani takiej, powiedzmy,
zależności w cudzysłowie rodzinnej, tak, takiego dziedziczenia,
ani nie mają też takiej zależności, że są częścią składową jakichś innych,
ale ze sobą współpracują, więc taką, musimy też znaleźć, które obiekty wiedzieć,
które obiekty ze sobą będą współpracowały.
No właśnie, i następny krok to jest, proszę Państwa, opis interakcji tych obiektów,
czyli właśnie opis tej współpracy pomiędzy obiektami,
dlatego że, tak jak Państwu mówiłam, system obiektowy to jest zbiór współdziałających obiektów
i to, te funkcje, te usługi, które taki system obiektowy nam daje,
wynikają po prostu z pewnej współpracy pomiędzy tymi obiektami.
To, co my widzimy, to, co użytkownik widzi,
to jest efekt pewnych interakcji pomiędzy obiektami w tym systemie
i to oczywiście musimy zaprojektować.
No i teraz przechodzimy do takich bardziej szczegółowych ustaleń,
mianowicie tutaj na tym etapie opis interakcji to my, jak gdyby, określamy,
jakie operacje, jakie czynności poszczególne obiekty mają wykonywać,
a dalej w kolejnym kroku musimy te operacje, czyli te czynności obiektu,
musimy zdefiniować, na przykład musimy się zdecydować,
jaki algorytm będzie tę operację realizował.
No i również definicja wnętrza obiektu, czyli właśnie tych danych,
które wewnątrz obiektu są przechowywane.
Także to są takie podstawowe kroki analizy obiektowej.
No i teraz jeszcze może wrócę do tego,
jak to wygląda, jak to wygląda obiekt.
Ja je tutaj, proszę Państwa, wymieniłam w postaci takiej sekwencji,
ale to nie jest taki, jak gdyby, jeden przebieg przez te kroki,
czyli to nie jest tylko tak, że zaczynamy i to jest, idziemy w dół,
tak, idziemy w dół, ale tutaj są nawroty, czyli wracamy.
Często jest tak, że na tym etapie organizowania obiektów
dodajemy nowe obiekty, często na tym etapie opisu interakcji
widzimy, że one są być może zbyt szczegółowe,
więc możemy wrócić, nawet dodając nowe obiekty i tak dalej.
Czyli to jest, proszę Państwa, proces taki iteracyjny,
te kroki wykonywane są wielokrotnie, aż będziemy zadowoleni z tego, co…
Nie mogę tutaj znaleźć…
Okej, nie mogę.
Teraz, jeśli chodzi o tą identyfikację obiektów,
to tu, proszę Państwa, jedyna taka wskazówka, jak do tego podejść,
to jest taka, że jak zaczynamy szukać, jakie obiekty w tym naszym systemie powinny być,
to szukamy ważnych rzeczowników, ale z dziedziny problemu.
I to są kandydaci na to, żeby być takim obiektem.
I kolejna rzecz jest taka, żeby te podmioty…
Tutaj zaczynamy mówić najpierw o takich klasach, obiektach w liczbie pojedynczej,
a potem ewentualnie je jakoś tam składać.
I to jest, proszę Państwa, w zasadzie jedyna sensowna podpowiedź, którą można podać,
ale oczywiście jeszcze przy tej identyfikacji obiektów…
No, może mogą nam pomóc jeszcze typy obiektów.
Czyli po pierwsze, jak będziemy identyfikować obiekty,
to szukamy takich obiektów, czy identyfikujemy takie obiekty,
które będą służyły do przechowywania pewnych informacji, czyli takie obiekty aktywne.
Może, proszę Państwa, będą potrzebne nam pewne obiekty,
które będą takimi obiektami aktywnymi, na przykład będą sterowały wykonaniem czegoś, tak?
Będą nadzorowały wykonanie pewnych czynności, czyli mogą być takie obiekty właśnie aktywne.
Teraz, proszę Państwa, często jest tak, że jak projektujemy pewien system,
no to ten system ma gdzieś działać, na przykład jeśli, powiedzmy, to jest system,
który wspomaga prognozowanie pogody, no to ten system, prawda, mamy,
żeby tą prognozę pogody prognozować, żeby określać prognozę pogody,
to musimy mieć dane, na przykład takie, o jaka jest temperatura, wilgotność,
a więc mamy pewne obiekty fizyczne, istniejące, no, w świecie rzeczywistym,
które będą jakiś nam danych dostarczać.
I, proszę Państwa, wtedy te obiekty, które fizycznie istnieją,
czyli na przykład ten termometr, no to są takie obiekty, które istnieją,
czyli na przykład ten termometr, ten ciśnieniomierz, miernik siły wiatru,
kierunku wiatru i tak dalej, będą miały w systemie, no, klasy, które będą je,
czyli obiekty, które będą je reprezentowały faktycznie.
Czyli jak gdyby pewnym fizycznym bytom z tego systemu, z tego środowiska,
w którym system ma działać, będą odpowiadały właśnie też w tym naszym systemie,
pewne klasy, pewne obiekty.
Ale również sporo będzie w takim systemie takich obiektów po prostu wymyślonych przez nas,
czyli tak zwanych obiektów konceptualnych.
Teraz kolejna rzecz, no, niektóre z tych obiektów są obiektami stałymi.
I to, czyli cały czas istnieją w trakcie działania tego systemu.
Mało tego, musimy na przykład zapewnić,
żeby je, jeżeli ten system zamykamy, tak, to żeby jakby te wartości,
które w tych obiektach były przechowywane, żeby zostały zapisane,
żeby przy nowym starcie systemu, tak, prawda, te dane mogły być pobrane.
Czyli mamy tutaj, no, obiekty stałe, mówimy również o takich informacjach permanent,
które, prawda, muszą być zapisywane, no, właśnie w bazach danych.
Ale w trakcie działania tego systemu pewnie będą potrzebne również takie obiekty,
które są powoływane tylko na trochę, na chwilę.
Na przykład po to, żeby zrealizować określoną funkcję tego systemu.
Takie obiekty chwilowe. One być może będą właśnie aktywne,
bo one będą sterowały przebiegiem pewnych czynności po to,
żeby jakąś funkcję ten system zrealizował.
No i teraz, proszę Państwa, możemy również mówić o, jak gdyby, czy widzieć również dostępność obiektów, a więc obiekty publiczne, no mogą być również obiekty prywatne, czyli właśnie te niektóre z tych obiektów mogą posiadać takie swoje, jak gdyby, części składowe, na przykład obiekty prywatne, w których będą pewne informacje przechowywane.
No właśnie tutaj już dochodzę do obiektów typu całość-część, czyli możemy widzieć pewien obiekt, że jest pewną całością i widzimy pewne jego części składowe, czy pewne jego elementy, które wchodzą w skład tej całości.
No i wspominałam Państwu o tej strukturze, o dziedziczenia, którą też dobrze byłoby w systemie mieć, czy nam jest dobrze.
Żeby ona wystąpiła, bo jest dla nas po prostu wygodna i dla struktury systemu jest wygodna, więc też, proszę Państwa, no tutaj z obiektów, które żeśmy zidentyfikowali, tak, przyglądamy się, czy nie można, no z tych być może specyficznych obiektów, które żeśmy tutaj zidentyfikowali, czy nie można, jak gdyby, wyodrębnić pewnych ich cech wspólnych i wtedy taki obiekt ogólny utworzyć.
Dziękuję.
Widzimy, że one mają pewne cechy wspólne. Wrócę tutaj może do tego, do tych podpowiedzi, prawda, jakie, jak te obiekty identyfikować i teraz spróbujmy sobie tutaj jakieś przykłady podać.
Czyli wyobraźmy sobie, że mamy takie nowe UBI zaprojektować, zrealizować. Jakie obiekty tutaj byście Państwo zaproponowali?
Czyli jakie ważne rzeczowniki z dziedziny?
Z dziedziny problemu. Jeśli realizujemy taki system typu UBI, jakie, jakie ważne rzeczowniki z dziedziny problemu byście Państwo widzieli? Słucham jakichś pomysłów.
Wersja mobilna, bo nie ma. Jest tylko, jest tylko na komputery stacjonarne.
No dobrze, ale mnie chodzi o to, że teraz, no zaczynamy, powiedzmy, że celem naszym jest właśnie zrobienie takiego systemu, tak.
I my tutaj, jakich kandydatów na obiekty w takim systemie byście Państwo widzieli?
Czyli szukajcie ważnych rzeczowników, ważnych podmiotów z dziedziny problemu. No ten problem, dziedzina problemu jest Wam znana, bo korzystacie z tego systemu UBI, więc tutaj powinno być Wam łatwo podać takie rzeczowniki. Jakie, jakie to mogą być rzeczowniki?
Student?
Dobrze.
Student, tak.
Przedmiot. Przedmiot, kurs, co jeszcze? Jak studenta to pewnie potrzebny jest wykładowca, pewnie potrzebna jest jakiś pracownik dziekanatu na przykład, bo tutaj też jest dziekan.
Czyli właśnie mamy ważne rzeczowniki z dziedziny problemu.
No to teraz, proszę Państwa, podaliśmy tutaj kilka rzeczowników takich właśnie typu student, wykładowca, student, wykładowca, dziekan, pracownik dziekanatu.
Czy te obiekty, widzicie Państwo, mają jakieś cechy wspólne? Moglibyśmy tutaj jakąś strukturę dziedziczenia utworzyć, albo może coś dodać, żeby taką strukturę utworzyć?
Są to osoby?
Świetnie, są to osoby. Czyli dodajemy tutaj na przykład klasę osoba, która może być taką klasą abstrakcyjną, że faktycznie w systemie jej nie będzie,
ale w niej są gromadzone te pewne cechy wspólne, czyli właśnie student ma, prawda, i wykładowca, i pracownik dziekanatu, i dziekan mają imię, nazwisko, tam adres zamieszkania, PSL, coś jeszcze, tak?
No a teraz potem możemy dodawać te cechy już takie specyficzne, czyli dla studenta numer, na przykład indeks, ale to już będziemy, czyli możemy utworzyć taką hierarchię dziedziczenia.
Teraz, proszę Państwa…
Proszę Państwa, kolejna, kolejny ruch to jest właśnie określenie, które obiekty ze sobą muszą współpracować, w jaki sposób komunikować się,
więc też będziemy szukać tutaj takich relacji pomiędzy obiektami, które ze sobą współpracują, a wynik tej współpracy jest widoczny.
Teraz szukamy również tutaj takich relacji,
żeby właśnie obiekty,
obiekt był częścią innych obiektów i tutaj, no, mówiliśmy, ktoś powiedział student, tak, a ktoś powiedział studenci, tak?
Czyli tutaj możemy powiedzieć, że na przykład mamy obiekt student, tak, i na przykład mamy, no, na naszym przedmiocie ja mam listę zajęciową, tak, ta lista zajęciowa, lista tego kursu,
więc można powiedzieć, że taki student jest
elementem składowym, jest częścią listy studentów
przedmiotu takiego, a nie innego.
Czyli mamy tutaj relacje typu całość i typu część.
Możemy mieć również tutaj relacje zależności pomiędzy tymi obiektami.
O tym jeszcze będę później mówić, ale na przykład w takich sytuacjach, kiedy mamy pewien obiekt, który jak gdyby definiuje pewien typ danych i ten typ danych jest używany przez inny obiekt.
Teraz, proszę Państwa, widzimy pewne relacje pomiędzy obiektami,
no, ale tak jak Państwu mówiłam, to co system obiektowy robi wynika z tego, że te obiekty ze sobą współpracują.
I teraz, proszę Państwa, my musimy opracować takie scenariusze współpracy tych obiektów,
gdzie rezultat tej współpracy to będzie pewna funkcja.
Dziękuję bardzo.
Funkcja potrzebna wewnętrznie dla systemu, albo potrzebna dla użytkownika tego systemu.
Także musimy właśnie przygotować, opisać takie scenariusze i z nich też mogą tutaj wynikać pewne dodatkowe związki,
których żeśmy w tym kroku poprzednim organizowania obiektów być może nie zauważyli,
bo być może właśnie dodamy jeszcze tutaj nowe związki, tutaj zobaczymy, że pewne obiekty ze sobą muszą współpracować.
No i teraz właśnie przygotowując tą współpracę, te scenariusze dostarczenia pewnej funkcji systemu,
wyjdzie nam też troszkę z tego, jakie operacje ten obiekt powinien wykonywać, czyli interfejsy obiektów, co one mogą dostarczać.
Tutaj.
Tutaj być może również wyjdą nam te zależności typu całość-część, bo być może się okaże, że właśnie tutaj widzimy, że coś jest pewną częścią.
W kolejnym kroku, już jak mamy te operacje, wiemy, że obiekt ma pewien zbiór operacji realizować,
no to możemy te operacje zdefiniować, czyli właśnie określić, co ten obiekt ma robić.
I tutaj ja mówiłam Państwu przed chwileczką, że to nie jest taki...
To nie jest taki proces sekwencyjny, tylko że to jest taka iteracja, że często się wraca do tych kroków poprzednich.
Więc właśnie jeśli tutaj przyglądając się temu, co ten obiekt ma robić, tym operacjom, wychodzi, że one są bardzo złożone,
to może trzeba ten obiekt rozłożyć na pewne obiekty, jego części składowe i dla nich te operacje zdefiniować.
No i ostatni krok to już jest implementacja tych operacji, czyli na przykład zastanowienie się,
jakie algorytmy powinniśmy użyć do tych operacji.
Teraz proszę Państwa popatrzeć tutaj na ten slajd i co Państwo tutaj widzicie, co tutaj można zauważyć, patrząc na ten slajd.
Coś widzicie?
Coś widzicie?
Jakieś, nie wiem...
Dużo jest podejść do tego zagadnienia.
Tak, było bardzo dużo podejść do tego zagadnienia.
Tutaj widzimy, że w większości tych metod mamy OO, co znaczy, jak się można domyśleć, Object Oriented.
Teraz popatrzcie Państwo tutaj na daty.
Taka masa tych różnych właśnie metod obiektowych to jest koniec lat 80., początek lat 90.
I jedynie dwie mamy tutaj takie linijki, które nam jak gdyby nie pasują.
Tego wzorca.
Tutaj widzimy również jest wiele nazwisk, prawda?
Czyli właśnie te metody były jak gdyby proponowane przez określone osoby i tutaj nazwiska tych znanych osób proponowanych te metody też Państwu tutaj pokazałam.
No i proszę Państwa, jak widzimy, wiele tych metod było proponowanych i był z tym duży problem, bo jeśli coś było tutaj, może zwrócę uwagę na to,
że najczęściej...
...prostosowano metodą w latach 90., na początku lat 90. była metoda OMT, że i również tutaj ta metoda też była dosyć często kodajurdona stosowana,
więc był problem taki, że jeżeli projekt został zrobiony według pewnej metody, tak, no to był często niezrozumiały dla osób, które tej metody nie używały.
Te metody, niektóre z tych metod miały taki zasięg lokalny.
Tutaj zwracam Państwu uwagę na metodę Fusion, która była stosowana w firmie Hewlett-Packard i zwracam Państwa uwagę na taką metodę, która się nazywała Merisi, która była stosowana we Francji.
Czyli widzimy, że tutaj niektóre z tych metod miały takie bardzo lokalne zastosowanie, prawda, w określonej firmie czy w określonym kraju.
No więc były z tym problemy.
No i wobec tego, proszę Państwa, zaczęto szukać jakichś...
Takich wspólnych cech tych metod.
I tutaj też proszę popatrzeć, koniec w 1989 roku było jedynie 10 metod obiektowo zorientowanych, a w 1994 już tych metod było 50.
No i te najbardziej znane, o których już Państwu wspomniałam, to była metoda Jimma Rambo-OMT, czy metoda Butcha, czy metoda Iwana...
Jakobs...
Iwana Jakobsona, czy metoda Koda-Jurdona.
No i teraz, proszę Państwa, dla tych metod były również narzędzia, które pozwalały projekt robić, bo z każdą z tych metod wiązała się również pewna notacja graficzna.
No tutaj mówiłam Państwu o tym, że taką cechą podstawową tej metody obiektowej jest ten obiekt, ale że istotne są te związki pomiędzy tymi obiektami, organizacja tych związków.
I tutaj, no, ci twórcy mieli różne podejścia do tego, jak to należy robić.
Czyli na przykład w metodzie OMT obiekt to był prostokącik, a w metodzie Koda-Jurdona ten prostokącik miał zaokrąglone rogi.
A w metodzie Butcha to nie był prostokącik, tylko to była taka chmurka.
No i wobec tego trudno było te projekty jakoś zrozumieć.
No i teraz, proszę Państwa...
Ja bym była taką firmą, która miała dobre narzędzie do właśnie takiego projektowania obiektowego, narzędzie się nazywało ROSE, firma Rational miała i ona, w tym narzędziu ROSE było kilka metod, jak gdyby włożonych do środka, metoda Butcha, metoda OMT, Jim Arambo.
No i teraz sprawa się zaczęła tutaj jakoś szczęśliwie układać wtedy, kiedy ta firma, której pracował Jim Arambo zatrudniła się do tego, żeby to zrobić.
No i teraz sprawa się zaczęła tutaj jakoś szczęśliwie układać wtedy, kiedy ta firma, której pracował Jim Arambo zatrudniła również Grady'ego Butcha, którego metoda też była dosyć znana i używana przez firmy przy projektowaniu obiektowym systemów.
No i po prostu panowie się musieli dogadać ze sobą.
I jak widzicie Państwo tutaj trochę się dogadali, bo zaproponowali taką metodę zunifikowaną, ale zdawali sobie sprawę z tego, że to trochę jest jeszcze nie do końca, więc mamy wersję poniżej jedynki.
Czasami byli świadomi tego, że to się powinno jakoś tam rozwijać i powinno być doprecyzowane.
Teraz firma Rational zatrudniła trzeciego takiego pana bardzo tutaj znanego, jeśli chodzi o właśnie inżynierię oprogramowania, Iwara Jacobsona, który w swojej metodzie zaproponował tak zwane use cases, przypadki użycia i już wtedy to po włączeniu tego mamy tą wersję zwiększoną, ale jeszcze ciągle poniżej jedynki.
Teraz proszę Państwa ta metoda zunifikowana, na niej pracowały duże firmy software'owe.
To narzędzie Rational było używane przez duże firmy software'owe, Hewleta Packard'a i IBM'a i Microsoft'a i tak dalej.
I firmy, znaczy te pracujące na nich, no gdyby zgłaszały pewne swoje pomysły czy zastrzeżenia, czy to co jeszcze by im było potrzebne, co by chcieli.
No i w ten sposób został utworzony, ale tu już proszę popatrzeć, że to słowo metod zginęło, prawda, metod, dlatego że metoda, no jesteśmy przyzwyczajeni tak z matematyki do tego, co taka metoda znaczy.
Metoda znaczy, że związywania pewnego typu zadań, tak, to jeżeli są spełnione pewne założenia, to ta metoda daje mi taki algorytm postępowania i dostaje wynik, tak, rozwiązania.
W przypadku produkcji systemów.
No to tutaj żadnej gwarancji nie ma, tak, mogą być spełnione pewne założenia, tak, ale tutaj to co robimy, jak działamy zależy od zespołu ludzi, więc trudno tu mówić o metodzie, można tutaj jedynie mówić o pewnym zbiorze, no jakiś tam wskazówek.
Wobec tego usunięto to słowo metoda i włożono słowo language, unified modeling language, czyli taki zunifikowany język modelowania.
Został on zatwierdzony tutaj w tej wersji 1.1.97 roku i od tego momentu, proszę Państwa, ten język jest rozwijany, w tej chwili pracujemy, prawda, na wersji 2 coś, już w ostatnich latach te wersje systemu tak bardzo nie zmieniają tego, znaczy systemu tego języka UME.
No i teraz, proszę Państwa.
Bardzo szybko ten UML wyparł wszystkie te metody, o których Państwu wcześniej po prostu pokazałam, że są, dlatego że do niego zostały włożone najlepsze pomysły z tych metod, które wcześniej były.
A więc właśnie zostało włożone, najwięcej jak gdyby zostało włożone z tej metody OMT, szczególnie jeśli chodzi o symbole notacyjne, ale zostały włożone te use cases Iwara Jakobsona.
Zostało włożone.
Zostały włożone pewne pomysły, które Grady Butch w swojej metodzie proponował, zostały włożone pewne elementy z metody tej Hewletha Packarta, zostały włożone diagramy maszyn stanowych Harela, które też były powszechnie znane i używane przy projektowaniu systemów czasu rzeczywistego i tak dalej.
Czyli właśnie wiele tych dobrych pomysłów z innych metod, nawet niekoniecznie z metod obiektowych.
Te diagramy stanów to nie jest z metod obiektowych, tylko to jest, zostało do tego włożone.
UML błyskawicznie wyparł wszystkie inne metody, czyli jeżeli, więc błyskawicznie się rozpowszechnił, no i w tej chwili już nie mówimy o innych metodach, tylko mówimy o projektowaniu obiektowym właśnie z zastosowaniem, z użyciem UML-a.
Teraz proszę Państwa, jak projektujemy system, właśnie korzystając...
...z UML-a, to widzimy ten projektowany system z takich trzech perspektyw.
Zaczynamy od takiej perspektywy use case, czyli zaczynamy od widzenia pewnych przypadków, sposobów użycia tego systemu.
Teraz tutaj takie, widzicie Państwo taką elipsę i to jest równocześnie symbol graficzny takiego przypadku użycia w UML-u.
Dlaczego?
Dlaczego tutaj go Państwo widzicie?
I ten, to jest określenie tego, co system robi.
Poprzez zdefiniowanie use case'ów, czyli sposobów użycia przykładu tego systemu określamy, co ten system robi.
Od tego zaczynamy, mamy tutaj jedyneczkę.
Teraz proszę Państwa, no mamy system obiektowy, tak?
Czyli musimy określić, co w tym systemie jest, tak?
Co w tym systemie jest, a więc jakie obiekty, tak, w tym systemie są, jak one są ze sobą zorganizowane, jak one ze sobą współpracują.
Bo tutaj musimy również odpowiedzieć na pytanie, jak te funkcje są realizowane, czyli które obiekty ze sobą muszą współpracować...
I w jaki sposób, żeby dostarczyć tych funkcji, które tutaj żeśmy zdefiniowali.
I to jest, proszę Państwa, poziom, gdzie, no, jak gdyby najwięcej wysiłku będziemy musieli włożyć właśnie w to.
Tutaj również będzie model zachowania tych, czyli tu mamy zarówno taki model statyczny, co w tym systemie jest, jak i takie modele dynamiczne, behawioralne.
W jaki sposób te funkcje systemu są realizowane.
Jakie funkcje systemu są dostarczane.
Teraz tutaj mamy również taki poziom implementacyjny, bo tutaj, no, mogą dojść pewne gotowe komponenty do tego naszego systemu, tak?
Biblioteki, tu też musimy pokazać, w jaki sposób one ze sobą, jak to jest zrealizowane, prawda?
Co, jakie mamy moduły, jakie mamy komponenty systemu, jak one ze sobą współpracują.
To jest ten poziom implementacyjny.
I wreszcie mamy poziom fizyczny, czyli na którym musimy określić, no, na przykład, jak wygląda instalacja tego systemu.
Gdzie, co ma być, instalacja.
Jak, gdzie, co ma być zainstalowane.
Jaka część tego oprogramowania, na przykład, ma być po stronie klienta, czy coś tam ma być, czy nie, czy wszystko na serwerze.
Także to jest ten poziom fizyczny.
No i teraz, proszę Państwa.
No i teraz, proszę Państwa.
Będziemy już stopniowo, prawda, przechodzić przez te poszczególne perspektywy użycia systemu.
Tutaj będziemy mieli jeden typ diagramów, diagramy use case.
Tu będzie wiele różnych diagramów.
Diagramy class, diagramy sekwencji, diagramy maszyn stanowych.
Tutaj na poziomie implementacyjnym będą diagramy komponentów, na przykład.
I tak zwany deployment diagram, diagram instalacyjny.
Świetnie.
Także tutaj z fundusza,oso ob theorys indywidualnie,
Sprawy sprzętu są generalnie bezwinulentne.
Taułansy są też stealth equivalent.
To znaczy, że ruch,dy formuły, roboty, czy jeżeli takie rzeczy gwiazdowe,
to, jakby tanie zmieni birkę w.\
Czyli przecież nie jest ze wszystkom to samo, po prostu,
zaafekscytuje się jako doktor.
Zwarunkowe�, czyli…
Ś Signal ze算ć jest w tym samym czasie.
Tak.
To na przykład.
D Services.
Klassika.
co system robi. I to jest, proszę Państwa, takie widzenie tego systemu
z punktu widzenia użytkownika. Ważne jest, żebyśmy na tym etapie
od razu widzieli różne typy użytkowników tego systemu.
Czyli tutaj będziemy projektować, modelować zachowanie tego systemu
w odpowiedzi na pewne żądania przychodzące od użytkownika.
Będziemy tutaj rysować diagramy use case, będziemy te use case opisywać,
jak gdyby definiować pewną sekwencję kroków, która wewnątrz tego use case'a ma miejsce.
I tutaj również jak gdyby na tym etapie mogą być przygotowane testy
pod kątem właśnie spełnienia wymagań funkcjonalnych tego systemu,
czyli takie testy akceptacyjne.
Teraz jeśli chodzi o model logiczny,
to tu jest, tak jak Państwu mówiłam, najwięcej się napracujemy,
bo tu musimy określić, co w tym systemie jest,
czyli właśnie jakie są klasy, jakie są związki pomiędzy nimi.
Musimy tutaj zaprojektować zachowania obiektów poszczególnych tych klas.
Musimy tutaj określić sekwencję działań.
I tutaj mamy różne typy diagramów,
diagramy klas, obiektów.
Diagramy integracji, diagramy tak zwane collaboration,
diagramy współpracy, diagramy maszyn stanowych.
Czyli właśnie co ten system robi, tutaj będziemy określić,
jak ten system działa i co w tym systemie jest,
żeby te use case'y dało się zrealizować.
Model implementacyjny, to tutaj widzimy, proszę Państwa,
właśnie tu jest jeden typ diagramów, diagram komponentów.
Można powiedzieć, że tutaj jest projekt architektury tego systemu określony
i model wdrożeniowy, tak zwany deployment diagram.
To jest, tak jak Państwu mówiłam, taki model, gdzie określamy,
gdzie instalujemy poszczególne moduły tego oprogramowania.
Diagramy rozmieszczenia, to się nazywa czy deployment diagram.
Dobrze, to teraz.
Dobrze.
No i otworzę teraz prezentację modeli.
Jest tu pewne rzeczy,
nam się trochę zainteresowało,
i jest tu pewne rzeczy, nam się trochę zainteresowało,
powtórzą, także niektóre przeskoczę, a więc jest proszę Państwa dosyć dobra
książka przetłumaczona na język polski Alistera Cockberna, jak pisać
efektywne przypadki użycia, która może się przydać wtedy, kiedy rzeczywiście
chcemy system taki obiektowy projektować i będziemy oczywiście zaczynać
od tego modelu use case. Przed chwileczką już mówiłam Państwu,
że to jest model use case określa co system robi, że na tym etapie musimy
tutaj określić różne użytkowników tego systemu i za pomocą właśnie
diagramów use case. Tych diagramów, one też mogą mieć różną organizację,
różną strukturę, mogą być w postaci takiej hierarchicznej robione,
mogą być robione diagramy z punktu widzenia poszczególnych klas,
tego systemu.
Użytkownika systemu.
O tym modelu logicznym to już mówimy, bo to będziemy mówić dalej.
No i teraz przechodzimy właśnie do tego use case'a. Wiecie Państwo już,
bo to pokazywałam, że symbolem graficznym takiego use case'a jest taka elipsa,
czy takie jajo.
I jak gdyby nazwa tego use case'a określa funkcję, określa pewne zachowanie systemu,
które jest z punktu widzenia użytkownika na ogół jakoś tam pożądane.
Teraz to tak jak Państwu mówiłam, my z tą elipsą wiążemy pewną nazwę tej funkcji.
Czyli zwykle...
Jest to jakiś czasownik.
Ale musimy również tutaj troszkę to opisać.
Więc potem tego use case'a, czyli właśnie tą jakby funkcję udostępnianą na zewnątrz systemu.
Przepraszam.
Nie widzimy prezentacji.
O, przepraszam. Dobrze, dzięki za...
Ups.
Dobra, teraz coś widać?
Tak.
Ok.
Dobra, no to myślę, że ten początek to był tam...
To o tym już mówiłam przed chwileczką.
No.
Właśnie.
Use case, symbol graficzny w postaci takiej elipsy,
to jest pewne zachowanie systemu, czy to jest jak gdyby coś co dla tego użytkownika systemu,
którym może być również inny system, niekoniecznie człowiek.
Jest istotny, jest potrzebny.
Natomiast oczywiście z tą nazwą wiąże się...
Żeby to zrealizować, to system musi wykonać no pewne...
Pewien ciąg akcji, tak?
Które spowodują, że ta funkcja jest realizowana.
Można powiedzieć, że taki use case to jest pewna funkcja,
czyli to jest wymaganie funkcjonalne, które ten system realizuje.
Teraz, proszę Państwa, jak zajmujemy się właśnie tutaj tym modelem use case,
to istotne jest, żebyśmy się...
żebyśmy się skoncentrowali na tym, co ten system robi.
Na tym etapie nie martwimy się, w jaki sposób to będzie zrealizowane,
tylko tutaj, co ten system ma zrealizować.
No i mówiłam Państwu, że to zaczyna się od tworzenia takich diagramów use case,
które mają następujące elementy, czyli po pierwsze jest to aktor,
ktoś lub coś, co inicjuje tę funkcję, wywołuje tę funkcję,
lub ktoś coś, co dostarcza danych, odbiera dane z systemu.
Mamy ten przypadek użycia, czyli to wymaganie funkcjonalne,
tę funkcję w postaci tej elipsy i będziemy mieli tutaj różne rodzaje asocjacji
aktor z przypadkiem użycia i będziemy mieli,
również zależności, zależności pomiędzy przypadkami użycia.
Co to jest, czy kto to jest ten aktor?
No właśnie, czyli po pierwsze może być to użytkownik tego systemu w postaci osoby,
ale mogą być to, proszę Państwa, również systemy zewnętrzne.
Przed chwilą mówiłam, jako przykład podałam taki system prognozowania pogody.
Wtedy na przykład te mierniki, tak?
Temperatury, ciśnienia i tak dalej, to są jakieś urządzenia zewnętrzne,
czyli jakieś systemy zewnętrzne, które dostarczają lub odbierają danych z systemu.
No właśnie, bo taki aktor to jest ktoś lub coś, co korzysta z tego systemu,
co być może dostarcza lub odbiera pewne dane do tego,
odbiera dane z systemu, czy dostarcza dane do systemu.
Ale to jest również, proszę Państwa,
no na przykład administrator jest takim typem aktora,
który na pewno jest potrzebny do realizacji tego systemu, do działania tego systemu.
Teraz, proszę Państwa, proszę popatrzeć tutaj na definicję aktora.
Aktora jest to, tak jak tutaj widzicie Państwo,
na napędzająca przypadki użycia, sprawca zdarzeń,
powodujących uruchomienie pewnego przypadku użycia,
odbiorca danych wyprodukowanych przez właśnie system, przez przypadki użycia.
Czyli osoba, organizacja, inny system.
Istotne jest, że takim aktorem jest grupa osób pełniących pewną rolę,
a nie konkretna osoba.
Czyli na przykład, jeżeli mówimy o takim systemie typu UBI,
tak, to właśnie...
Takim aktorem będzie student, a nie student Jan Kowalski.
Czyli grupa osób, która pełni pewną określoną rolę.
Popatrzcie Państwo na taki prościuteńki przykład diagramu Józkejs.
I przy okazji właśnie symbole graficzne.
Symbol graficzny aktora to jest taki ludzik z takich kreseczek zbudowany, tak?
Czasem w systemach takich case'owych, w których projektujemy ten system,
czasem te ludziki mają troszkę grubsze rączki i nóżki.
I właśnie Józkejs, który jest w postaci takiej elipsy.
Mamy tutaj relacje, asocjacje łączące aktora z określonymi Józkejsami.
Czyli na przykład chcemy zrobić system dla biblioteki,
definiujemy, że z tego systemu będzie korzystał na przykład czytelnik,
ale również bibliotekarz.
A może za chwilę jeszcze dodamy jakiegoś innego aktora,
typu na przykład administrator tego systemu.
Ale powiedzmy na razie widzimy tylko tych dwóch.
I zastanawiamy się, w jaki sposób ten czytelnik może z tego systemu bibliotecznego,
korzystać.
No na przykład może zamawiać coś, może wypożyczać coś, może zwracać coś,
może coś jeszcze więcej, rezerwować.
No i teraz na przykład te same funkcje widzimy, że ma bibliotekarz.
Ale może jeszcze potem stwierdzimy, że bibliotekarz jeszcze powinien mieć
jakieś dodatkowe funkcje, które dla czytelnika były niedostępne.
Jakiś pomysł na taką funkcję? Ktoś z Państwa ma?
Co by mógł jeszcze, jaka funkcja jest potrzebna bibliotekarzowi w takim systemie?
Zmienia lokalizację książek na przykład?
Nie, nie, nie. Bo to nie chodzi o fizyczne, tylko to chodzi o...
My tutaj projektujemy system informatyczny dla biblioteki.
Tak to trzeba widzieć.
Czyli co taki bibliotekarz w takim systemie bibliotecznym powinien mieć?
Jakie możliwości?
Książki.
Tak, książki, ale co z tymi książkami robić?
Dodawanie nowych tytułów?
Super, dodać, dodać nowy tytuł.
Ewentualnie się coś, prawda...
Jeżeli dodać, to też usunąć.
Dobrze, bardzo dobrze, usunąć.
Jak idziemy dalej w tym kierunku, no to pewnie powiemy tak,
no pewnie nie dla wszystkich ta biblioteka jest dostępna,
więc byśmy dodali funkcję typu, nie wiem,
dodaj użytkownika, usuń użytkownika i tak dalej.
Dobra, no więc super, widzę, że Państwo jakoś zaczynacie tutaj
aktywnie uczestniczyć.
Proszę Państwa, co robimy właśnie na tym etapie?
No musimy, już o inżynierii wymagań trochę mówiłam,
więc jak gdyby mamy te rzeczy już wykonane,
wiemy mniej więcej, wiemy co ten system powinien zrobić,
jakoś troszkę się tu orientujemy,
już w dziedzinie problemu musimy mieć zdefiniowane,
kto z tego systemu będzie korzystał i co danemu użytkownikowi jest potrzebne,
prawda, czyli tak jak przed chwileczką, żeśmy w tym systemie bibliotecznym tam stwierdzili,
że bibliotekarz powinien mieć pewne funkcje jeszcze dodatkowe.
Czasem się tutaj przeprowadza modelowanie procesów biznesowych,
żeby widzieć, jak pewne rzeczy w systemie się dzieją, musimy określić,
skąd dane pochodzą, tak, no musimy mieć pewną wizję tego systemu.
Teraz, proszę Państwa, no te use case'y możemy również,
no żeby ten system był bardziej czytelny,
taki możemy wprowadzać strukturalizację use case'ów,
a więc może być sytuacja taka, że pewien use case jest takim use case'em bardzo ogólnym
i mamy pewne use case'y, które są jego specjalizacjami,
czyli możemy mieć tutaj generalizację pomiędzy use case'ami.
Teraz może być sytuacja taka, że mamy jakiś use case,
który jest włączony w przebieg innego use case'a
i będziemy tutaj korzystać, w UML-u mamy pojęcie tak zwanych stereotypów.
Stereotypy to jest takie coś, co jest tutaj takimi,
nawiasami kątowymi, podwójnymi z przodu i z tyłu otoczone
i w środku mamy pewne słowo, które określa ten stereotyp.
Pewna liczba takich stereotypów jest predefiniowana w UML-u,
na przykład właśnie te, których tutaj używam w use case'ach,
takie jak include, za chwileczkę pokażę następny.
Natomiast ciekawą sprawą jest, że można w trakcie realizacji projektu,
na potrzeby danego projektu, można definiować,
ustalać swoje własne stereotypy.
No i właśnie jeszcze jeden taki stereotyp,
który tutaj pozwala nam na pewne określenie,
pewnej zależności pomiędzy use case'ami,
bo to jest określenie zależności pomiędzy use case'ami,
to jest stereotyp extend.
Czyli możemy mieć pewien przykład użycia,
który rozszerza zachowanie innego.
Za chwileczkę jakieś przykłady Państwu pokażę,
może będzie to bardziej oczywiste czy bardziej zrozumiałe.
I teraz, proszę Państwa, mamy właśnie znowu symbole notacyjne.
Przypominam, UML jest standardem ogólnoświatowym
i to, że ja tutaj pokazuję takie, a nie inne strzałki,
to nie wynika z tego, że one mnie się podobają,
tylko że tak jest to określone w UML-u.
Czyli po pierwsze,
linia przerywana, którą stosujemy w UML-u
przy określaniu pewnych związków
pomiędzy różnymi elementami projektu,
to się nazywa tak zwana dependency line.
I teraz to dependency line może być skierowane,
tak jak tutaj Państwo widzicie,
co oznacza właśnie kierunek tej zależności.
Jeżeli mamy po prostu linię skierowaną,
przerywaną, nieskierowaną,
to to oznacza, że ta zależność jest dwukierunkowa,
czyli zarówno to coś, które jest po tej stronie,
jak i to coś, co jest po tej stronie,
tak, że to jest zależne od tego,
a to jest zależne od tego, że ta zależność jest dwukierunkowa.
Tutaj określa kierunek tej zależności.
Teraz mówiłam Państwu o tym,
że w tych projektach obiektowych
to dziedziczenie jest takie istotne,
dziedziczenie inaczej, generalizacja.
I tu, proszę Państwa, symbol graficzny jest taki,
że mamy taki gruby, otwarty grot strzałki.
Ona jest niewypełniona w środku, tak,
czyli taki trójkącik wyraźny.
I ten trójkącik wskazuje na coś, co jest ogólnego,
czyli tu mamy coś, co jest ogólnego,
a po tej stronie mamy specjalizację tego czegoś ogólnego.
No i teraz, proszę Państwa,
tutaj mamy asocjację,
która jest w postaci linii ciągłej.
Modelujemy ją i albo asocjacja,
czyli pewne powiązanie, może być skierowane,
wtedy określamy kierunek tego skierowania,
albo może być, tutaj nie mamy żadnych strzałek
i to oznacza, że ta asocjacja,
że to powiązanie jest dwukierunkowe.
Czyli możecie sobie Państwo wyobrazić,
że ta asocjacja to jest jak gdyby taki kanał komunikacyjny
pomiędzy czymś, co jest tu i czymś, co jest tu.
I teraz, jak jest dwukierunkowa,
to znaczy, że ta komunikacja może iść w jedną stronę
i w drugą stronę, jak jest skierowana,
to tylko w jedną stronę może być coś przesyłane, przekazywane.
Jakieś pytania może do tego Państwo macie?
Proszę Państwa, teraz proszę Państwa ten use case,
tak jak Państwu mówiłam,
no to jest to pewna nazwa pewnej funkcji, prawda?
Często jest to pewna czynność,
którą aktor w tym systemie może wykonać,
więc tak jak Państwu mówiłam,
sugerowałam, że dobrze jest używać czasowników,
ale my musimy potem to opisać trochę dokładniej,
więc musimy opisać pewną sekwencję zdarzeń.
Jak to się rozpoczyna, jakie mamy zdarzenia,
jak się kończy, kiedy są te,
czy są jakieś interakcje z aktorem
i kiedy one się kończą.
I teraz, czyli ten przypadek użycia musimy opisać,
przygotować jego scenariusz, jego przebieg.
I albo stosuje się tu po prostu tekst nieformalny,
często w tym tekście mamy takie elementy pseudokodu,
po to, żeby pewne rzeczy po prostu były bardziej precyzyjnie opisane
niż w języku naturalnym.
Są różne formaty takiego opisu przypadków użycia.
Tu Państwo widzicie taki przykład,
czyli właśnie mamy nazwę, jakieś wyrażenie czasownikowe,
kontekst użycia, jaki jest cel, jakie są normalne warunki,
wystąpienia, zakres i poziom,
dlatego że no właśnie w złożonych systemach
to prawda, możemy mieć te use case'y na równych poziomach.
Kto jest aktorem głównym, czy co jest aktorem głównym,
jaką rolę on pełni.
Pozostali aktorzy i udziałowcy,
dlatego że czasem jest tak, że w przebiegu tego use case'a
uczestniczą on jest inicjator,
jest inicjowany przez aktora głównego,
ale żeby go wykonać to jacyś inni aktorzy być może muszą w tym uczestniczyć
i stąd to są tak zwani aktorzy wspierający.
Mamy tutaj również możliwość określenia wyzwalaczy,
czyli zdarzenia, które powoduje rozpoczęcie takiego przypadku użycia.
Określamy warunki początkowe,
co powinno być jak gdyby na początku działania tego,
jakie warunki końcowe,
jakie warunki będą spełnione po pomyślnym wykonaniu takiego głównego scenariusza.
Minimalne gwarancje na końcu każdego.
I teraz proszę Państwa mówiłam o scenariuszu przebiegu takiego przypadku.
Zwykle takich scenariuszy jest kilka.
Zaczynamy od głównego, takiego podstawowego scenariusza,
ale takiego, kiedy wszystko jest ok,
wszystko się udaje, wszystko jest dostępne.
Te scenariusze opisuje się w krokach, czyli podaje się w krokach.
Jeden to i to, dwa to i to.
I zaczynamy od takiego scenariusza, kiedy wszystko się tutaj udaje,
czyli na przykład użytkownik loguje się do systemu,
podaje tam swoje hasło i to hasło jest trafione i dalej tam idzie.
Teraz możemy, podajemy również i projektujemy proszę Państwa przepływy alternatywne.
Czyli na przykład w pewnym miejscu mamy powiedzmy to podanie tego hasła jakiegoś,
albo nie wiem, wyszukanie czegoś i na przykład wyszukanie książki
i to wyszukanie się nie uda.
I co wtedy?
Czyli jak gdyby pokazujemy tutaj sytuację, kiedy czegoś nie ma jakiejś informacji,
coś się nie uda i określamy co się wtedy ma dziać w systemie,
jak on ma się zachowywać.
No i możemy tutaj podawać pewne punkty rozszerzeń,
czyli właśnie takie warianty przebiegu tego use case'a.
Popatrzcie Państwo tutaj na taki właśnie przykładowy scenariusz.
I to jest taki scenariusz główny, kiedy wszystko się udaje,
no właśnie w takim systemie bibliotecznym na przykład,
kiedy chcemy sobie zamówić książkę.
Widzicie Państwo tutaj ten opis jest taki dosyć ogólny.
System prezentuje ekran, czytelnik wprowadza dane,
system przeszukuje ekran, wyświetla listę, przegląda, wybiera i tak dalej.
Czytelnika tutaj napisałam czerwoną czcionką.
Dlaczego? Jak Państwo myślicie?
Co to jest ten czytelnik, czy kto to jest ten czytelnik,
który tutaj jest na czerwono pokazany?
Aktor główny?
Tak, tak, jest to aktor.
I ma Pan rację, jest to aktor główny.
Teraz, proszę Państwa, również definiujemy takie scenariusze,
alternatywne.
Czyli na przykład pierwsze osiem kroków,
tak jak w tym scenariuszu głównym,
ale system nie dopuścił tutaj,
tą autoryzacja nie wykonała się pozytywnie,
no i wracamy i tutaj określamy, co ma być robione.
Albo na przykład nie ma takiej wolnej książki,
którą byśmy chcieli,
czyli pierwsze pięć kroków, jak w scenariuszu głównym,
krok szósty brakuje wolnej książki,
czytelnik zapisuje się do kolejki
i teraz tutaj na przykład, żeby się zapisać do tej kolejki,
to trzeba wiedzieć, kogo zapisać,
więc znowu mamy takie kroki, jak już wcześniej widzieliśmy,
wprowadza nazwę, hasło, autoryzuje,
potwierdza zapisanie do kolejki.
Więc w postaci właśnie takich scenariuszy
będziemy opisywać to use case.
Jakieś pytania może coś Państwo macie,
jakieś swoje obserwacje, komentarze?
Jeśli nie, to teraz przejdę, proszę Państwa,
mówiłam, że te use case można strukturalizować.
No i powiedziałam Państwu,
pierwsza z możliwości,
to jest właśnie za pomocą generalizacji,
widzicie Państwo, tu mamy właśnie taką strzałkę,
strzałkę z takim dużym, otwartym grotem,
która mówi, że jest to,
ten trójkącik pokazuje na use case,
który jest use casem ogólnym,
zamawia, jest takim use casem ogólnym,
a to są jakoś jego specjalizacje,
że zamawia przez internet, osobiście lub przez telefon.
No i tutaj mamy różnych aktorów,
klient telefoniczny, internetowy,
czy taki zwykły klient, który, prawda,
przyszedł do biblioteki.
Bardzo często właśnie w przypadku takiej generalizacji use case'ów
mamy różnych aktorów.
Proszę Państwa, tu jest jakiś kolejny przykład
generalizacji obsługa zlecenia przez maklera
i ta obsługa zlecenia też może mieć
jak gdyby różne wersje w zależności od tego,
jaki jest tutaj klient.
Proszę Państwa,
to jest często, czyli mamy pewien ogólny schemat
i mamy pewne jego realizacje specjalne takie.
Mamy zazwyczaj tutaj różnych aktorów.
No i popatrzmy, jak by to mogło wyglądać.
Mamy pewne kroki takie tego zlecenia,
takiego ogólnego,
a teraz mamy tutaj kroki tego,
pierwszego na przykład w zależności od tego,
czy jest to, jeśli to jest zlecenie telefoniczne.
No tutaj mamy pokazane kroki tego zlecenia telefonicznego
i podobnie robimy dla następnych.
I tutaj od razu Państwu powiem,
że w praktyce bardzo rzadko stosuje się
tą generalizację use case'ów.
Jest ona w UML-u, jest dostępna,
ale w praktyce się ją stosuje rzadko.
Częściej stosujemy rozszerzenie, czyli extend,
bo właśnie tym możemy podobne,
jak gdyby podobne rzeczy uzyskać.
Mianowicie mamy zależność pomiędzy dwoma use case'ami
za pomocą określoną, za pomocą stereotypu,
czyli mamy pewien typowy schemat przebiegu use case'a
i ewentualnie w pewnym kroku mogą wejść
jakieś dodatkowe czynności,
może wejść taka specjalizacja,
określa się te punkty, w którym to rozszerzenie może wejść.
To jest proszę Państwa w przypadku,
nie ma wtedy dostępnych odrębnych aktorów,
ten przykład użycia podstawowy jest właśnie
udostępniony aktorowi.
Te, które są extend, są takimi use case'ami wewnętrznymi
i pokazują one pewne warianty przebiegu,
pewne opcje przebiegu.
Właśnie, warto zapamiętać, że jest to wariant,
czy jest to pewnego rodzaju opcja.
Popatrzmy znowu na jakiś przykład.
A więc mamy tutaj dwóch aktorów,
klient i sieć.
Połączenia na przykład takie powiedzmy telefoniczne,
klient ma dostępną funkcję połącz lub odbierz połączenie
i teraz może być to odbierz, ten use case odbierz,
może być proszę Państwa rozszerzony przez
odbierz dodatkowe połączenie,
czyli na przykład w trakcie odbierania jakiegoś
pojawia się kolejne i co z tym zrobić.
Proszę zwrócić uwagę, jest to inna linia,
jest to linia przerywana
i strzałka pokazuje na ten use case,
który jest dostępny dla użytkownika,
a to jest pewien jego wariant przebiegu,
pewna opcja przebiegu, pewne rozszerzenie.
Tutaj proszę Państwa w przypadku tego prostego przykładu
chcę zwrócić uwagę Państwa również,
że tym aktorem niekoniecznie jest użytkownik systemu,
tutaj mamy tą sieć połączeń w ten sposób zamodelowaną jako aktora
i proszę popatrzeć, że ta sieć jest połączona do tego odbierz,
czyli aktor odbiera połączenie,
ale żeby mógł to zrobić,
to mamy tak zwanego aktora wspierającego,
którym jest ta sieć.
To jest aktor, który jest potrzebny do realizacji tego use case.
Bez tej sieci nie da się zrobić tego połączenia.
To samo mamy tutaj w przypadku tego połączeń.
A więc przy okazji właśnie pojęcie takiego aktora głównego
i aktora wspierającego, który jest potrzebny,
żeby zrealizować,
pewien use case.
Bez niego by się to nie udało.
No i popatrzmy na jakiś kolejny przykład
takiej zależności ze stereotypem extend,
czyli na przykład właśnie mamy pewien typowy schemat,
ale być może mamy pewne opcje,
pewne warianty przebiegu,
tego use case.
Na przykład w tym naszym systemie bibliotecznym,
powiedzmy wyobrażamy sobie takie funkcje,
że przeglądamy swoje własne konto,
patrzymy jakie zamówienia żeśmy złożyli w bibliotece
i na przykład widzimy,
że pewne rzeczy już są nieaktualne,
bo na przykład zamówiliśmy jakąś książkę,
a już ten sprawdzian się odbył,
ta książka nie będzie nam już potrzebna,
więc możemy skasować zamówienie,
które żeśmy złożyli,
bo stwierdzamy już jest nieaktualne,
nie chcemy tego.
Czyli tutaj w przebieg tego przeglądania konta
włączamy pewną funkcję,
pewien wariant,
pewną opcję przebiegu,
skasowanie zamówień.
Proszę zwrócić uwagę również na to,
że ten włączany przebieg,
ten przebieg podstawowy,
ten use case włączany,
on nie jest dostępny na zewnątrz.
Podobnie było w tym poprzednim, prawda?
To nie są dostępne na zewnątrz funkcje,
tylko właśnie jest to pewien,
na ogół tak robimy,
że jest to pewien wariant przebiegu
tego use case podstawowego.
No i teraz proszę popatrzeć,
jak to by w takim scenariuszu wyglądało,
czyli mamy use case,
przeglądanie konta
i przygotowujemy scenariusz jego przebiegu.
Właśnie wybieramy opcję przeglądania konta,
logowanie, nazwę, hasło,
wyświetla stan konta
i tu proszę popatrzeć,
tu mamy ten punkt rozszerzenia.
W punkcie rozszerzenia
wstawiamy to skasowanie zamówienia.
Więc mamy wyraźnie tutaj w tym scenariuszu
pokazane, w którym kroku
to rozszerzenie, ten wariant
może mieć miejsce.
Czy może jakieś pytania mają Państwo do tego?
Drugi typ zależności,
bardzo często stosowany,
to jest, proszę Państwa,
zawieranie, czyli include.
A więc pewien przykład użycia
włącza zachowanie innego.
I tutaj również podobnie,
jak było w tym extend,
ten inkludowany, ten włączany przykład
nie może być samodzielny,
nie jest widziany na zewnątrz systemu.
Kiedy to stosujemy?
Na przykład wtedy, kiedy widzimy,
że pewna sekwencja czynności,
będzie wykonana w wielu use case'ach,
to możemy taki wspólny fragment wyodrębnić,
pewien fragment wspólny.
Lub chcemy wyciągnąć do takiego wyodrębnionego
przypadku użycia właśnie coś,
co nam jest potrzebne.
Też nie ma tu odrębnych aktorów,
ten włączany na ogół nie jest use case,
samodzielnym, a na pewno nie jest
takim use case'em dostępnym
dla zwykłych użytkowników.
Czasem jest udostępniany administratorowi systemu.
No i znowu wróćmy do tego
naszego prostego systemu bibliotecznego.
Mamy czytelnika, który może zamawiać,
czy może wypożyczać w tym naszym systemie.
Obie te czynności wymagają,
żeby był to czytelnik znany w danej bibliotece.
Czyli włączamy tutaj use case,
który się nazywa autoryzuje.
Właśnie za pomocą tego include'u.
Proszę popatrzeć na teraz kierunek tych strzałek.
W extendzie była strzałka skierowana
w przypadku tego use case'a podstawowego.
Bo strzałka pokazuje, co jest rozszerzane.
A tutaj strzałka pokazuje, co włączamy.
Include, włączać.
Przebieg zamawia, włączamy.
Autoryzuje.
No i popatrzmy, jakby to wyglądało
właśnie w sekwencji.
W takiej sekwencji kroków.
Mamy krok siódmy.
Wykonaj autoryzację czytelnika.
I pokazane jest tutaj,
jak ten use case wygląda.
Jakie ma kroki swojego przebiegu.
Proszę Państwa,
teraz jeszcze chcę powiedzieć
o bardzo takiej istotnej możliwości.
Mianowicie o,
teraz możemy również określać
relacje pomiędzy aktorami w systemie.
I to pomiędzy aktorami w systemie
używamy generalizacji ewentualnie.
Proszę popatrzeć teraz tutaj na taki,
no też ten system biblioteczny,
gdzie mamy czytelnika,
mamy bibliotekarza.
Czytelnik może wypożyczać, zwracać.
Przed chwileczką pokazywałam Państwu,
że bibliotekarz też może
takie funkcje wykonywać, tak.
Albo być może bibliotekarz jest potrzebny,
żeby te funkcje wykonać, tak.
Że on jest być może aktorem wspierającym.
Ale w każdym razie, no jakoś ma też
dostęp do tych use case'ów,
wypożycza i zwraca.
To możemy powiedzieć, no ten czytelnik, tak,
ma te funkcje, tak.
I tutaj za pomocą generalizacji
pokazujemy generalizację.
Ten jest ogólny, ten jest jego wersją
specjalizowaną. Możemy powiedzieć,
bibliotekarz dziedziczy te możliwości,
które ma czytelnik.
Czyli też ma dostęp do use case'a,
wypożycza, zwraca. A tu definiujemy
jego dodatkowe możliwości.
Czyli właśnie na przykład to,
o których mówiliśmy, wprowadza czytelnika,
czy na przykład, prawda, wprowadza książki
i tak dalej.
Jakieś pytania do tej relacji?
Może coś Państwo macie?
I to jest, proszę Państwa,
też taka typowa relacja.
Czyli mamy takiego aktora,
no takiego typowego użytkownika systemu, tak.
I mamy kogoś, kto więcej może w tym systemie.
Czy to jest bibliotekarz,
czy to jest administrator systemu.
To właśnie ta relacja,
ta relacja generalizacji.
Czy może w jakimś systemie takim
dla, nie wiem, sklepu jakiegoś
mamy klienta i mamy właściciela
tego sklepu.
Popatrzcie, proszę Państwa,
też na kolejny taki przykład
jakiegoś use case'a.
Teraz, proszę Państwa,
tutaj te use case'y są wewnątrz
takiego prostokątu narysowane,
bo tak często się robi.
W ten sposób się czasem
po prostu zaznacza granice systemu.
Aktor, jak widać, jest zawsze
na zewnątrz tego systemu,
a tutaj pokazujemy, jakie funkcje
są dostępne w tym systemie.
I to jest,
widzimy, że mogą być to
zarówno klient, administrator systemu,
tutaj widzicie Państwo,
jest relacja dziedziczenia.
Mogą być to jakieś systemy zewnętrzne,
które też uczestniczą w tym naszym,
czy w przebiegu use case'ów
naszego systemu.
I mamy właśnie często
z przebiegu use case'ów
w tym naszym systemie wyciągamy
pewne wspólne przebiegi.
Takie jak autoryzacja,
jak logowanie,
jak weryfikacja czegoś.
I to jest takie typowe użycie
tej zależności include.
Inne typowe użycie zależności
ze stereotypem include,
to jest to, które tutaj Państwo widzicie
na tym przykładzie.
A więc zarówno, powiedzmy,
rezerwowanie jakiejś pozycji w bibliotece,
zwracanie, wypożyczanie,
wyliczanie tej pozycji
wymaga pewnych zmian w tej bazie,
na przykład w bazie książek
w tej bibliotece.
Wobec tego właśnie tą modyfikację
tej bazy wyłączamy
jako taki use case wspólny.
Jak widać, to na pewno nie jest
dostępne dla klienta,
ale te zwracanie zmienia stan
tej pozycji na dostępny.
Rezerwowanie, też coś tu się dzieje,
wypożyczanie, też się coś tutaj dzieje.
I taki, proszę Państwa, use case,
jest use casem, tak jak Państwu ten
inkludowany jest use casem wewnętrznym,
ale mogą być sytuacje,
i tutaj akurat taka sytuacja
może mieć miejsce,
kiedy ja mam tutaj aktora,
którym jest administrator,
i takiemu administratorowi
ja na przykład mogę pozwolić na to,
żeby on miał bezpośredni dostęp
do tej bazy, tak?
Żeby on tutaj mógł ewentualnie
coś poprawić, zmienić.
Proszę Państwa, jest czas na przerwę.
Ja mam dosłownie jeszcze parę minut,
więc prosiłabym, żebyśmy jeszcze Państwo
chwilkę wytrzymali.
Skończę tę prezentację
i wtedy zrobimy przerwę normalnej długości.
Pełne takie podsumowanie tego, co mówiłam.
A więc, proszę Państwa, tak.
Zaczynamy od identyfikacji aktorów.
Od tego, co każdemu z tych aktorów
wolno zrobić, tak?
Przygotowujemy scenariusze takie główne,
takie scenariusze powodzenia,
kiedy wszystko się udaje.
Teraz zastanawiamy się nad
jakimiś możliwościami niepowodzenia
i przygotowujemy scenariusze alternatywne.
Zastanawiamy się tutaj
nad możliwymi rozszerzeniami.
No, właśnie na przykład nad tą obsługą błędów.
Czy też szukamy jakichś wspólnych przebiegów
i wyciągamy te wspólne przebiegi.
Teraz, proszę Państwa, jakie są wady i zalety
stosowania tych przypadków użycia.
Zaleta. Proszę Państwa, jest to bardzo łatwy
do odczytania typ diagnozy.
Mamy wymagania funkcjonalne w ten sposób przedstawione.
Widzimy również, kto w tym systemie może pracować
i co może w tym systemie zrobić,
więc jest to bardzo łatwe do odczytania.
Natomiast, proszę Państwa, nie mamy tutaj możliwości
pokazania jakichś wymagań niefunkcjonalnych.
Natomiast, tak jak widzieliście Państwo,
ten model use case zahacza o wszystkie perspektywy
tworzenia tego systemu, ale jak gdyby nie tworzymy systemu
przez poszczególne przypadki użycia,
tylko najpierw tworzymy całe to, co w tym systemie ma być,
a potem określamy, jak one muszą ze sobą współpracować,
żeby te funkcje dostarczyć.
Bo właśnie, jest to pewne, wymagane zachowanie systemu.
Jest to również model kontekstowy.
Tutaj widzieliście Państwo na takim jednym z tych diagramów use case,
pokazywałam Państwu tych aktorów, którzy są na zewnątrz systemu,
a więc właśnie jest ten kontekst systemu.
Zaczynamy, jeszcze raz podkreślam, od identyfikacji aktorów,
od tego, jakie zadania ten aktor ma wykonać.
Pamiętamy o takich zadaniach typowych,
jak wprowadzanie danych,
identyfikowanie danych,
czy utrzymywanie systemu.
I, proszę Państwa, musimy ten model uporządkować.
Czyli właśnie, widzimy, że pewne funkcje są wspólne dla określonych aktorów,
no to zróbmy generalizację.
Możemy tutaj szukać pewnych wspólnych przebiegów
i wtedy wyciągać je i mieć to inkludowane, jakieś use case.
Czy możemy mieć pewne warianty przebiegu, opcje?
Wtedy te rozszerzenia.
No i dokumentacja tego modelu.
Teraz, proszę Państwa, nie mamy tutaj na tym etapie projektowania.
Nie widzimy tutaj nic, jeśli chodzi o strukturę tego systemu.
Nie widzimy tutaj żadnych struktur danych.
Nie wiemy, czy coś się będzie odbywać równolegle, czy sekwencyjnie.
I bardzo ważna rzecz.
Nie widać tutaj na tym diagramie, w jakiej kolejności te use case mogą być wykonywane.
Jeżeli one muszą być wykonywane w określonej kolejności,
to to będziemy musieli realizować w modelu logicznym.
Czyli tu wycofam się do tego modelu bibliotecznego.
No więc tutaj jakaś kolejność to by była taka,
że najpierw coś rezerwujemy, tak?
Potem wypożyczamy, a potem zwracamy.
Ale proszę popatrzeć, na tym diagramie use case
my tylko mówimy, co ten może, tak?
Natomiast nie określamy tego, w jakiej kolejności to ma być robione.
Pewne rzeczy możemy wprowadzić, pewne informacje w tym opisie tych use case'ów, tak?
Że najpierw powinno być to czy tamto.
Ale to, żeby to się odbywało w takiej, a nie w innej kolejności,
przez nas określonej, to to będzie zadanie modelu logicznego,
a nie diagramu use case.
Czyli jeszcze raz bardzo istotna rzecz,
nie ma tutaj kolejności, nie widzimy tutaj,
w jakiej kolejności te use case'y mogą być wykonywane.
No i jeszcze kolejny przykład właśnie taki pokazujący właśnie
różne use case'y różnych typów, różne typy aktorów,
którzy mogą w tym uczestniczyć.
Relacja włączania, czyli na przykład chcemy śledzić pewne rzeczy
związane ze sprzedażą, tak?
Dane na przykład w jakich godzinach, kiedy.
No to możemy takie rzeczy włączać.
Tutaj też, proszę Państwa, na przykład mamy jakiś system taki
dla jakiejś kliniki realizowany, co może pacjent,
może na przykład poprosić o wizytę, tak?
Poprosić o jakieś tam, nie wiem, recepty czy leki,
może płacić, tak?
Może skasować zamówione spotkanie.
Tutaj widzimy taką właśnie zależność inkludowaną,
żeby na przykład określona recepta mogła być wypisana,
to lekarz musi, ten request medication uczestniczy w tym,
lekarz, ale on musi sprawdzić, tutaj zajrzeć, tak?
Żeby do informacji o pacjencie, zanim tą receptę wypisze.
I teraz pewne typowe błędy, jakie robi się na początku korzystania
z tego, a więc tak jak widzieliście Państwo, jeżeli na przykład
robimy system dla przychodni, szpitala, tak?
To nie możemy mieć use case'a pacjent, tylko jeszcze raz przypominam,
use case to jest pewna czynność, którą aktor w tym systemie może zrobić.
Czyli możemy mieć use case, dodaj pacjenta albo określ, tak?
Wizytę pacjenta, tak?
Czy zarezerwuj wizytę dla pacjenta.
Teraz kolejny typowy błąd, który się robi na początku korzystania z UML-a,
to jest, no trzeba pamiętać o tych notacji, o notacji graficznej, prawda?
Że pomiędzy aktorem a use case'em zwykle jest asocjacja dwukierunkowa.
Dlaczego?
Dlatego, że dlaczego tutaj, prawda, jest dwukierunkowa do tego pacjenta,
jak chcemy, nie wiem, zarezerwować wizytę.
No dlatego, że my w tą stronę przekazujemy informacje na przykład,
kiedy byśmy chcieli albo do jakiego lekarza, tak?
się zapisać, ale musimy dostać jakieś informacje zwrotne,
chociażby tyle, czy się to udało zrealizować, czy nie.
Więc tutaj ta komunikacja musi być w obie strony, prawda?
Dlatego mamy tutaj asocjację dwukierunkową.
Zawsze, jeżeli aktorem jest użytkownik systemu, to musi być to dwukierunkowa asocjacja,
bo on przynajmniej musi się dowiedzieć, czy ta funkcja, udało się ją wykonać, czy nie.
Pomiędzy use case'ami, wszystkie, jeżeli są jakieś zależności,
to właśnie zależność, czyli musi być linia przerywana
i albo extend skierowany w przypadku głównej tej funkcji,
albo include skierowany w przypadku tego czegoś, co włączamy.
Czyli grot strzałki, tak, pokazuje albo co jest włączane,
albo co jest rozszerzane. Rozszerzana jest główna funkcja.
I jeszcze popatrzmy na taki slajd z książki anglojęzycznej ściągnięty.
Mianowicie, no wyobraźmy sobie, że tutaj mamy jakiś telefon, prawda?
No to teraz tak, jeśli chodzi o use case'y, to te use case'y będą zadzwoń,
albo odbierz połączenie, albo wyślij komunikat, albo zapisz numer,
albo tam dodaj jakiś numer, czyli z punktu widzenia użytkownika tego systemu.
Natomiast, żeby te funkcje można było wykonać, to to urządzenie, jakim jest telefon,
musi mieć, no, pewne funkcje wewnętrzne, takie jak odbiór danych, wysyłanie danych.
Kwestia poziomu baterii, prawda? Musi mieć jakiś interfejs użytkownika
w postaci wyświetlacza, klawiatury. Musi mieć jakiś system wewnętrzny,
który jest związany na przykład z tą książką telefoniczną.
Czyli mamy tutaj inny punkt widzenia, tak? Te wewnętrzne funkcje to są funkcje
z punktu widzenia takiej osoby, która to oprogramowanie realizuje, tak?
Tworzącego to oprogramowanie. Use case zawsze jest to punkt widzenia użytkownika.
Czy do tego, co tutaj Państwu mówiłam, może macie Państwo jakieś pytania, uwagi?
Jeśli nie, to proszę Państwa, robimy teraz przerwę.
15 minut przerwy. Ja zaraz zapiszę to na...
czacie. Zatrzymam nagrywanie.
---------------------------------------------i udostępnienie
ekranu.
Tak jak Państwu mówię,
tym
teraz modelem, jak mamy już określony
model use case, czyli wiemy, kto z tego
systemu będzie mógł korzystać, jakie
ma możliwości w tym systemie, jakie funkcje są
dla niego dostępne, to teraz musimy
określić, co w tym systemie musi być,
żeby te funkcje dało się zrealizować.
I czy ja włączyłam mikrofon?
Słychać mnie?
Tak, tak słychać.
Ok, dobra.
Bałam się, że znowu...
Dobra, więc proszę Państwa, teraz ten
diagramy klas będę chciała Państwu
pokazać, czyli musimy określić, co w tym
systemie musi być, żeby
te funkcje dało się zrealizować.
I tu proszę Państwa, przypominam to, co
dzisiaj mówiłam, że takim podstawowym
musimy zacząć od identyfikacji klas,
czyli szukamy ważnych rzeczowników z dziedziny,
problemu, dlatego że zaczynamy od tej dziedziny
problemu, dopiero później być może dojdą jeszcze
jakieś klasy, które są związane z implementacją
tego systemu.
Wobec tego właśnie, co w tym systemie jest,
jakie muszą być klasy, żeby dało się
te funkcje zrealizować.
Jest to model statyczny, czyli właśnie, co ten
system zawiera.
Klasa, tak?
Jakie obiekty, jakich klas będą w tym systemie.
Widzicie Państwo, tutaj mamy symbol graficzny
klasy, którym jest po prostu prostokąt.
Nazwa, to jest to pierwsze pole, w drugim polu
mamy atrybuty, czyli mamy dane, które w obiektach
tej klasy będą przechowywane.
Atrybuty, czyli coś, co charakteryzuje obiekty tej klasy.
Czyli, jeżeli mam klasę osoba,
to cechą charakterystyczną
tej osoby może być na przykład
data urodzenia, adres,
wiek, PESEL.
No i operacje.
Trzecie pole, to jest pole
z operacjami, czyli w szczególności
na przykład operacje, które udostępniają
wartości tych,
atrybutów, na przykład podaj adres, czy podaj wiek,
czy które być może zmieniają te dane,
które w tych, w tym obiekcie są przechowywane,
na przykład zmiana adresu.
Teraz, proszę Państwa, nie zawsze wszystkie te
rzeczy są nam potrzebne, czyli jak zaczynamy
projektować system, to zaczynamy od określania
po prostu, jakie są klasy w tym systemie.
Wtedy wystarczą nam po prostu nazwy tych klas.
A potem być może będziemy dodawać operacje,
tak jak tu, czy atrybuty, ale zawsze zaczynamy
od tego, takiego modelu ogólnego, a potem
będziemy ten model uszczegóławiać.
Właśnie klasa. Klasa to jest grupa obiektów,
które mają podobne własności, czyli mają
takie same atrybuty, w ten sam sposób się zachowują.
Mają pewne wspólne relacje z innymi obiektami,
czyli mają takie same atrybuty, w ten sam sposób się zachowują, mają pewne wspólne relacje z innymi obiektami,
identycznymi w znaczeniu.
Jest to uogólnienie zbioru obiektów.
Pomaga nam to w abstrakcji, generalizacji problemu.
Tak jak wspomniałam, atrybuty, czyli dane przechowywane w obiekcie tej klasy.
Te nazwy tych danych są unikalne w ramach danej klasy.
Różne klasy mogą mieć takie same nazwy atrybutów.
Czyli tutaj miałam na przykład atrybut.
Wiek.
A teraz powiedzmy, że dodam klasę, która się nazywa samochód.
A może auto napiszę, będzie szybciej.
No i to auto też ma wiek, też ma ileś lat.
Możemy określić też jego atrybut w postaci wieku.
Czyli to są dane, które w obiekcie tej klasy są przechowywane.
Więc mogą one mieć takie same nazwy, chociaż zabierają zupełnie inne wartości.
Ponieważ są to dane, będziemy musieli również określić, jakiego typu są to dane.
I mogą być to zarówno takie typy, jak mamy w językach programowania,
jak i mogą być to również po prostu, te dane mogą być to typu,
tym typem może być klasa z projektu.
Można podać pewne wartości domniemane tych danych.
Natomiast bardzo istotne jest to, że w obiekcie tej klasy są dane, które są przechowywane.
Natomiast bardzo istotną sprawą jest widzialność tych danych.
Widzialność tych atrybutów.
I tutaj mamy takie trzy typy widzialności atrybutów.
Mianowicie atrybut prywatny to znaczy, że tylko ten obiekt widzi wartość tego atrybutu.
Czyli słowo private.
Można to również, w WML-u jest taki minusik, który się przed nazwą tego atrybutu podaje.
I to znaczy, że ten atrybut name jest atrybutem prywatnym.
Tylko klasa, dana klasa ma dostęp do wartości tego atrybutu.
Atrybut może być public.
Wtedy możemy napisać plusik przed nazwą tego atrybutu.
Co znaczy, że wszystkie klasy w tym projekcie mają do niego dostęp.
I wreszcie może być atrybut tzw. chroniony.
Protektyt, który tutaj znak hasza przed nazwą tego atrybutu.
Umieszczony oznacza, że dana klasa, w której ten atrybut jest,
oraz podklasy, czyli jeżeli to jest klasa i po niej dziedziczą jakieś inne klasy,
to w tych podklasach dziedziczących też ten atrybut będzie dostępny.
Zwyczajowo w narzędziach, które,
w narzędziach, które pozwalają nam taki projekt WML-u właśnie tworzyć,
to standardowo, jeżeli dodajemy atrybut do klasy,
to dodajemy atrybut prywatny.
Bo tak w większości przykładów prawda będzie,
że atrybuty powinny być prywatne.
Taki jest też podjście tego modelu obiektowego.
Tu mi się coś dziwnego zrobiło.
Dobrze.
Teraz, proszę Państwa,
niektóre z tych atrybutów mogą być w momencie tworzenia.
Na przykład my jeszcze nie jesteśmy zdecydowani.
Nie wiemy, czy to ma być atrybut prywatny,
czy może chroniony,
czy może publiczny.
A więc chcemy, jak gdyby,
to określenie tego zakresu widzialności tego atrybutu
przesunąć trochę dalej na fazę kodowania.
Wtedy użyjemy znaku zapytania,
co oznacza, że jest to implementation atrybut,
ale w fazie implementacji dopiero jego zakres widzialności będzie podany.
Teraz niektóre z atrybutów mogą mieć pewne specjalne własności.
Na przykład może być to atrybut,
którego wartość da się wyprowadzić
na podstawie wartości innych atrybutów.
Może być to również,
niektóre z atrybutów mogą być tak zwanymi atrybutami kluczowymi,
key,
co oznacza, że na podstawie wartości tego atrybutu
możemy jednoznacznie zidentyfikować instancję,
czyli obiekt tej klasy.
Wracam do tej klasy osoba,
która już gdzieś tam wystąpiła w moim przykładzie.
I ta osoba
na przykład miała wiek.
Nie chce mi to działać dzisiaj.
Powiedzmy wiek.
Ups, wypełnienie dobre.
Więc proszę Państwa dla tej klasy osoba,
mamy datę urodzenia tej osoby jako atrybut
i mamy aktualną datę,
no to jesteśmy w stanie wartość tego atrybutu wiek policzyć.
Czyli wtedy ten wiek byłby tym atrybutem wyprowadzalnym.
Jeżeli tutaj w tej osobie dodamy taki atrybut jak pesel,
to na podstawie wartości tego pesela
jesteśmy w stanie zidentyfikować,
o którą konkretnie osobę chodzi.
Czyli byłby to atrybut kluczowy.
No i te atrybuty mogą mieć jeszcze dodatkowe własności,
które już tutaj pominę,
bo pokazuję Państwu w prezentacji,
że one są możliwe,
ale rzadziej stosowane.
Teraz proszę Państwa jeśli chodzi o operacje.
To to jest pewna funkcja, transformacja, czynność,
która albo może być wykonana przez obiekty tej klasy,
albo którą można na tym obiekcie wykonać.
I oczywiście jak mamy ileś obiektów, instancji danej klasy,
to wszystkie mają te same operacje.
Metoda to jest implementacja operacji danej klasy.
Teraz operacja może mieć pewne argumenty,
które są potrzebne do jej wykonania,
albo przez które możemy zwracać pewne wartości.
Właśnie operacja może zwracać wynik.
I to może zwracać wynik albo poprzez nazwy tej operacji,
albo właśnie poprzez parametry.
Również dla operacji musimy określić,
zakres widoczności.
I tutaj odbywa się to w analogiczny sposób jak dla atrybutów.
Czyli operacja może być prywatna, private, minusik przed nazwą.
Może być publiczna, public, plusik przed nazwą.
Może być chroniona, hash przed nazwą.
Czyli wtedy dana klasa i wszystkie podklasy mają tą operację.
I znowu może być sytuacja taka, kiedy na danym etapie projektowania,
nie wiemy jeszcze jaki powinien być zakres widoczności tej operacji.
Przerzucamy to na fazę tworzenia kodu.
Wtedy będzie to znak zapytania implementacyjny.
No i teraz proszę Państwa tak.
Czyli tu mam nazwę operacji.
Z przodu mam albo to private, albo public, albo protected.
W nawiasie mam listę argumentów.
Po dwóch kropkach.
Po dwóch kropkach może być typ zwracany.
Czyli typ poprzez nazwę tej operacji zwracany.
Powinny być to typy proste, typu na przykład int czy boolean.
O tej liście parametrów za chwileczkę będę jeszcze mówić.
Natomiast jeśli chodzi o operację,
to znowu takim domniemanym określeniem widoczności operacji jest public.
Czyli znowu, jeżeli korzystamy z takiego nazwiska,
z takiego narzędzia typu case,
to dodajemy operację w klasie,
to ta operacja zwyczajowo jest operacją publiczną.
Co oznacza, że wszystkie obiekty w danym systemie mogą z niej korzystać.
Ale oczywiście też musimy panować nad tym projektem,
bo na pewno nie wszystkie operacje dla wszystkich klas
powinny być operacjami publicznymi.
Teraz jeszcze popatrzmy na tą listę,
popatrzmy na tą listę argumentów, tych parametrów.
Po pierwsze nazwa tego parametru.
Parametry są określonego typu.
Parametr może mieć pewną wartość domyślną,
a przed nazwą tego parametru, tego argumentu
pokazujemy za pomocą wyboru jednego z tych słów,
w jaki sposób ten parametr ma być przekazywany.
Czyli jeżeli jest to in,
to znaczy, że przekazujemy przez wartość,
czyli podajemy konkretną wartość tego argumentu.
Wewnątrz tej operacji można z tej wartości korzystać.
Ale nie można tej wartości zmienić.
Jeżeli poprzedzimy to słowem out,
to znaczy, że ta operacja może wartość tego parametru ustawić,
może jej zmienić, bo być może ona miała już jakoś,
może zmienić na nową wartość.
I również możemy in, out podać.
To jest też przekazywanie przez referencję.
W ten sposób wyraźnie mówimy, że pewna wartość początkowa
jest przekazywana do tej operacji,
ale zezwalamy na to, aby ta wartość została zmieniona.
Czyli musimy określić, w jaki sposób możemy wewnątrz tej,
czy możemy zmienić wartość tego parametru, czy nie.
I w ten sposób za pomocą takiego parametru out
możemy przekazywać jakieś bardziej złożone typy,
bo tutaj tym typem może być nawet nazwa jakiejś klasy.
No i proszę Państwa, teraz istotną sprawą jest,
zaczynamy od tych identyfikacji tych klas,
czyli ważnych rzeczowników z dziedziny problemu.
A dalej to musimy się zastanowić nad relacjami pomiędzy tymi klasami.
Czyli właśnie musimy na przykład zaznaczyć,
że są konieczne jakieś połączenia pomiędzy obiektami tych klas.
Albo takie fizycznie istniejące, albo takie konceptualne.
Te klasy ze sobą muszą współpracować, muszą sobie przekazywać pewne dane,
więc musimy taką drogę tej współpracy, przekazywania danych pokazać.
Bo właśnie poprzez takie połączenie pomiędzy,
asocjacje pomiędzy klasami pokazujemy,
że obiekty tych klas mogą ze sobą współpracować.
Czyli na przykład mogą poprosić o wykonanie pewnej,
wywołać pewną operację, mogą sterować tym innym obiektem,
mogą odbierać rezultaty wykonania pewnej operacji.
I tutaj jeśli chodzi o te relacje pomiędzy klasami,
to mamy relacje trzech typów.
Pierwszy z tych typów to jest asociacja.
Czyli powiązanie.
Stosuje się to wtedy, kiedy możemy związek pomiędzy tymi klasami
na przykład określić za pomocą słów dotyczy, komunikuje się,
obsługuje, przesyła, odbiera.
I tak jak to pokazywałam Państwu na poprzedniej godzinie,
asociacja jest modelowana w postaci linii ciągłej.
Jeżeli nie ma skierowania, to znaczy, że jest to asociacja dwukierunkowa.
To znaczy, że klasa, którą mam tutaj i klasa, którą mam tutaj po tej stronie,
że one mogą przesyłać sobie, jak gdyby tym kanałem komunikacyjnym,
dane w obie strony, czyli na przykład klasa A może wywołać operacje z klasy B,
a te operacje, które tutaj są z tej klasy wywoływane,
zwracają pewne dane i ten obiekt klasy A te dane odbierze.
Może być to asociacja jednorazowa.
Może być to asociacja jednokierunkowa,
która jest tutaj znakowana właśnie za pomocą strzałki.
Na diagramach use case nie pokazałam Państwu przykładu takiej asociacji jednokierunkowej,
a też jest ona możliwa wtedy, kiedy na przykład tym aktorem,
pomiędzy aktorem a use casem,
wtedy, kiedy tym aktorem jest na przykład jakieś urządzenie,
które albo dostarcza pewnych danych, na przykład termometr,
albo odbiera pewne dane, na przykład mamy jakiś sterownik klimatyzacją,
który odbiera dane i wtedy będzie do niego to skierowanie skierowane.
Również może być taka asociacja jednokierunkowa pomiędzy klasami, prawda?
To znaczy, że ta klasa przesyła, na przykład klasa A przesyła do klasy B
pewne informacje, czy wywołuje operacje z klasy B,
ale nic nie może do niej wrócić.
W drugą stronę nie ma przesłania informacji.
Drugi typ relacji pomiędzy klasami to jest agregacja.
Agregacja może być użyta w takiej sytuacji, kiedy chcemy powiedzieć,
że tu znowu mamy pewną klasę i tu mamy pewną klasę.
I ta klasa jest całością, tak?
A ta klasa jest pewną jej częścią składową.
Mamy tu taki diamencik.
Ten diamencik jest po stronie, wskazuje klasę, która jest tą całością,
jest w tym czymś jak gdyby większym, tak?
Mamy tutaj i możemy powiedzieć, że ta klasa zawiera takie klasy,
czy że ta klasa jest zwana z takich części,
że składa się, że zawiera.
A więc w takich przypadkach używamy.
Mamy tej relacji agregacji.
Ja potem jeszcze Państwu pokażę, że ta agregacja może być taką agregacją bardzo silną,
czyli że ten diamencik może być czarnym diamencikiem
i wtedy mamy tak zwaną relację kompozycji.
No i oczywiście, czyli mamy ten sam symbol graficzny,
który Państwu pokazałam w diagramach use case,
stosowany pomiędzy aktorami.
Tutaj aktor ogólny, a tutaj aktor specjalizowany.
Podobnie w klasach.
Strzałka pokazuje klasę ogólną.
Tu mam klasę specjalizowaną.
Ta klasa specjalizowana dziedziczy atrybuty, operacje,
które w tej klasie ogólnej zostały określone jako protected.
Ale może te odziedziczone operacje na przykład przykryć
swoją własną implementacją tych operacji, jeżeli to jej nie odpowiada.
Mówiłam Państwu, że w złożonych projektach mamy tych klas,
może być bardzo dużo, nawet może być parę tysięcy.
Wobec tego musimy te klasy grupować w pewne części
i te diagramy klas właśnie rysujemy, tworzymy
dla pewnych modułów, dla pewnych komponentów.
I na przykład możemy w pakiety grupować te klasy.
Popatrzcie Państwo na taki prosty przykład diagramu klas.
Mam klasę pracownik, klasę firm.
Tutaj, proszę Państwa, zwracam uwagę, że w nazwach klas,
ponieważ te nazwy klas i to, co wewnątrz tych klas piszemy,
to jest jak tworzymy projekt w WML-u dla konkretnego systemu
w narzędziu case'owym, to to jest po prostu generowany jest kod.
No więc w językach programowania nie można używać polskich czcionek,
więc dlatego tutaj w nazwach klas, w nazwach atrybutów operacji
też nie powinniśmy polskich czcionek używać.
No i jeśli chodzi o nazwy, to te nazwy powinny zawierać
litery i cyfry, może być znak podkreślenia, może być kreseczka.
Inne znaki są niedozwolone.
Mam klasę pracownik.
Ten pracownik ma imię, nazwisko, jakąś pensję,
mam określone tutaj typy tych atrybutów,
mam jakieś operacje, które ten pracownik zrobić może,
czy można na nim wykonać.
Mam klasę firma i mam związek jednej firmy.
Jeżeli na takiej asocjacji nie podaję liczności,
to znaczy, że mam jeden obiekt klasy firmy.
Jest w związku, który ja nazwałam pracuję,
z wieloma obiektami klasy pracownik.
Tutaj możemy określać liczność, tak jak Państwo widzicie.
Gwiazdka oznacza dowolność.
Jest niewiele, w tym także zero.
Jak nie podana jest liczność,
no to oznacza to dokładnie jeden.
Mam okres liczb.
Można podać gwiazdkę od zera do dowolnej,
czy jak chcemy, żeby co najmniej jeden obiekt
w tym związku występował, to od jeden do gwiazdki.
No i popatrzmy na kolejny przykład.
Tutaj mamy wiele osób związanych z jedną instytucją.
Czyli można sobie wyobrazić,
że ja robię jakiś system tutaj dla tej właśnie firmy,
w którym chcę przechowywać na przykład informacje
o wszystkich osobach, które z tą firmą współpracują.
Tutaj mam z kolei liczbę postawioną,
tą gwiazdeczkę, po stronie instytucja.
Czyli mogę powiedzieć, że na przykład teraz to wygląda tak,
jak ja bym projektowała jakiś system,
który ja jako pewna osoba chcę używać
i na przykład mieć informacje w tym systemie o tym,
z jakimi firmami i instytucjami ja współpracuję,
czy dla jakich pracuję.
Więc wtedy ta liczność jest po stronie instytucja.
Oczywiście można sobie wyobrazić,
że ta liczność będzie po obu stronach.
Czyli na przykład powiedzmy WIT chce mieć informacje
o wszystkich wykładowcach, którzy prowadzą,
prowadzą zajęcia w tej szkole,
ale chcą wiedzieć również,
że na przykład powiedzmy tutaj ja jestem tą osobą,
ale chcą wiedzieć również,
że z jakimi innymi na przykład uczelniami
ta osoba współpracuje,
że ja jestem pracownikiem etatowym Politechniki Warszawskiej.
Także to oczywiście ta liczność zależy od założeń modelu,
zależy od punktu widzenia i również ta krotność.
Teraz proszę Państwa w tej asocjacji można nazywać role,
jakie te obiekty pełnią w tym związku.
Czyli na przykład rolą instytucji jest zatrudnia,
a rolą osoby jest, że pracuje.
Jeżeli tych ról nie nazwiemy,
to standardowo takie narzędzia case'owe przyjmują,
że nazwa tej roli to jest nazwa klasy,
tylko ma uniterką pisane.
No właśnie, proszę Państwa,
klasa to jest określenie pewnego zbioru obiektów.
I tutaj widzicie Państwo taki diagram obiektów,
który na przykład pasuje do tego diagramu klas,
który ja tutaj zrobiłam.
Czyli diagram obiektów jest pewną konkretną realizacją
tego diagramu klas.
Czyli tutaj instytucje mam vid
i mam dwa obiekty klasy osoba,
Jan i Ala.
I popatrzmy, jak to wygląda.
Właśnie, po pierwsze nazwa klasy jest po dwukropku.
Dwukropek osoba, dwukropek osoba.
Tu z początku mamy identyfikator tego obiektu
i podobnie jest tutaj.
I to wszystko jest podkreślone.
To znowu nie jest mój wymysł,
tylko to jest, proszę Państwa,
tak to się po prostu robi w WML-u,
w diagramie obiektów.
Teraz mogą być asocjacje zwrotne.
Czyli na przykład chcemy modelować struktury rodzinne.
Powiedzmy, obiekt klasy osoba
może mieć od zera do dwóch,
może być w związku od zera do dwóch obiektów,
które pełnią rolę rodzica w tym związku.
A dany obiekt pełni rolę dziecka.
Dany obiekt może pełnić rolę rodzica
w związku z dowolną także zerową liczbą obiektów klasy osoba,
które wtedy w tym związku będą pełniły rolę dzieci.
No i popatrzmy tutaj na taki diagram obiektów,
który przykładowy mógłby wyglądać,
czyli Ala,
obiekt klasy osoba pełni rolę rodzica.
Do Jana też obiekt klasy osoba,
który w tym związku pełni rolę dziecka,
ale Jan jednocześnie nie ma tu o identyfikatorze Zuza.
Nie zawsze trzeba podawać te identyfikatory obiektów.
Czasem można po prostu podać nazwę klasy
i to podkreślić.
I to będzie znaczyło,
że to jest jakiś obiekt tej klasy,
ale powiedzmy, że ten identyfikator nie jest ważny.
W pewnych sytuacjach chcemy mieć bardzo silny związek
pomiędzy trzema lub więcej lub czterema klasami.
I ten związek jest na tyle silny,
że jeżeli byśmy go jakoś tam poprzecinali,
to mogą nam zginąć pewne informacje.
Popatrzmy na taki przykład.
Wyobraźmy sobie,
że realizujemy system taki dla jakiejś firmy software'owej,
w którym będziemy chcieli przechowywać informacje
o wszystkich projektach, które ta firma prowadzi,
również o osobach, które są zatrudnione w tych projektach
i o tym, w jakim języku programowania dana osoba
w tym projekcie pracuje.
Wtedy stosujemy tzw. asocjację ternarną
i łączymy te trzy klasy projekt, język programowania i osoba.
I jest to taki ścisły związek.
Popatrzmy na pewien diagram klas.
Teraz inny trochę.
No a to może byśmy mogli tak to zrobić,
że mamy projekt, mamy język programowania, mamy osobę
i tutaj mamy po prostu asocjację.
W projekcie uczestniczy wiele osób,
dana osoba może uczestniczyć w wielu projektach,
dany projekt może być realizowany w wielu językach programowania,
dany język programowania może być używany w wielu projektach
i dana osoba może programować w wielu językach programowania.
W danym języku programowania
wiele obiektów klasy osoba może programować.
Popatrzmy teraz na jakiś przykładowy diagram obiektów.
Tutaj właśnie z tej asocjacji ternarnej.
Mamy Jana, który jest w związku z projektem pierwszym
i w tym projekcie pierwszym programuje w C++,
ale Jan uczestniczy także w projekcie drugim
i w projekcie drugim Jan programuje w Javie,
czyli wiemy tutaj o związku tego Jana,
wiemy w jakich projektach uczestniczy
i wiemy w jakich językach programowania
on w tych projektach programuje.
Gdybyśmy teraz to zrobili na tym takim modelu,
gdzie nie mamy asocjacji ternarnej,
no to mam też Jana, który w projekcie drugim pracuje
i w projekcie drugim powiedzmy, że pracuje w C++,
ale on jest też zatrudniony w projekcie pierwszym
i ten projekt pierwszy jest zarówno w C realizowany,
jak i w C++ i Jan potrafi programować w C,
Jan potrafi programować w C++.
I teraz, proszę Państwa, to my nie wiemy,
czy on w tym projekcie pierwszym,
bo tutaj widzimy, że jest związek z dwoma językami programowania,
czy on w tym projekcie, i on zna oba z tych języków,
to czy on w tym projekcie pierwszym programuje w C,
czy programuje w C++. Tego nie wiemy.
Natomiast w przypadku tej asocjacji ternarnej,
to wiemy, nawet jeśli ten projekt pierwszy też jest realizowany
w wielu językach, ale tu mamy konkretny związek
z językiem programowania.
To jest, proszę Państwa, taka możliwość w UML-u,
czy ją będziemy stosować w projektach,
czy uda nam się raczej tego nie stosować,
bo dlatego nie ma schematów generacji kodu,
więc raczej o ile w takim pierwszym modelu systemu
możemy tą relację ternarną użyć,
to ponieważ nie ma dla niej schematów generacji kodu,
to potem lepiej ją jest jednak przerobić na takie asocjacje binarne.
Popatrzmy teraz, proszę Państwa, na taki prosty przykład.
Mamy klasę plik, mamy klasę user.
Wyobraźmy sobie, że naszym celem jest zaprojektowanie systemu plików
w jakimś tam systemie operacyjnym,
czyli fragment systemu operacyjnego.
No i mamy tutaj związek wiele do wielu.
Z danego pliku może korzystać wiele użytkowników,
dany użytkownik może korzystać z wielu plików.
No i teraz byśmy, proszę Państwa, chcieli tutaj dodać kwestię,
a w jaki sposób ci użytkownicy mogą z tego pliku korzystać.
No to jak byśmy mogli to zrobić?
No na przykład tak, żebyśmy mogli,
żebyśmy do pliku, tutaj mamy diagram obiektów jakiś przykładowy,
żebyśmy do pliku włożyli atrybut dostęp typu read, tak?
I z tym plikiem pierwszym powiązany jest Jan i powiązana jest Ola, tak?
Ola, przepraszam.
Więc ponieważ dostęp jest atrybutem tego pliku p1,
no to ten sam dostęp będzie dla obu z tych użytkowników.
No to teraz spróbujmy to zrobić inaczej, tak?
To widzimy, że to no niezbyt dobrze jest,
bo wtedy jeśli mamy ten dostęp związany z plikiem,
to wszyscy użytkownicy mają ten sam typ dostępu.
No a jakbyśmy teraz to włożyli do pliku tutaj, do tego Jana, tak?
Gdybyśmy tu włożyli dostęp, no to wtedy,
ponieważ ten Jan miał dostęp do wielu plików,
na przykład tutaj byśmy włożyli mu w,
no to znaczy, że on by wszystkie pliki, z którymi jest powiązany,
miał do nich dostęp typu read.
A ona, na przykład Ola, no miałaby inny,
ale też do wszystkich plików, jakich byliby w związku,
mieliby ten sam typ dostępu, więc nie jest to dobrze.
No to co możemy zrobić?
No to wiemy, że nie może być on związany,
nie może być on dołączony do obiektu z jednej czy z drugiej strony.
No to moglibyśmy wprowadzić odrębną klasę prawa dostępu, prawda?
Wiążącą dany plik z danym użytkownikiem.
Ale w UML-u mamy możliwość realizacji tego w sposób bardziej elegancki,
mianowicie za pomocą tak zwanej klasy asocjacyjnej,
którą tutaj za pomocą linii zależności dependency line
łączymy z tym powiązaniem pomiędzy plikiem i użytkownikiem.
I w nim są prawa dostępu.
I teraz możemy mieć do tego samego pliku
różny dostęp różnych użytkowników,
czyli jak będzie miał inny dostęp, może mieć Ola inny,
jak również dla danego użytkownika,
z kilkoma plikami,
te dostępy też mogą być różne.
Tutaj mamy inny przykład takiego związku z klasami asocjacyjnymi,
czyli na przykład możemy właśnie taką klasę asocjowaną połączyć,
jak gdyby doczepić do związku pomiędzy klasami
i wtedy obiekty tych klas, prawda,
tutaj można przechowywać pewne dodatkowe informacje.
Na przykład znowu mamy tą instytucję i osobę,
w której wiele osób pracuje dla tej instytucji.
I teraz, proszę Państwa, proszę popatrzeć,
tutaj mam stanowisko włożone w tą klasę asocjacyjną.
Dlaczego ja nie mogę tego stanowiska włożyć tutaj w osobę?
No mogłabym, ale jeżeli ją włożę w osobę,
to wtedy dana osoba może pracować tylko na jednym stanowisku.
A powiedzmy, że ja mam Jana,
który w tej instytucji pracuje na stanowisku hydraulik
i na stanowisku na przykład strażnik.
I wtedy już nie mogłabym tego zamodelować,
że on może być zatrudniony na dwóch stanowiskach.
Natomiast jeżeli to podłączę jako właśnie klasę asocjowaną,
no to mogę te informacje przechowywać.
Tutaj mamy inny przykład zastosowania.
Mamy asocjację zwrotną, która modeluje takie zależności służbowe.
Czyli obiekt klasy osoba jest podwładnym, tak,
w stosunku do od zera do jednego obiektów klasy osoba,
które pełnią rolę w tym związku szef.
No i teraz, jeżeli chcemy tutaj na przykład,
żeby szefowi dać możliwość oceniania wydajności,
swoich pracowników, no to właśnie łączymy tą,
mamy tą klasę asocjowaną, która będzie tutaj przechowywała
te informacje o tej ocenie wydajności właśnie w związku
z tym konkretnym szefem.
Teraz, proszę Państwa, mamy również w WML-u możliwość
używania tak zwanych constraint, czyli constraint to jest takie coś,
co napiszemy wewnątrz nawiasów klamrowych, to są ograniczenia.
Mamy tutaj pewną liczbę takich ograniczeń predefiniowanych,
na przykład widzicie tutaj Państwo zastosowanie takiego ograniczenia
ze słowem kluczowym ordered. Wyobraźmy sobie, że modelujemy
teraz fragment graficznego interfejsu użytkownika,
czyli mamy ekran i użytkownik otwiera ileś tam okien na tym ekranie,
więc mamy tutaj ta relacja widoczne na, wiele okien otwiera.
Ale no niektóre z tych okien mogą być całkiem schowane,
a inne trochę tylko widoczne, a jakieś tam to okno na samej górze
będzie widoczne.
Całe. Wobec tego w takim związku może być istotna kolejność,
w jakiej te związki na przykład były tworzone.
Czyli może być istotne uporządkowanie tych obiektów,
które są w związku, w asocjacji z inną klasą.
W takim przypadku używamy właśnie tego ograniczenia ordered.
Teraz, proszę Państwa, tutaj mamy taki przykład,
kiedy pomiędzy dwoma klasami mamy dwie relacje.
Wyobraźmy sobie, że dla szkoły podstawowej realizujemy jakiś system
i przechowujemy w tym systemie informacje o rodzicach dzieci,
które uczęszczają do określonej klasy.
Czyli z daną klasą związanych jest wiele obiektów klasy osoba
i ten związek nazywa się rodzice dzieci.
Ale rodzice wybierają spośród siebie pewnych reprezentantów,
no na przykład powiedzmy od jednego do trzech takich reprezentantów
i mamy związek reprezentanci.
No i teraz, proszę Państwa,
popatrzmy, jak by to mogło wyglądać na właśnie diagramie obiektów.
Czyli mogę mieć, jeżeli mam diagram klas, który wygląda tak jak tutaj,
mam te dwie relacje i nie mam żadnej zależności pomiędzy tymi relacjami,
to ja mogę mieć, proszę Państwa, sytuację taką,
że Jan jest w związku rodzice dzieci z klasą pierwszą A czy A1,
a jest w związku reprezentanci z klasą trzecią B.
Ale proszę popatrzeć, w tej klasie trzeciej B on nie ma dzieci,
on nie jest tutaj w związku reprezentanci.
No to to jest sytuacja niezbyt dogodna,
bo nie będzie reprezentował potrzeb i sytuacji dzieci, które w tej klasie są.
Może być zupełnie niezainteresowany tym, co się dzieje.
Więc byśmy chcieli nie dopuścić do takiej sytuacji, żeby to było możliwe,
tylko, że jeżeli jest w tym związku reprezentanci,
to musi być również w związku rodzice dzieci.
I to możemy, proszę Państwa, zrobić,
pokazując zależności pomiędzy tymi dwoma asocjacjami.
Jeszcze raz przypominam, linia przerywana to jest dependency line,
czyli linia zależności.
Pokazujemy.
Musi być zależność pomiędzy tymi relacjami.
A za pomocą ograniczenia podajemy, na czym ta zależność polega.
Jest to podzbiór.
Czyli mamy teraz, tutaj widzimy,
że ten związek reprezentanci jest pewnym podzbiorem tego związku rodzice dzieci.
No to teraz, proszę Państwa, już ta sytuacja,
o której tu poprzednio pokazywałam, jest możliwa.
Bo jeżeli byśmy teraz tutaj go dopuścili
do tego związku reprezentanci,
to znaczy, że on tutaj musi mieć dziecko.
Również, że tutaj jest ten związek rodzice dzieci.
I wtedy może być w tym związku reprezentanci na diagramie obiektu.
Czy do tego, co tutaj Państwu mówiłam,
może macie jakieś pytania, uwagi, komentarze?
Dobra, popatrzmy na kolejny przykład.
No, wyobraźmy sobie, że mamy system robiony dla jakiegoś uniwersytetu.
Chcemy mieć informację,
o wszystkich osobach, które albo uczą na tym uniwersytecie,
o wszystkich wykładowcach, jak i o wszystkich studentach.
Mamy tutaj dwa związki, naucza czy uczy się, prawda?
Wiele osób uczy się w tym uniwersytecie,
wiele osób naucza w tym uniwersytecie.
Nie ma żadnej zależności pomiędzy tymi związkami.
Wobec tego, proszę Państwa, możliwa by była sytuacja taka,
w której jakiś obiekt,
czyli na przykład Jan uczy się na WIT-cie,
ale jednocześnie Jan naucza, jest wykładowcą na WIT.
Być może jest to sytuacja dopuszczalna,
na przykład jest na kierunku informatyka,
a wcześniej skończył jakieś studia i uczy na kierunku zarządzanie.
Może jest to sytuacja dopuszczalna, w zależności od tego, jakie reguły w tej szkole obowiązują.
Ale gdybyśmy chcieli nie dopuścić do takiej możliwości,
to moglibyśmy pokazać, że pomiędzy tymi relacjami jest zależność
i że ta zależność jest to exclusive or,
że wyłącznie jedna z tych relacji jest dopuszczalna.
Czyli, że albo on jest studentem na tym uniwersytecie,
albo on jest wykładowcą.
A nie dopuszczamy obu z tych możliwości.
Teraz, proszę Państwa, popatrzmy na takie sytuacje,
na przykład zrealizować i wobec tego mamy katalog.
Katalog opisuje wiele plików.
Mamy gwiazdkę po stronie plik.
No ale muszą te pliki być w jakiś sposób identyfikowalne.
No więc na przykład wprowadzamy ograniczenie,
czy mówimy, ale te pliki opisane w tym katalogu muszą mieć różne nazwy.
Muszą mieć unikalne nazwy.
Wobec tego możemy powiedzieć,
no to nazwa identyfikuje plik.
I możemy wtedy tą nazwę tutaj jak gdyby wyciągnąć
i powiedzieć, że ta nazwa właśnie kwalifikuje to powiązanie.
I teraz mamy jeden do jednego.
Dlatego, że konkretna nazwa mówi, o jaki plik chodzi.
W katalogu te nazwy muszą być unikalne.
Więc nazwa identyfikuje, o który plik chodzi.
A więc żeśmy zlikwidowali gwiazdkę, mamy jeden plik.
To nie znaczy, że przy takich połączeniach kwalifikowanych zawsze musi być jeden.
Może być sytuacja, że może być ich wiele.
Na przykład, powiedzmy mamy jakiś system dla giełdy, robimy.
Na giełdzie jest notowanych wiele różnych firm, wiele zakładów.
Stąd gwiazdka.
I te zakłady mają symbole akcji, które na tej giełdzie są notowane.
No to powiemy tak, ten symbol akcji identyfikuje daną firmę,
identyfikuje dany zakład.
No to wyciągamy sobie ten symbol akcji.
Mówimy, to jest kwalifikator naszego połączenia.
Ale tu mam teraz gwiazdkę po stronie tego symbolu.
Bo może być sytuacja taka, że dany zakład ma kilka edycji tych akcji.
Wobec tego są różne symbole.
Inny symbol jest w pierwszej edycji, inny jest w drugiej.
Czyli wcale to nie znaczy, że takie połączenie kwalifikowane zawsze ma jeden do jednego.
Może być tak, że ta gwiazdka jednak tutaj powstanie.
Dobrze.
I to by było, proszę Państwa,
jeśli chodzi o różne typy asocjacji.
Czy do tego, co mówiłam,
może mają Państwo jakieś pytania, uwagi do tych wcześniejszych rzeczy.
Ograniczeń kwalifikatorów.
No to teraz, proszę Państwa,
popatrzmy na inny typ związków.
Na inny typ związku pomiędzy klasami.
Na związek typu całość-część.
Mówiłam Państwu, to się nazywa agregacja.
Diamencik, duży diamencik jest po stronie klasy, która jest pewną całością.
Czyli książka jest pewną całością.
Rozdział jest jej częścią składową.
Mogę powiedzieć, książka składa się z wielu rozdziałów.
Książka jest zbudowana z wielu rozdziałów.
Czy rozdział jest częścią książki.
No i dalej możemy to ciągnąć.
Rozdział jest też całością.
Zawiera ileś paragrafów.
Paragraf jest częścią rozdziału.
Mamy tutaj tak zwaną agregację.
Czyli na przykład powiedzmy sobie, że ta nasza książka ma na przykład 5 rozdziałów.
Czy 6.
I teraz proszę Państwa w diagramie obiektów mamy 6 obiektów.
Rozdział pierwszy, drugi, trzeci i tak dalej.
I teraz usuwamy na przykład piąty, szósty rozdział.
Czyli mamy tylko pierwszych 4 rozdziałów.
Wobec tego nie mam tej książki, bo nie wszystkie rozdziały istnieją.
I to jest przy takim modelu dopuszczalna sytuacja.
Niektóre z tych obiektów, które są w tych związku mogą być usunięte wobec tego.
A ten związek też nie istnieje.
Ale możemy chcieć mieć taki związek silny.
Przeskoczyło mi.
I to się nazywa kompozycją.
Czyli ten diamencik jest takim diamencikiem.
Wypełnionym tutaj na czarno.
I to oznacza tak zwaną agregację całościową.
Czyli oznacza to tyle, że jak ja niszczę obiekt tej klasy całość.
To niszczę również wszystkie jego części składowe.
Więc tutaj modeluję, że wielokąt zawiera od 3 do dowolnej liczby punktów.
I mam ograniczenia order.
No bo żeby mieć wielokąt to ja muszę pomiędzy tymi punktami w odpowiedni sposób się przemieszczać.
Więc jest to 1, 2, 3, 4, 5 i tak dalej.
Jest uporządkowane.
Ta agregacja całościowa oznacza, że jeżeli ja ten obiekt usuwam.
Usuwam wraz z wszystkimi punktami.
Czyli wszystko to ginie.
Natomiast.
Gdybym tutaj miała tą.
Agregację taką białą.
To mogłaby być sytuacja, że ja nie mam już tej nie mam tego wielokąta.
Ale jakieś punkty mi zostały.
No i teraz to jest nasza decyzja.
Który z tych modeli jest modelem prawidłowym.
Czy ta kompozycja.
Czy ta agregacja zwykła.
Tutaj.
Też mogłabym na przykład zastosować tą kompozycję.
Tak.
I wypełnić.
Zamalować tutaj te na ciemno.
Ten znacznik agregacji.
Co by to znaczyło?
To by znaczyło, że jak ja usuwam taką książkę.
To wyobraźcie sobie Państwo.
Ja biorę tą książkę i wkładam do niszczarki.
I wszystko jest pocięte na drobne paseczki.
Nie jestem w stanie.
Nie mam tych elementów składowych.
Jeżeli natomiast mam tutaj.
Agregację taką.
To ja mogę nie mieć książki.
Tak.
Ale jakieś obiekty, klasy, rozdział.
Mogą w tym systemie istnieć.
No i jeszcze raz powtarzam.
Że to jest nasza decyzja.
Który z tych modeli jest modelem właściwym.
Czy ta kompozycja.
Czy ta agregacja.
Powiem Państwu, że.
Jak gdyby.
Statystycznie rzecz biorąc.
Te kompozycje są dużo rzadsze.
I jeśli Państwo na początku robicie jakieś modele.
I nie wiecie który z tych jest właściwy.
To proponuję stosować agregację zwykłą.
Bo będzie to bardziej trafne.
A kompozycje stosuje się w wyjątkowych sytuacjach.
No i teraz proszę Państwa.
Jeszcze trzecia relacja możliwa.
Pomiędzy klasami nam została.
Mianowicie generalizacja.
Czyli właśnie ta relacja ogólne coś.
I jego specjalizacja.
Czyli pewna klasa ogólna.
I pewne jej podklasy.
Pewne jej specjalizacji.
Pewne atruty i operacje wspólne.
Ogólne.
Umieszczane są w tej tak zwanej super klasie.
Czyli w tej klasie, która jest na samej górze.
No i jeżeli chcemy, żeby one były dziedziczone.
To przypominam, że wybieramy dla nich protected.
Mają być dziedziczone.
W takie właśnie atrybuty.
Takie operacje są dziedziczone.
Przez klasy niższego poziomu.
Popatrzmy tutaj na taki prosty przykład.
Mam klasę wyposażenie.
Pompa zbiornik.
Mamy relację generalizacji.
Mogę ją tak rysować jak tutaj.
Albo mogę ją po prostu takimi dwoma strzałeczkami pokazywać.
Tutaj mam klasę jedną.
I tu mam klasę drugą.
I tu mam klasę, która jest całością.
Obie te metody są graficzne, są poprawne.
I ta, i ta.
I jak nam jest wygodniej.
Proszę popatrzeć.
Tu mam klasę, która się nazywa wyposażenie.
No już pierwsza rzecz, o której mówiłam.
Że nie ma.
Nie ma polskich czcionek.
Druga rzecz to zwyczajowo nazwy klas powinny być dużymi literkami pisane.
I tutaj zbiornik.
I w tej klasie wyposażenie.
Protekty, czyli tutaj powinny być hesze.
I atrybuty, tak jak nazwa, producent, waga, koszt.
Jeśli one wszystkie są protekty.
One będą odziedziczone i przez pompę, i przez zbiornik.
Pompa ma swoje atrybuty prywatne.
Takie jak ssanie, przepływ, zbiornik, pojemność i ciśnienie.
Znowu tu mamy polską czcionkę.
Dobra, ale teraz proszę popatrzeć.
Klasa wyposażenie.
Ja ją napisałam czcionką pochyłą.
Italiką.
Dlatego, że mi się tak podobało?
No nie.
Takie właśnie podanie nazwy klasy.
W postaci właśnie pochylonej czcionki.
Czcionki Italik.
Oznacza, że ta klasa jest klasą abstrakcyjną.
To jest klasa abstrakcyjna.
Co to znaczy?
Abstrakcyjna.
To oznacza, że w systemie nie.
Nie będą tworzone obiekty wyposażenie.
Będą tworzone obiekty klasy pobiornik.
Ale żeby mieć w tej klasie zgromadzone pewne własności wspólne.
Warto taką klasę abstrakcyjną stworzyć.
Jakieś pytania, uwagi?
Teraz proszę Państwa.
Pokazywałam Państwu przed chwilą ograniczenia asocjacji.
Takie jak Exclusive Or albo Subset.
W relacji dziedziczenia mamy też wiele różnych ograniczeń dostępnych.
Mamy Exclusive.
To jest takie domniemane.
To oznacza, że obiekt jest instancją tylko jednej podklasy.
Czyli?
Bardzo wolną mi się.
Cierpliwość.
Czyli, że w systemie mogę mieć jakiś obiekt klasy pompa.
Czy kilka takich obiektów.
Obiekty typu zbiornik.
Ale albo są takie, albo są takie.
To jest ten Exclusive Or.
To jest domniemana relacja.
To może być ograniczenie relacji za pomocą słowa disjoint.
Co oznacza, że klasa pochodna od tej klasy na górze jest tylko do jednej możliwa.
Może być ograniczenie overlapping.
Czyli, że własności się nakładają.
Zaraz pokażę Państwu taki przykład.
Tu już mamy wspomniane.
Na przykład na górze mam klasę urządzenia.
Poniżej mam klasę urządzenia do rejestracji obrazu, urządzenia do rejestracji dźwięku.
I na przykład mam klasę kamera, która zarówno może dźwięk, jak i obraz rejestrować.
Może być ograniczenie w postaci complete i incomplete.
Czyli incomplete na przykład wtedy, kiedy w tej strukturze dziedziczenia przewidujemy, że może jeszcze jakieś dojdą klasy complete.
Wtedy, kiedy mówimy.
To już jest pełna struktura.
Nic więcej tu nie dojdzie.
No i popatrzmy na jakieś przykłady takich właśnie ograniczeń w generalizacji.
W jaki sposób można je wprowadzać na diagramie klas za pomocą notatki.
To, co Państwo tutaj widzicie.
Taki pięciokąt z tym rożkiem takim odłożonym.
Czyli jak gdyby taka kartka papieru z zagiętym rogiem.
To jest komentarz.
I mogę tutaj wpisywać pewne teksty.
W tym wypadku są to ograniczenia.
Za pomocą dependency line przywiązuję ten komentarz do czegoś.
Bo muszę pokazać, a czego ten komentarz dotyczy.
Tym razem ten komentarz dotyczy relacji generalizacji.
Pomiędzy klasą osoba i klasami kobieta, mężczyzna.
Complete.
To znaczy, że tutaj już nie dojdzie żadna nowa klasa.
Już nie dopuszczam żadnej nowej klasy.
Tego nie będzie na pewno.
To znaczy complete.
Disjoint.
Znaczy, że jeżeli ja mam w systemie utworzony jakiś obiekt.
To albo będzie to obie klasy kobieta, albo obie klasy mężczyzna.
Więc mam to rozłączne obiekty klasy.
Proszę Państwa.
Pokazałam Państwu tutaj trochę informacji dotyczących diagramu klas.
Czyli przypomnę, że zaczynamy od identyfikacji tych klas.
Od ważnych rzeczowników z dziedziny problemu.
Na razie nie zajmujemy się kwestią implementacji.
Potem na etapie implementacji dojdą nowe klasy.
Na przykład zwykle dochodzą klasy, które sterują przebiegiem use case'ów.
Ale to na dalszych etapach wprowadzamy.
Zastanawiamy się nad związkami pomiędzy, nad relacjami pomiędzy tymi klasami.
Czyli te, które współpracują ze sobą.
Asocjacje.
Może wyodrębniamy jakieś klasy abstrakcyjne.
W każdym razie generalizacji szukamy.
Czy nie da się gdzieś wprowadzić.
A może są relacje pomiędzy klasami typu całość, część.
To agregacja czy kompozycja.
No i tutaj przy tej generalizacji no to być może już identyfikujemy jakie atrybuty, jakie operacje w tej klasie ogólnej powinny być.
A jak dla innych obiektów dodajemy te atrybuty, operacje trochę później.
No i jak tych klas jest dużo.
No to dzielimy te klasy na pakiety.
I te pakiety powinny być pod jakimś tam względem spójne.
Czyli odpowiedzialne czy dostarczające pewnych usług, pewnych funkcji.
No właśnie w przypadku dużych złożonych systemów.
Proszę Państwa.
Ja tutaj Państwu pokazywałam takie bardzo proste przykłady.
Gdzie były tylko jeden typ relacji pomiędzy dwoma klasami.
Natomiast oczywiście jak tworzymy diagram klas dla jakiegoś podsystemu czy modułu to tych klas będzie wiele.
I będzie, będą różne typy związków dla danej klasy.
Czyli popatrzmy tutaj mam klasę samochód.
Tak.
Może być to samochód osobowy.
Może być to samochód ciężki.
Może być to samochód ciężarowy.
Mam związek samochodu z osobą.
Osoba kieruje jakimś samochodem.
Ale teraz ten samochód mogę widzieć jako pewną całość.
I mogę tutaj powiedzieć z jakich części on się składa.
Ja mam tu układ napędowy, hamulcowy, kierowniczy.
Ale nie jest to wszystko.
No to dodaje ograniczenie tej agregacji w postaci słowa incomplete.
Czyli to nie jest wszystko już.
Ja tu wybrałam takie elementy, które w danej wersji systemu są mi potrzebne.
Ale spodziewam się, że może w kolejnych wersjach albo w kolejnych iteracjach będę musiała tutaj coś dodawać.
Więc używam tego określenia incomplete.
No i teraz proszę Państwa tutaj mam tą relację dziedziczenia.
Samochód ciężarowy, samochód osobowy.
Asocjacje z osobą mam tej klasy samochód, która pewnie będzie klasą abstrakcyjną.
Tu mam tą relację agregacji.
I to proszę Państwa oznacza, że zarówno samochód ciężarowy jest kierowany przez jakąś osobę.
Samochód ciężarowy ma takie układy.
Ale samochód osobowy też ma takie układy.
I też jest kierowany przez osobę.
No dobra, to teraz jak jesteśmy tutaj mamy taki prosty przykład.
To jeszcze teraz zastanówmy się nad taką rzeczą.
Tutaj mówiłam Państwu o tych atrybutach, o własnościach, o danych, które w obiekcie danej klasy powinny być przechowywane.
Wiemy, że samochody mają numery rejestracyjne.
Tak?
Dobrym pomysłem jest, żebym ja ten numer rejestracyjny wprowadziła do osoby.
Że osoba kieruje takim samochodem o takim numerze rejestracyjnym.
Jak myślicie?
Fatalny.
Numer rejestracyjny to jest cecha charakterystyczna obiektu samochód.
Czyli powinna być ona wprowadzona w klasie samochód.
W klasie samochód, tak?
Ale poprzez ten cykl osoba wie jaki może wiedzieć, jak tu damy operację, podaj numer rejestracyjny.
To wie jaki jest numer rejestracyjny samochodu, który kieruje.
Prawda?
Ale nie może być to w klasie osoba.
Bo jest to cecha charakterystyczna dla obiektu.
Samochód.
Także umieszczając atrybuty musimy pamiętać, że mają być to atrybuty, które charakteryzują obiekty danej klasy.
A nie inne obiekty.
Ale być może te atrybuty będą dostępne dla innych obiektów właśnie poprzez operację, która ta klasa udostępniania wartości tych atrybutów będzie miała.
Teraz, proszę Państwa, mogą być również...
Tak zwane klasy interfejsowe.
I tu mamy taki przykład.
Mamy klasę koszyk, która ma dwie operacje tutaj.
Wyobraźmy sobie, że jakiś taki sklep internetowy, powiedzmy, ma operację dodaj pozycję do koszyka, czy usuń pozycję, czy jeszcze jakieś inne.
I proszę popatrzeć, tutaj mam takie celu.
Mam takie coś, co przypomina relację generalizacja, ale nie jest relacją generalizacji berywana.
I mam tutaj stereotypy.
To znaczy, że te operacje dodaj pozycję, usuń pozycję są realizowane właśnie w klasie książka.
A ten koszyk udostępnia.
Jest taką klasą interfejsową.
Którą udostępnia te operacje.
To czasem też nam jest potrzebne.
Można to zanotować w taki sposób.
Za pomocą takiego kółeczka.
To jest tak zwany interfejs udostępniany.
Może być również...
...interfejs wymagany.
Czyli może być również tak, że klasa...
Na przykład tu mam jakaś klasa television.
Wymaga, potrzebuje do swojego działania czegoś, co się nazywa signal.
I które skądś tam przychodzi.
I mam wtedy taki interfejs wymagany.
To jest udostępniany kółeczko, to jest wymagany.
I w takim przypadku możemy te interfejsy w takim porcie.
Jak gdyby w takim...
No właśnie umieścić, pokazać klasa television.
Wymaga interfejsu signal.
A udostępnia jakieś informacje billingowe.
Czy udostępnia informacje o użyciu kanałów na przykład.
Dobra, proszę Państwa.
Zostało nam 10 minut.
Więc próbujmy zrobić to zadanie.
Ile zdążymy?
Tyle zdążymy.
Zdążymy resztę ewentualnie na następnych zajęciach.
Ja również Państwu opublikuję dzisiaj takie zadanie domowe.
Poproszę Państwa o narysowanie diagramu klas.
Zaraz, nie w tą stronę.
O, poproszę Państwa o przygotowanie diagramu klas na następne zajęcia w takiej formie.
I jako zadanie opracowanie takiego diagramu klas.
I na następnym wykładzie porozmawiamy sobie o różnych rozwiązaniach.
Bo to oczywiście nie ma jednego dobrego rozwiązania przy takich bardziej złożonych przykładach.
Może być ich więcej.
To trzeba będzie przesłać...
Spróbujmy.
Przepraszam.
Poprzez Teams będzie zadanie ustawione w Teamsach.
I będziecie Państwo mogli po prostu zadanie przesyłać.
Czyli nie na czacie, nie broń Boże nie mailem do mnie.
Tylko będziecie Państwo mogli rozwiązanie, rysunek, zdjęcie przesłać właśnie w Teamsach, włożyć.
Z tym, że no bardzo proszę, żeby to było czytelne.
Prawda?
Czyli jeżeli robicie zdjęcie.
To proszę sprawdzić, czy ono było dobrze oświetlone, ta kartka papieru.
Czy te nazwy klas są czytelne.
Dobrze?
Niestety ja utraciłam połączenie z Aleksandrem.
Spróbuję jeszcze raz to nawiązać.
Może mi się uda szybko.
Ale w międzyczasie ja tutaj będę próbować się podłączyć do Aleksandra.
Bo chcę.
Chciałam Państwu to pokazać w jakimś narzędziu case'owym.
No to zastanówmy się.
No może pójdziemy od końca.
Tak?
To piąte.
Magnetofon, magnetowid są urządzeniami do rejestracji dźwięku.
No już teraz to możecie Państwo nie wiedzieć co to jest.
Bo trochę historyczna sprawa.
Teraz się tego nie używa.
Ale kiedyś się używało.
Pierwsza sprawa.
Jak mamy takie coś do wykonania.
No to musimy się zastanowić co tutaj będzie klasą.
No i tutaj przypominam tą wskazówkę, którą przed chwileczką, jakiś czas temu, a dzisiaj kilka razy Państwu mówiłam.
Że klasa, obiekt to są ważne rzeczowniki z dziedziny problemu.
Czyli proszę Państwa.
Tutaj.
Tak.
Jakie mamy tutaj klasy?
Jakie tu będą klasy w tym piątym zdaniu?
Co będzie klasą?
Magnetofon.
Magnetowid.
Urządzenia do rejestracji dźwięku.
Teraz.
Momencik znowu, żeby się przełączyć.
Dobra.
Teraz ja zatrzymam udostępnianie.
I udostępnię coś innego.
A to zadanie domowe to rozumiem, że to są dodatkowe punkty jakieś?
Czy to się wlicza do tych stu punktów?
Wlicza do tych stu punktów.
One się nie wlicza do tych stu punktów.
Natomiast jeżeli będą dobre rozwiązania jakieś.
To jakieś z tych punktów dodatkowych Państwo za to dostaniecie.
Jakiś problem mam.
A może mi się udało już.
Dobrze.
Już mamy.
Tak.
Więc.
No.
Więc właśnie.
Czyli mam klasę.
Tak.
Mam klasę urządzenie.
Napiszę w skrócie tylko, żeby już nie tracić czasu.
Urządzenie.
Mam klasę.
Magnetowid.
Mam klasę trzecią tutaj.
Trzeci rzeczownik.
To jest magnetofon.
No i teraz.
Jaka relacja tutaj pomiędzy tymi klasami?
Jak Państwo myślicie?
Magnetofon.
Magnetowid są urządzeniami do rejestracji dźwięku.
Czyli jaka relacja będzie?
Ta przerywana chyba.
Relacja.
Ta przerywana.
Nie.
Nie.
Jak przerywana to jest interfejs.
To całkiem nie.
Tutaj mamy urządzenia do rejestracji dźwięku.
Tak.
Powinnam jeszcze zaznaczyć.
To jest klasa abstrakcyjna.
Magnetofon jest pewną klasą kretną.
Magnetowid też.
One dziedziczą te cechy urządzenia do rejestracji dźwięku.
Czyli mają możliwość rejestracji dźwięku.
Bardziej współczesne.
Możemy dodać klasę kamera.
Na przykład.
Tak.
Telefon też ma taką możliwość do rejestracji dźwięku. Czyli mamy relacje generalizacji.
Dobra, może jeszcze zróbmy zdanie czwarte. W plecaku znajdują się książki zeszyty.
Czyli będę tworzyć kolejny diagram klas.
No i klasy, jakie tutaj mamy. Czyli będzie klasa.
W plecaku będzie klasa zeszyt.
Będzie klasa książka.
Zwracam uwagę, że tutaj było w zdaniu w plecaku znajdują się książki zeszyty.
Była liczba mnoga.
A ja mam tutaj klasę w liczbie pojedynczej zeszyt, książka.
Dlaczego?
No dlatego, że tak się robi właśnie w modelowaniu obiektowym.
A to, że wiele może być tych zeszytów w plecaku czy książek w plecaku, to za pomocą liczności to określę.
Natomiast teraz pytanie, a jaką relację tutaj pomiędzy zeszytem a plecakiem zrobić?
Zeszytem, a książką a plecakiem.
Jakie Państwo macie propozycje?
No słucham, żadnych nie ma.
Trzy byłości, tak? Dzisiaj.
Asocjacja, generalizacja i agregacja. Która z tych trzech?
Prawdopodobieństwo trafienia 1 trzecia. Całkiem sporo.
Co proponujecie?
Zwykła asocjacja pomiędzy plecakiem i zeszytem.
To, że wiele tych książek, to po prostu określamy tutaj liczność wtedy.
Niestety mnie tutaj nie mogę tego zmienić.
Ale jest to zwykła asocjacja.
Dlaczego nie mogę użyć tutaj agregacji?
Dlatego, że...
Teraz to przesunę.
I tu musi być wiele po stronie książka.
I tutaj multiplicity, wiele po stronie książka.
I w podobny sposób zmienię tutaj po stronie zeszyt.
Też wiele zeszytów jest dopuszczalnych.
Dlaczego nie agregacja?
Skoro mam powiedziane, w plecaku znajdują się.
Dlatego, że agregacja oznacza pewien związek fizyczny.
Czyli mogę tutaj zastosować agregację.
Ale muszę coś innego pokazać.
Czyli mogę powiedzieć, że na przykład plecak ma komorę.
Może kilka.
Ma na przykład szelki.
Szelka.
I teraz mogę tutaj użyć agregacji.
I pokazać, że właśnie.
Że mam...
Że plecak zawiera, składa się, jest zbudowany.
Na przykład z kilku komór.
Tak jest zbudowany z kilku szelek.
Ma kilka szelek.
Tu mogę zmienić, powiedzieć dokładnie.
Dwie szelki są w plecaku.
Proszę Państwa, to na tym dzisiaj kończymy zajęcia.
Te pierwsze trzy zdania, które tutaj były na tej prezentacji.
Też będą.
Jako praca domowa.
I wrócimy do tych przykładów za tydzień.
Także dziękuję dzisiaj Państwu za udział w zajęciach.
Zatrzymuję nagrywanie.
I do zobaczenia, do usłyszenia za dwa tygodnie.
Do widzenia.
Dziękuję.
Do widzenia.
---------------------------------------------pracy domowej, którą
kilkanaście osób mi przysłało,
natomiast
nie wszystkie
z tych rozwiązań, które
zostały mi przysłane, były poprawne.
Punkty
za tą pracę domową,
takie te dodatkowe ekstra punkty
dostały
osoby, które miały rozwiązanie
dobre lub
prawie dobre. Natomiast
kilka osób przysłało mi
jakieś
rysunki, w ogóle nie stosując
się do notacji WML-owej,
więc oczywiście te
osoby nie dostały tych punktów
dodatkowych i również
w przypadku osób, które
popełniły jakieś
bardzo poważne błędy w tych swoich
rozwiązaniach, np. relacja
generalizacji była
skierowana w niewłaściwą
stronę, też tych punktów
nie dostały.
Dobra, proszę Państwa,
zaczniemy może, aha, jeszcze chwileczkę,
czy mi się uda
połączyć
z Aleksandrem.
Tak, udało się
połączyć ponownie.
Zaczniemy, proszę Państwa,
może od tego pierwszego zdania,
które
tutaj widzicie.
Klient ma miejscówkę na określony
pociąg.
I teraz
jeszcze
będę
chciała teraz co innego Państwu
tutaj pokazać.
I to jest, proszę Państwa,
jedno z możliwych
rozwiązań tego
właśnie, no tutaj
tego zadania.
Zdanie było, klient ma miejscówkę
na określony pociąg, czyli mamy
klient, mamy pociąg
i mamy tutaj
miejscówkę jako taką klasę
asocjowaną,
związaną z tym połączeniem,
prawda? W danym pociągu
może być wielu klientów,
tutaj klient
jedzie określonym jednym pociągiem,
nie jest
to jedyne dobre
rozwiązanie.
Tutaj również osoby,
które po prostu nie zastosowały
asocjacji,
klasy asocjowanej, ale połączyły
nie wiem, pociąg z miejscówką,
pokazały pociąg ma ileś
tam miejscówek, klient
jest połączony z miejscówką, też
jest rozwiązaniem poprawnym.
Teraz, jeśli
chodzi o drugie zdanie,
drugie zdanie to było
zdanie,
to było
zdanie listonosz
dostarcza przesyłki.
To tutaj zwracam uwagę, że
klasa jest przesyłka,
czy przesylka,
czyli jest
w liczbie pojedynczej,
a nie w liczbie mnogiej.
To, że tych przesyłek jest wiele,
tak jak w zdaniu jest napisane, że
dostarcza przesyłki, to
pokazujemy za pomocą
liczności, dowolnie
wiele obiektów klasy
przesyłka i
jeden tutaj listonosz.
I trzecie zdanie,
bileter sprzedaje bilety,
przepraszam, to chyba nie to,
bilety, bileter
i znowu klasa bilet,
a nie bilety. Tutaj kilka osób właśnie
nazwę klasy miało w liczbie
mnogiej.
Czy ktoś z Państwa ma może jakieś
pytania, uwagi dotyczące
tych rozwiązań?
Ewentualnie punkty są na UBI, tak?
Nie, punkty nie są na
UBI.
Punkty nie są na UBI,
przynajmniej jeszcze.
Natomiast
jeśli komuś
bardzo zależy, to
ja mogę ewentualnie mu
potem odpowiedzieć, czy punkty dostał,
czy nie i ile dostał. Muszę otworzyć
określony plik.
Także na przykład, nie wiem,
czatem indywidualnym możecie się
ze mną komunikować i
spróbuję Wam odpowiedzieć, kto dostał
i ile dostał. Maksymalnie można
było dostać za te
dwa zadania,
można było maksymalnie dostać pięć
punktów.
Dobra, jeszcze raz, czy ktoś może
ma jakieś pytania albo chce się spytać
o swoje rozwiązanie, to bardzo
proszę.
Dziękuję.
Nie słychać, nie widać.
To proszę Państwa, teraz
przejdziemy do
dalszej, do drugiego
zadania.
Drugie zadanie polegało
na tym, aby
narysować spójny
diagram klas WML-u
i były podane
i były podane,
ale to nie ten, przepraszam.
Już nie ten.
Okej, to nie ten.
To momencik.
To teraz
mam to w innym miejscu.
I tutaj już użyję
czyjegoś rozwiązania
po prostu.
Jednego
z możliwych.
Czy pan
Szum wyrazi zgodę na to, aby
jego, nie wiem, czy jest obecny w tej chwili,
żeby jego rozwiązanie
tutaj pokazać?
Jestem obecny, można pokazać.
Można pokazać? Dobrze.
Ma pan pewne drobne błędy,
ale to jak gdyby
przy okazji, przy okazji,
się pan dowie, co i jak.
Natomiast
pokażę tutaj
jak gdyby jedno z możliwych rozwiązań.
Być może, że pokażę jeszcze jedno
właśnie z rozwiązań, które
dostałam. Otóż było tam
dosyć dużo
rzeczowników, zamek, most
wodzony, strażnik, duch,
rabina, schody i tak dalej.
No i tutaj
pan Martin, prawda, jako taką
klasę centralną zrobił klasę,
zamek i tutaj
użył relacji agregacji
i to jest ok. Pokazał, że ten
zamek jest pewnego rodzaju budowlą
i pokazał z jakich części
się składa, a więc ma
jakieś pokoje, wiele pokoi,
wiele korytarzy, wiele schodów,
także most wodzony,
wieża, czyli takie pokazał elementy
architektoniczne poprzez
relacje agregacji. I to jest
ok, to jest dobrze.
Teraz tutaj jeszcze
jest pokazane, prawda, troszkę
dokładniej organizacja,
czy budowa tego pokoju,
że ma okna, że ma podłogę,
tak, korytarz też ma
podłogę, też może mieć okna,
z korytarzem
są, no tutaj
wolałabym relacje asocjacji,
są związane schody,
wieża,
wewnątrz wieży są schody,
czyli ta relacja agregacji
tutaj jest jak najbardziej
wskazana, tak to
powiedzmy. No i
teraz mamy tutaj, mamy tutaj
taką część jakby osobową,
bardzo dobrze jest
zrobiona tutaj klasa, wyciągnięta
jest klasa, na przykład
człowiek czy osoba
i mamy pokazane,
że zarówno hrabina, hrabia, loka
i kucharz, to są to osoby
i super, i to jest
bardzo dobrze. Teraz tutaj również
jest pokazane, że te osoby za pomocą
relacji asocjacji są związane
z klasą zamek.
I tutaj troszkę robi się taka sieć,
pającza, bo tych asocjacji
tak jak Państwo widzicie, jest dosyć
dużo, chociaż tutaj Pan Martin bardzo ładnie
to narysował, ale lepsze
rozwiązanie byłoby, gdyby
zamiast tych asocjacji
kucharz, hrabina, lokaj
z zamkiem, zrobić jedną
asocjację z klasą człowiek.
I wtedy, ponieważ
hrabina, lokaj, kucharz
dziedziczą po klasie
człowiek, to też by
jak gdyby dziedziczyły tą własną
możliwość, tą asocjację
z klasą zamek i ta
konstrukcja wtedy
byłaby tutaj
bardziej czytelna. Ale
ogólnie jest to dobre rozwiązanie
i Pan Martin dostał chyba pięć punktów
z tego, co pamiętam.
Czy może macie Państwo
jakieś pytania?
Teraz jeszcze do tego, co
tutaj pokazałam.
Jeszcze zobaczę, może jeszcze
pokażę jedno rozwiązanie.
Tak, pokażę jeszcze
rozwiązanie. Czy Pan Łukasz Kryśkiewicz
jest może obecny w tej chwili?
I czy wyrazi zgodę na pokazanie
swojego rozwiązania?
Nie słychać.
No, więc proszę Państwa, to jest
też
dosyć dobre rozwiązanie. Jak widzicie
Państwo, podobne
są pomysły,
czyli też jest klasa abstrakcyjna
osoba. Tutaj
no i tą osobą
może być również duch.
Tutaj pokazana jest budowa
tego zamku, domek,
zamek zawiera wieże, schody,
korytarz, pokój
i tak dalej.
Natomiast ja tutaj niezbyt mi się
podoba użycie kompozycji,
czyli tej czarnej takiej
agregacji, że na przykład
zamek, tak, zawiera
pokoje.
Pokój
zawiera podłogę, tak.
To jest taka,
jeszcze raz przypominam, kompozycja
bardzo silna relacja,
która mówi, że
nie może być klasy będącej,
gdyby nie może klasa
będąca jej elementem składowym, nie może
istnieć samodzielnie.
No, a tutaj możemy
sobie wyobrazić taki zamek w ruinach,
że jakieś tam pokoje zostały,
ale praktycznie już tego zamku nie ma.
Możemy sobie wyobrażyć
jakąś taką sytuację,
że no nie ma pokoju,
bo na przykład ściany zostały zburzone,
ale podłoga istnieje. Także tutaj
lepiej byłoby, gdyby zamiast
tej kompozycji była po prostu
użyta zwykła agregacja.
Tutaj, proszę Państwa, jeszcze
co można by było zauważyć, na przykład,
no, tutaj
akurat, no, jak gdyby
nie jest pokazana budowa tego
korytarza, że też może mieć okna,
czy ma podłogę. Można by
wprowadzić tutaj klasę abstrakcyjną,
na przykład klasę pomieszczenie
i pokazać, że takim
pomieszczeniem może być korytarz,
takim pomieszczeniem może być pokój,
no i to pomieszczenie,
pomieszczenie właśnie zawiera podłogę,
zawiera okna.
Dobra, czy do tego
może ktoś ma jakieś pytania, uwagi?
Dobrze, to tyle, jeśli
chodzi o,
jeśli chodzi o pracę domową.
To teraz, proszę Państwa, ja bym jeszcze
chciała, żebyśmy
zrobili kolejne,
zadanie.
Tutaj w oparciu o,
już pokazuję.
Dobra, no, otóż
chciałabym, żebyście Państwo zrobili,
spróbowali sobie,
naszkicować przynajmniej fragmenty
takiego właśnie
diagramu klas, gdzie nazwy
klas macie Państwo tutaj podane.
Szkoła,
boisko, dyrektor,
klasa, uczeń, nauczyciel,
grono nauczycielskie, stołówka,
sala, stół,
krzesło, tablica, książka,
biblioteka.
To jest,
tego typu zadania czasem się pojawiają
na egzaminie, także myślę,
że takie ćwiczenie może
być pomocne, jako przygotowanie
przyszłości do egzaminu
i, no, może nie z taką
dużą liczbą słów, ale może z jakąś
mniejszą. Musicie się Państwo liczyć, że
podobne zadania, jak te, które były właśnie
w pracy domowej, pojawią się
na egzaminie.
Możecie Państwo sobie,
no, zacząć to
robić. Ja tutaj, chodzi mi tu
w szczególności o taki diagram klas,
który będzie wszystkie te klasy
pokazywał, ale jeśli ktoś na początku
ma jakieś tutaj,
problemy z takim
tworzeniem diagramów klas,
to może zacząć od jakiegoś fragmentu.
Czyli, proszę popatrzeć, mamy tutaj
jakąś rzecz związaną,
czy część rzeczowników związanych
z osobami. Na przykład
dyrektor, uczeń, nauczyciel,
grono nauczycielskie.
Czyli, na przykład, no,
jak mamy dyrektor, uczeń,
nauczyciel, to aż się prosi, żeby
wprowadzić klasę abstrakcyjną,
która pewne cechy
wspólne tych klas będzie gromadziła,
tak? I można ją sobie nazwać, nie wiem,
na przykład osoba, czy człowiek, czy jakoś tam.
No i teraz
taki dyrektor jest pewnym
typem osoby, uczeń też jest pewnym
typem osoby,
nauczyciel też jest pewnym typem osoby.
Dalej, w zależności
od tego, jak ustawicie Państwo relację
dziedziczenia, to
albo możecie pokazać, że dyrektor
jest pewnym szczególnym nauczycielem,
albo może niekoniecznie, bo
można sobie wyobrazić szkołę, w której
dyrektor wcale nie jest nauczycielem.
No a grono nauczycielskie,
to co to jest? No to grono
nauczycielskie składa się, zawiera
nauczycieli, więc
tutaj też, tutaj byłaby relacja
agregacji po stronie grono nauczycielskiej.
No i teraz
mamy tutaj znowu jakieś
słowa takie, jakieś rzeczowniki
związane, no, z pewną budową
tej szkoły, prawda? Czyli mamy
boisko, no, pytanie
klasa. Tutaj różnie
Państwo możecie do tego podchodzić.
Ta klasa może być takim
pomieszczeniem w tej szkole,
albo można widzieć, że klasa
to jest zbiór uczniów,
czyli klasa zawiera
wiele obiektów klasy
uczeń. To już jest
jak gdyby do Państwa
decyzji, jak to rozwiązać.
No dalej coś mamy, sale,
tak, czyli pewnie jakieś sale
znajdują się w tej szkole.
Stołówka może być pewnym
typem tej sali.
No i dalej
można pokazać, że w sali znajduje się
stół, krzesło, tak, ewentualnie
tablica.
Dalej znowu jakaś
decyzja, czy biblioteka
jest zbiorem książek,
czy biblioteka to jest może
po prostu pewna specjalna sala,
która w tej szkole się znajduje.
Czy ktoś z Państwa może jakiś
kawałeczek naszkicował i chciałby się,
wyraziłby
zgodę na
pokazanie swojego rozwiązania
koleżankom i kolegom?
Nie ma chętnych?
Albo może ktoś mógłby
na bieżąco
zacząć rysować taki diagram?
Będziemy podpowiadać, jak
i co.
Jeśli nie ma chętnych,
to ja spróbuję jakieś rozwiązanie
Państwu pokazać.
O ile mi się zgłosi
Aleksander?
Tak jest.
Ok, no więc proszę popatrzeć
jakiś jedno z możliwych rozwiązań.
Zawsze w takich przypadkach
tych rozwiązań,
może być kilka.
Tutaj ja widzę szkołę
jako pewien
twór architektoniczny,
czyli szkoła
składa się,
zawiera salę, tak?
I teraz proszę popatrzeć.
Z salą mogą być związane
dowolnie wiele krzeseł.
Z salą może być
związana przez relacje,
asocjacji,
tablica, może wiele tablic,
może być wiele stołów
w tej sali. Sala
pewnym typem sali może być
stołówka, pewnym typem sali
na przykład może być biblioteka
i wtedy z biblioteką
może być związanych wiele
książek.
Tutaj
nie mam relacji, agregacji,
że biblioteka zawiera książki,
bo ja poprzez tą relację
generalizacji pokazuję,
że biblioteka jest pewnego
typu salą, prawda? Czyli
widzę bibliotekę jako pomieszczenie,
a nie jako zbiór książek.
Ale można by to rozwiązanie
zmienić w inny sposób.
Wtedy taką bibliotekę jako zbiór
książek można by po prostu połączyć
relacją asocjacji ze szkołą.
No i boisko jest związane
z tą szkołą. Teraz z tą
szkołą związanych jest
wiele klas. Tutaj u mnie
klasa jest widziana, tak jak Państwo
widzicie, jako zbiór uczniów.
Klasa zawiera
dowolnie wiele obiektów klasy uczniów.
Mam
klasę abstrakcyjną osoba.
Osoba
może być to uczeń. Osoba
może być to nauczyciel.
Nauczyciel wchodzi w skład
grona nauczycielskiego,
które jest też tutaj
asocjacją związane ze szkołą
1 do 1. Jedno grono
nauczycielskie z jedną szkołą związane
do
tego grona
nauczycielskiego. Mamy
asocjacje z dyrektorem, który
zarządza, kieruje
tymi nauczycielami
i w tej mojej szkole dyrektor
jest pewnym specjalnym
typem nauczyciela.
I też tutaj jeszcze za pomocą relacji,
asocjacji
mam połączonego
dyrektora ze szkoły.
Znowu może w międzyczasie
ktoś z Państwa
ktoś z Państwa
zrobił swoje
swój diagram i
wyraziłby zgodę
na to, żeby ten diagram pokazać
i omówić.
A to jest tak,
że ten dyrektor to
jest jednym z typów nauczyciela,
tak?
Jeszcze raz.
To jest tak, że ten dyrektor
jest jednym
z typów nauczyciela, tak?
U mnie tak, ale
nie musi być
to
takie
rozwiązanie.
Można by sobie
wyobrazić, że
dyrektor
nie jest nauczycielem, wtedy
tutaj ta
generalizacja by została
zniesiona i można by wtedy
powiedzieć, że no, ale też tutaj tą
generalizacją pokazać,
dyrektor jest osobą. Na przykład
taki dyrektor zarządzający szkołą,
który jest bardziej menadżerem,
a nie jest nauczycielem.
Ale on jakoś tam kieruje tym
gronem nauczycielskim, więc ta asocjacja
by została, a zamiast
tej generalizacji, że dyrektor jest
nauczycielem, moglibyśmy pokazać, że
dyrektor jest pewnym typem
osoby.
Może coś jeszcze
ktoś z Państwa ma jakieś
jakieś obserwacje?
Proszę Państwa,
tutaj już takie zadanie
żeśmy robili, ale jeszcze raz
pokazuję, ponieważ
w kilku rozwiązaniach, które od Państwa
dostałam, było
niewłaściwe skierowanie
relacji generalizacji,
czyli relacji dziedziczenia.
A więc ta strzałka
relacji dziedziczenia
pokazuje na klasę ogólną,
na klasę, w tym wypadku klasę
abstrakcyjną urządzenia
rejestracji dźwięku, takim urządzeniu,
jest kamera,
takim urządzeniem może być
dyktafon, przypomnę, że czasem
możemy stosować tak zwane
constraints, czyli pewne
ograniczenia, czy pewne
jeszcze doprecyzowujące
na jak
tutaj te relacje wyglądają.
W tym wypadku mówimy, że nie
są to jedyne urządzenia
rejestracji dźwięku, ta
relacja tej generalizacji
i tu i tu jest niekompletna, że
można sobie wyobrazić, że tutaj w przyszłości
będą dodane jakieś inne klasy
jeszcze.
To jest, proszę Państwa, też
no już rzecz, która
w tym
zadaniu z tą szkołą była użyta,
ale jeszcze też chcę zwrócić uwagę
na to, gdybyśmy mieli do
narysowania diagram klas
dla takiego zdania. W sali
są studenci,
krzesła,
tak, sala ma
ściany, na przykład 4,
ma sufit, ma podłogę.
No to
tutaj zwracam uwagę
też na taką rzecz. Ja
widzę salę jako
pewien twór
architektoniczny, tak,
czy taki budowlany. Czyli
mówię, sala ma, ta moja sala ma
4 ściany, tak.
W mojej sali jest sufit.
Sufit jest częścią składową
tej sali i również podłoga.
Czyli tu mam relację agregacji.
Widzę salę jako
pewien twór architektoniczny.
Ze ścianami, sufitem
i podłogą. Nawet jeżeli
w zdaniu mam, w sali znajdują się
studenci, w sali
znajdują się krzesła,
to ja nie mogę tutaj
pokazać relacją
agregacji, że w sali znajdują się
studenci. Dlatego, że
jeżeli ja używam relacji
agregacji dla jakiejś
klasy, w tym wypadku tutaj jest ta
klasa sala, to wszystkie
elementy składowe muszą być
no w cudzysłowie
z tej samej bajki, z tej samej
kategorii. Czyli tutaj mam
właśnie jakieś elementy
no architektoniczne.
Ściana, sufit, podłoga.
A student nie jest takim elementem
architektonicznym, prawda? Jest osobą.
Więc dlatego tutaj
nie mogę użyć relacji agregacji.
Podobnie nawet jeżeli
powiem, w sali znajdują się
krzesła, to to krzesło
nie jest elementem składowym sali,
tak? Ono nie jest, nie wchodzi,
owszem znajduje się we
wewnątrz niej. Mogę tak to
zamodelować, ale nie jest jej
elementem składowym, bo znowu nie jest
jeżeli widzę salę, tak jak
tutaj, jako pewien twór architektoniczny,
to krzesło nie jest takim tworem
architektonicznym. Krzesło
jest z innej kategorii.
Krzesło jest z innej bajki.
Dlatego mam tutaj to połączenie
zrobione za pomocą
relacji asociacji.
Asocjacje są tutaj dwukierunkowe,
bo zarówno chcę wiedzieć,
prawda, jakie krzesła są w tej
sali, jak i również to krzesło,
jak gdybym mogłoby wiedzieć, w jakiej sali się
znajduje. No i tutaj relacja
asociacji jeden do jednego, tak?
Każdy student ma
jedno krzesło, tak? Z jednym
krzesłem związany jest dokładnie
jeden student. Czy to jest
dla Państwa jasne? To też jest,
proszę Państwa, typowy błąd, który pojawia
się na egzaminach,
że jeżeli używacie relacji
agregacji, to
te elementy składowe,
tak? Tej klasy
będącej całością, muszą być
z tej samej kategorii, czyli na przykład
osób nie można łączyć z
jakimiś tam przedmiotami.
Czy ktoś może ma do tego jakieś
pytania, uwagi?
...
A trzeba
pisać te numery?
Tak.
Znaczy, czy trzeba
pisać te numery, czy to
jest takie opcjonalne, te
jeden do czterech na przykład albo?
...
Wie Pan, no
ważne jest, żeby te
liczności określać, tak?
U mnie ta sala akurat
ja sobie tu przyjęłam, że ma cztery
ściany. No, ale
nie wiem, ktoś mógłby sobie wyobrazić,
że ta sala ma trochę
inną budowę, tak? Że na przykład
może być to sześciokąt, czy
ośmiokąt, czy
jakiś inny. Także
tutaj to jest jak gdyby
Państwa założenie, chyba,
żeby to z treści zdania
wyraźnie wynikało, tak? Ale
jakieś takie
liczności powinniście Państwo
podać, no takie, które wynikają
no nazwijmy to
z wiedzy ogólnej.
Ale również możecie tutaj swoje
założenia podać. Czyli jakby ktoś napisze
sześć tutaj w przypadku tej, że
sala zawiera sześcian i napisze mi
zakładam, że moja sala
ma taką i taką budowę,
jest w kształcie sześciokąta,
to ja to będę akceptować.
Czy coś
może jeszcze?
To proszę Państwa kolejna,
jak gdyby kolejny
przykład z tej kategorii.
Wyobraźmy sobie, że dostajecie Państwo,
to jest te zdanie, które na jednym
z egzaminów się pojawiło,
czy czasem się pojawia,
w plecaku znajdują się
książki zeszyty.
I
no być może
jeszcze, więc
tutaj mam relacje
asocjacji.
Wprowadziłam klasę abstrakcyjną
przedmiot. Książka,
zeszyt są pewnym
przedmiotem u mnie.
Tak to nazwałam. Można by sobie to inaczej
wyobrazić. Można
by sobie wyobrazić, że książka jest
pewnym typem zeszytu albo zeszyt
jest pewnym szczególnym przypadkiem
książki. Tutaj jak gdyby te rozwiązania
mogą być różne.
Ale teraz tu jest
asociacja. Dlatego, że znowu ta książka
czy ten zeszyt nie są
elementem
budowy plecaka. I tutaj pokazuje
tą budowę tego plecaka.
Że ten mój plecak ma
kilka komór. Że ten mój plecak
może tutaj powinien podać niewiele,
tylko co najmniej
jedną powinien mieć, żeby
to jak gdyby
miało rację bytu.
Czyli tutaj gdzieś powinna być
nie gwiazdka,
tylko na przykład od jeden do gwiazdka.
Tak? Co najmniej jedną komorę,
być może więcej.
Szelki. No plecak bez szelek jakoś
też się wydaje być mało
prawdopodobny.
Czy nie będzie plecakiem wtedy,
więc może też powiedzmy
no i tutaj mogę wprowadzić
na przykład, nie wiem, dwie szelki.
Lub więcej, jeżeli
to jakoś tam uzna.
Dobra, czy może do tego mają Państwo
jakieś pytania, uwagi?
To proszę Państwa
pewnie bym tutaj
na tym ten przykład bym zakończyła.
Zaraz momencik, ja
tutaj po pierwsze
dokonam zapisu
tego cośmy tu zmienili.
I następnie
opuszczę
software architekta.
Tak i na razie się odłączę
od
Aleksandra.
Dobra, czy może
ktoś w międzyczasie coś jeszcze
sobie narysował?
Czy ma jakieś pytanie
do tych rzeczy,
które
robiliśmy przed chwileczką?
Robiliśmy przed chwileczką.
Tego typu,
jeszcze raz przypominam,
tego typu zadania
na pewno będziecie Państwo
mieli na egzaminie.
Jeszcze właśnie
a propos egzaminu, to
proszę Państwa jest taki plik
udostępniony, który chyba się nazywa
zadania po prostu.
I
te zadania,
które żeśmy tutaj
przed chwileczką rozwiązywali
znajdują się w tym pliku.
Również te elementy.
To co było
jako praca domowa.
Chwileczkę, ja coś kiepsko Państwa
słyszę.
Chwileczkę coś pokombinować tutaj
z głośnikiem.
Ok, teraz
powinno być lepiej.
Dobra i proszę Państwa
jeszcze raz
ponawiam pytanie, czy nie ma przypadkiem
komuś się coś przypomniało
może?
Jeżeli nie
to przechodzę do
kolejnej prezentacji
i kolejnego
tematu. Mianowicie
teraz będę chciała Państwu
opowiedzieć, tak jak tutaj widzicie
o diagramach sekwencji.
Proszę Państwa, no
do tej pory poznaliśmy
dwa typy
diagramów UML-owych.
Diagramy use case to są
diagramy, które mówią
co ten system może
robić, prawda? Kto w tym
systemie może pracować?
Diagramy class
na których modelujemy
co ten system
musi zawierać, żeby
te funkcje, które określiliśmy
na diagramach use case
dało się
zrealizować.
No i teraz musimy
przejść już
do tego, a jak te funkcje
można
zrealizować? W jaki sposób
te i które
obiekty, których class
ze sobą będą musiały
współpracować, żeby te
funkcje, które
w use case'ach żeśmy określili, dały
się zrealizować? I to
właśnie będą do tego celu
służyły diagramy
sekwencji.
Nazywają się one
sequence diagram.
I to jest proszę Państwa
typ diagramu, który pokazuje
już pewne rzeczy, które się dzieją
w systemie. Który
pokazuje jak zrealizować
pewne rzeczy. Na przykład
jak zrealizować
use case'a.
Eee...
Potem będą one, często są
używane również do testowania
końcowego.
I bardzo istotna
rzecz, mianowicie proszę Państwa
każdy taki diagram
sekwencji
to jest jedna ścieżka
wywołania gotowego programu.
Czyli
na przykład to jest
taki diagram sekwencji
będziemy rysować
dla use case'a.
Taki dla use case'a
będziemy rysować
jeden diagram sekwencji.
Taki diagram sekwencji
będzie pokazywał jak ten
use case można realizować.
Eee...
Te diagramy sekwencji tak jak już
mówiłam to jest
pewien model dynamiczny
systemu, który
pokazuje jak zrealizować
pewną czynność
w systemie. Czyli
właśnie będzie pokazywał
jak współpracują ze sobą
obiekty. Tak?
Jak one się komunikują.
Jak współpracują.
Pewna współpraca ich w czasie
daje nam tą
no użyteczną jakąś
funkcję systemu.
Tutaj czas
będzie rósł w kierunku
do diagramu.
I teraz popatrzmy jak
wyglądają elementy
takiego diagramu sekwencji.
Przypomnę Państwu
jak mówiłam takie podstawy dotyczące
analizy obiektowej czy
systemów obiektowych to mówiłam
Państwu system obiektowy
tak? To co ten system robi
to wynika ze współpracy
obiektów tego
systemu. Czyli właśnie
diagram sekwencji za pomocą
którego będziemy modelować
jak zrealizować
pewną czynność
pewną funkcję systemu
to będą w nim uczestniczyły
obiekty. Przypominam,
że taki prostokąt
w środku nazwa
klasy po dwukropku
podkreślenie
to jest obiekt. To jest symbol
graficzny obiektu w WML-u.
Ja tu mogę jakiś
identyfikator wpisać na przykład mój
obiekt nazywa się A.
Tutaj taka linia
przerwana właśnie modeluje
upływ czasu i ten
czas rośnie w kierunku
dołu tego
diagramu. Czyli
mam obiekt, ta linia
przerwana to jest tak zwana
linia życia tego obiektu
i na tej
również widziana jako oś czasu
i na tej osi czasu
będziemy pokazywać
komunikaty, które
ten obiekt wysyła
lub które do tego
obiektu są dostarczane.
I
tutaj mam taki przykład
z identyfikatorem.
Ten Freshman jest identyfikatorem
obiektu klasy
student. Linia
życia. Czas rośnie w kierunku
dołu tego ekranu.
Przypominam nazwa klasy
dużą literą, podkreślenie.
Mamy tutaj obiekt o identyfikatorze
Freshman.
Teraz właśnie te komunikaty.
Otóż proszę Państwa
komunikaty mogą być
różnego rodzaju.
I tutaj bardzo ważną
rzeczą jest po raz setny
czy 150
przypominam, że
UML jest standardem
i symbole graficzne
mają ściśle określone
znaczenie. I dlatego
na przykład osoby, które
rysowały elipsy jako
klasy nie dostały
żadnych punktów za pracę domową.
A jeżeli w egzaminie
ja zobaczę takie elipsy
zamiast klasy to będą
punkty ujemne.
Musimy
stosować notację
UML-ową. To jest standard.
I no nie ma tam wiele symboli graficznych.
Można mieć
sobie ściągę i trzeba te
symbole graficzne właściwie używać.
I tutaj proszę Państwa w przypadku
komunikatów kluczową
sprawą są groty strzałek.
Bo widzicie Państwo, że taki
komunikat jest to
po prostu taka strzała,
tylko że mogą być różne groty.
W przypadku jeżeli
taki grot jest otwarty
tak jak tutaj Państwo widzicie
to jest to komunikat asynchroniczny.
Co to oznacza,
że jest komunikat asynchroniczny?
Jeżeli mam tutaj jeden
obiekt
i tutaj mam
drugi obiekt
i mam linie życia
tych obiektów
i teraz ten obiekt wysyła
komunikat asynchroniczny
do tego drugiego obiektu
to znaczy, że
ten obiekt może dalej się wykonywać
i ten się też może
wykonywać, może wykonywać
właśnie ten komunikat,
czyli tą operację, która
tutaj została w nim wywołana.
To jest komunikat asynchroniczny.
W przypadku komunikatu
synchronicznego
w przypadku komunikatu
synchronicznego mam jeden obiekt,
mam drugi obiekt, mam linie życia
i teraz
jeżeli tutaj wysyłam
komunikat asynchroniczny,
czyli ten grot jest
wypełniony
to
proszę Państwa, ten się tu wykonywał
wysłał ten komunikat
i stoi
i teraz może się ten wywoływać
i teraz może on na przykład
albo wywołać komunikat
synchroniczny
z tego, albo może
tutaj pokazać, że jest
taki powrót, jak zakończy
wykonywać ten komunikat,
który tutaj był wywołany
to sterowanie wraca
do tego obiektu, który tutaj
nazwijmy go obiektem pierwszym,
który ten komunikat wysłał
i znowu on się
dalej może wykonywać.
Taki powrót sterowania
możemy pokazywać za pomocą
linii przerywanej.
Jeżeli korzystamy
przy rysowaniu diagramów sekwencji
z narzędzi typu CASE
no to zwykle
taki powrót sterowania jest
zaznaczany automatycznie.
Co to jest ten komunikat
proszę Państwa?
Otóż ten komunikat
to jest to operacja
w tej klasie odbierającej
czyli w tej, do której
to zostało skierowane.
To jeżeli
tutaj mam jakąś nazwę
to znaczy, że w tej klasie
do której ten komunikat jest skierowany
w tym wypadku nie ma znaczenia
czy to jest
asynchroniczny
czy synchroniczny
musi znajdować się operacja
o tej właśnie nazwie.
No i popatrzmy na taki
troszkę lepiej narysowany
przykład diagramu sekwencji.
Mam
dwa obiekty
o nazwach Instance1
Instance2
Proszę Państwa
to Object2, które tu mam
czy Object1 to jest to nazwa
klasy. Tak też możemy
sobie wyobrazić.
Mamy linie życia tych obiektów.
Obiekt
Instance1 wywołuje
komunikat synchroniczny
klasie
Object2
po
jego zakończeniu sterowanie
wraca do tego
Instance1
na przykład tutaj on wykonuje
wywołuje teraz komunikat
asynchroniczny, czyli teraz
mogą się wykonywać
oba równocześnie.
Teraz proszę Państwa
co ja mogę
wywnioskować
co ja mogę wywnioskować
z takiego diagramu
sekwencji. Otóż
musimy pamiętać o tym
że musimy zachować
spójność pomiędzy
diagramami sekwencji
i diagramami klas.
A więc co ja mogę wywnioskować
o diagramie klas
jeżeli mam taki diagram
sekwencji. Czyli po pierwsze
mogę powiedzieć tak
mam dwie klasy
lub na pewno te dwie
które tutaj widzę.
Pierwsza się nazywa
ja już skrócę sobie
jako Object1
druga się nazywa
Object2
troszkę tą nazwę skróciłam
teraz o atrybutach
tych klas nie wiem nic
nie wiem nic
natomiast
wiem coś nie coś
o operacjach
klasy Object2
widzę, że tutaj
ten komunikat
Synchronous Message
to jest proszę Państwa nazwa
operacji, która w tej klasie
Object2 musi się znajdować
podobnie ta
operacja też
musi się znajdować tutaj
w klasie Object2
czyli mogę na podstawie
diagramu sekwencji
wnioskować o tym jakie
klasy znajdują się w systemie
jakie operacje
w tych klasach się znajdują
co dalej mogę wywnioskować
otóż proszę Państwa
mogę wywnioskować
co powinno być na
systemie klas
żebym ja taki diagram
sekwencji mogła narysować
mianowicie musi być
jakaś droga komunikacji
pomiędzy klasą Object1
i klasą Object2
musi być
no na przykład
relacja asocjacji pomiędzy
tymi klasami
co więcej
pamiętamy, że asocjacje mogą być
jednokierunkowe
lub mogą być dwukierunkowe
ja narysowałam
asocjacje dwukierunkową
dlaczego narysowałam dwukierunkową
asocjacji
ze względu na to
że tu widzę
że jest użyty komunikat synchroniczny
czyli
że musi wrócić
coś
przynajmniej sterowanie
a może również jakieś parametry
tej operacji
muszą być zwrócone
do obiektu instance1
wobec tego musi być
tutaj komunikacja
w obu kierunkach
dlatego narysowałam tą asocjację
jako asocjację dwukierunkową
czy to jest jasne
to co w tej chwili powiedziałam
bo to jest znowu podstawa
do kolejnego typu zadań
które zazwyczaj na egzaminie
się pojawiają
wszystko jasne
no to
przechodzimy na
kolejny przykład
troszkę bardziej złożony
diagram sekwencji
mamy
tutaj trzy klasy
klasy klient
klasy system rezerwacji
klasy baza danych
w tej klasie jest jakiś identyfikator
w tych klasach nie ma
i mamy
pewne
pewną sekwencję
tutaj komunikatów pokazano
zaczyna klient
wywołuje operację
otwórz rezerwac
z klasy s rezerwacji
i jest to
operacja asynchroniczna
czyli klient
może się tu wykonywać dalej
i
teraz
obie klasy system rezerwacji
wykonuje tą operację
otwórz rezerwac
żeby to zrobić
to wywołuje operację
synchroniczną
asynchroniczną
w klasie baza danych
czyli teraz też robi się ta
klasa wykonuje tą operację
sprawdź dostępność
tutaj widzę powrót sterowania
czyli ta operacja asynchroniczna
się zakończyła
sterowanie wraca do systemu rezerwacji
który w międzyczasie coś mógł robić
kończy tą operację
otwórz rezerwacji
i wraca sterowanie do klasy system rezerwacji
klasy klient
kolejną
komunikat wywołuje klient
z tego
s rezerwacji
w pr dane pewnie wprowadź dane
żeby znowu jest to
asynchroniczna
czyli potencjalnie klient coś może
robić i ten system
rezerwacji teraz wykonuje
tą operację
czyli wywołuje komunikat
rezerwuj w klasie baza danych
też asynchroniczny
ale proszę popatrzeć
co tutaj jest zrobione
mianowicie nie widzę tutaj
powrotu sterowania tylko ten
powrót sterowania jest
zrealizowany poprzez
wywołanie operacji asynchronicznej
potwierdź w
klasie system rezerwacji
ten
znowu wraca
to sterowanie do klienta
swoją operacją potwierdź
znaczy wywołuje operację potwierdź
w klasie klienta
swoją operację synchroniczną
zamknij ten system
rezerwacji no dobra
to proszę państwa teraz przed chwileczką
mówiłam państwu
jakie muszą być
zależności co musi być
w diagramie klas żeby
taki diagram sekwencji
można było narysować
co czyli muszą być trzy
klasy klient
z rezerwacji baza danych
co dalej
teraz muszą być
asociacje pomiędzy tymi
pomiędzy klientem a systemem
rezerwacji prawda bo on się
tutaj komunikuje jaka to
powinna być asociacja pomiędzy
klientem i systemem rezerwacji
komunikacja jest w
jedną stronę czy w obie strony
no widzimy że w
obie strony są wywołane komunikaty
a co więcej widzimy
tutaj komunikat synchroniczny
jak widzimy komunikat
synchroniczny to wiadomo że
pomiędzy tymi klasami
musi być asociacja dwukierunkowa
pomiędzy klasą system rezerwacji
a klasą baza danych
widzimy że też jest
komunikacja dwukierunkowa
więc też musi być
asociacja dwukierunkowa
no i teraz gdzie będziemy
umieszczać te operacje
czyli jakie operacje
są w klasie S rezerwacji
otwórz rezerwacji
w klasie wpr dane
zamknij
i co jeszcze
i potwierdź ta operacja
wywoływana z bazy danych
w klasie baza danych mam
operację spr dostępność
rezerwuj
i tyle
w klasie klient jakie mają być
operacje
otwierdź
operacja zamknij jeszcze musi być
w klasie system rezerwacji
wobec tego ten diagram klas
spójny z tym diagramem sekwencji
czy fragment diagramu klas
taki który daje nam
szansę na rysowanie
takiego właśnie diagramu sekwencji
jak przed chwileczką pokazałam
mógłby wyglądać właśnie
w ten sposób
klasa klient
klasa S rezerwacji
klasa baza danych
o atrybutach tych klas
nic nie mogę powiedzieć
że te operacje
muszą być dwukierunkowe
bo widzieliśmy że te operacje
są wywoływane
z jednej klasy do drugiej klasy
tu była również
operacja synchroniczna
więc na pewno musi być
asociacja dwukierunkowa
i mamy umieszczone
te operacje które występowały
czyli te nazwy komunikatów
które występowały
w diagramie sekwencji
one są poprzedzone u mnie
w tym odcinku
co znaczy
że są to operacje publiczne
no właśnie żeby klient
mógł wykonać jakąś operację
z klasy S rezerwacji
takie jak otwórz
czy zamknij
czy operacja potwierdź
przez bazę danych
żeby mogła być wywołana
to muszą być to operacje publiczne
stąd plus przed nazwą tych operacji
czy do tego
może ktoś z państwa ma jakieś pytania
na ten temat
no dobrze to popatrzmy
na kolejny prosty przykład
diagramu sekwencji
klasa financial analyst
i identyfikator obiektu
klasa reporting system
identyfikator obiektu
security system
też pewien identyfikator obiektu
tego obiektu
wywoływany jest
komunikat synchroniczny
get available reports
i to jest proszę państwa
taki obrazek takiego diagramu
jaki zazwyczaj dostajemy
w narzędziach typu case
czyli w momencie jak
obiekt
system otrzymuje
ten komunikat get available reports
i musi wykonać
metodę get available reports
to znaczy że on
się wykonuje
i to jest takim prostokątem
zaznaczane na tej linii życia
to się nazywa
czasem aktywacji obiektu
no bo ten obiekt coś robi
musi być aktywny żeby to coś zrobić
teraz tutaj
żeby zrealizować tą operację
get available reports
to on komunikuje się
z innym
obiektem
sex system
tutaj wywołuje pewną metodę
z jakimś tam parametrem
wywołuje w sposób synchroniczny
i to jest tutaj
widzicie państwo teraz
wywołuje czas aktywacji
tego obiektu sex system
bo on wykonuje tą metodę
get security clearance
mamy tutaj
powrót sterowania
i na takim powrocie sterowania
czasem nie zawsze
ale możemy zaznaczyć
wartość czyli właśnie to
user clearance tak jest
zwracane do obiektu system
a z kolei
tutaj mamy powrót sterowania
zaznaczony i widzimy
że obiekt system
zwraca available reports
do obiektu
klasy financial analyst
może jakieś pytania
ktoś z państwa ma
dobra
teraz proszę państwa popatrzmy
właśnie to co mówiłam
takim prostokątem jest zaznaczany
czas aktywacji obiektów
czyli wtedy kiedy one
muszą być w pamięci operacyjnej
bo coś robią
i tutaj
no jeszcze
ponowne wyjaśnienie
tych synchronicznych
i asynchronicznych komunikatów
jeżeli komunikat jest
asynchroniczny tak jak tu widzimy
to się może ten obiekt
wykonywać tutaj
i może się wykonywać
obiekt klasy B
jeżeli natomiast byśmy zrobili tutaj
to jako obiekt
komunikat
synchroniczny
czyli teraz ten jest
tutaj synchronicznym komunikatem
to proszę państwa
ten obiekt klasy A
stoi
dopóki tutaj nie dojdzie
do niego czy on się tutaj nie wykonuje
dopiero zaczyna się
wykonywać wtedy kiedy do niego
wróci sterowanie
zakończy się ta operacja
zakończy się metoda
proszę państwa
diagramy sekwencji
jeszcze raz przypomnę to co mówiłam
na samym początku dzisiaj
że diagram sekwencji
to jest pokazanie jak
pewna funkcja w systemie
jest realizowana
obiekty których klas
ze sobą muszą współpracować
żeby coś użytecznego
ten system dostarczył
żeby jakąś funkcję zrealizował
wobec tego bardzo istotna
jest również w tych
diagramach sekwencji
projektując te diagramy
musimy również
panować nad
strukturą sterowania
no i tutaj popatrzmy
jakie mamy możliwości
czyli często robimy
na przykład tak
że tworzymy obiekt
pewien specjalny obiekt
który będzie takim obiektem
sterującym
i tutaj mam taki obiekt
klasy A
który steruje całym przebiegiem
tego use case
czasem
się tak to robi
jeżeli mam tutaj na przykład fragment
diagramu use case
czyli mam aktora połączonego
z use case
tutaj mam na przykład
aktora A
i mam na przykład use case który pokazuje
funkcję pierwszą
to ja tworzę
taki obiekt
który
będzie
sterował właśnie
przebiegiem tego use case
dla tego konkretnego aktora
tak się czasem robi
no i właśnie widzimy
mamy tutaj wszystkie
komunikaty do
różnych obiektów obiektu B
i C wychodzą z tego
obiektu sterującego
czyli mamy tutaj takie
centralne sterowanie
centralne zarządzanie
przebiegiem tego use case
wywołujemy
żądamy wykonania pewnych czynności
przez inne obiekty
ale sterujący
jest ten obiekt
to jest jedno
z możliwych rozwiązań
ale możemy też sobie to wyobrazić
zupełnie inaczej
mianowicie właśnie
nie mamy takiego obiektu
jednego który wszystkim
zarządza i steruje
ale
mamy tutaj wywołanie
pewnej metody
komunikatu wysłany
komunikat jest do obiektu klasy B
komunikat się nazywa
oper 1 żeby to zostało
zrobione to on prosi
obiekt klasy C o wykonanie
jakiejś operacji
tutaj mamy nazwy tej operacji
potem znowu sam coś robi
i zwraca ten rezultat
zwraca sterowanie
do tego obiektu klasy A
czyli tutaj możemy również
projektować te przebiegi
wykonania czegoś
w taki sposób że nie ma
jednego obiektu który
przebiegiem zarządza steruje
tylko właśnie za pomocą
komunikacji
przesyłania komunikatów
sekwencja wywołań tych komunikatów
daje nam coś użytecznego
możemy mieć taką strukturę
zdecentralizowaną
teraz proszę Państwa
czasem jest tak
że w wyniku wykonania
w trakcie wykonania
tej sekwencji
wywołań komunikatów
jeden z obiektów
będzie niszczony
albo może być tak że
jakiś obiekt zostanie utworzony
i tu mamy taki przykład
który pokazuje jak to modelować
na diagramach sekwencji
przypomnę Państwu że takie
podwójne nawiasy kątowe
w UMLu
to są
stereotypy myśmy już takie
stereotypy
wcześniej tam mieli na diagramie
klas na przykład
i
mamy tutaj możliwość
użycia takiego stereotypu
create żeby
pokazać że obiekt tej
klasy platnost
zostanie utworzony
i mam tutaj wywołane
komunikat zapłać
no bo nie mam polskich czcionek
prawda tak jak mówiłam
nie powinniśmy ich używać
no dobrze i mam dodatkowo
ten stereotyp create
co ja mogę powiedzieć
jakiego typu jest ta operacja
zaplać w klasie
platność
ktoś z Państwa
wie co to będzie za
typ takiej operacji
create
tak to znaczy
że obiekt tej klasy zostanie
utworzony
a jak się tworzy obiekty
w programowaniu obiektowym
jaki typ operacji
jak się nazywa taką operację
no to jest konstruktor
tej klasy
czyli ta klasa platność
ma konstruktor który się nazywa
zaplać tak bo mam
tutaj użyty stereotyp
co oznacza że ten
komunikat ta operacja
tworzy obiekt klasy platność
czyli jest to konstruktor klasy platność
teraz tutaj mam
z kolei w trakcie prawda wykonania
tego
tej operacji mam wysłany
komunikat proszę popatrzeć
komunikat tu jest akurat synchroniczny
anuluj do
obiektu klasy wierzytelność
i tutaj mam
za pomocą stereotypu
określony typ tej operacji
i jeszcze
no co należy
zrobić z tym obiektem wierzytelność
mianowicie mam tutaj użyty
stereotyp destroy
czyli znaczy to zniszcz
a więc znaczy to
zniszcz obiekt klasy wierzytelność
to że ten obiekt
będzie zniszczony to tu
proszę państwa też modelujemy
takim krzyżem na tej linii życia
czyli no tu krzyżyk mu na tej linii
życia stawiamy co znaczy że nie
będzie dalej ten obiekt istniał
no więc znowu jaki
co to znaczy co mogę
powiedzieć o tej operacji
anuluj która oczywiście musi
być w klasie wierzytelność jaki
to jest typ operacji
tu był konstruktor
to tu będzie przy
destroy musi być destruktor
tej klasy
czyli niszczę obiekt
klasy wierzytelność
czy to jest jasne
tak tak
dobra proszę państwa
teraz w poprzednich przykładach
pokazywałam takie przesyłanie
komunikatów od
obiektu do innego
obiektu ale
czasem może być
potrzeba również wywołania
jakiś operacji własnych
czyli obiekt
dostaje komunikat
a więc wywoływana jest pewna
metoda
pewna operacja w tym obiekcie
i teraz żeby tą operację
żeby tą metodę zrealizować
to on musi również jakieś
swoje operacje
prywatne metody
prywatne wykonać
i to również modelujemy
możemy zamodelować
taką sytuację na diagramie
sekwencji tutaj mamy właśnie
taki przykład czyli mam
klasę formularz
linie życia
czas aktywności
tego obiektu klasy formularz
i proszę popatrzeć
takim uchem tak pokazujemy
wywołanie to się nazywa
samowywołanie albo message to self
czyli to jest
praktycznie wywołanie
metody prywatnej
jest to na
diagramach sekwencji pokazuje się
jak gdyby taki drugi czas aktywności
który pokazuje że ta
metoda sprawdź kompletność jest
wykonana wykonywana
co więcej ja mogę
powiedzieć o tej klasie
formularz tak
zaraz to
czyli tu mam klasę formularz
o atrybutach tej
klasy nie mogę powiedzieć nic
ale tutaj
jeżeli mam takie
no taki message to self
takie samowywołanie to
znaczy że to powinna być
metoda prywatna
czyli to sprawdź
kompletność
tak
dalej nie będę pisać bo myszko mi się kiepsko
pisze to jest
to minusik przypomnę oznacza
metodę prywatną to
sprawdź kompletność to będzie
metoda private
to jest metoda private
prawda prywatna nie ma
widać że ona jest na swoje potrzeby używane
nie ma powodu żeby była
udostępniona na zewnątrz
proszę Państwa
diagramy sekwencji
mówiłam Państwu dzisiaj już kilkakrotnie
na nich projektujemy
na nich modelujemy
przebieg wykonania czegoś
użytecznego w tym systemie
wykonania pewnej funkcji
i
no czasem
te przebiegi są bardzo złożone
duże
skomplikowane
więc dzielimy te przebiegi
na takie mniejsze
części składowe
tak jak powiedzmy
złożony kod programu
dzielimy na procedury
funkcje
tak samo robimy takie samo
podejście stosujemy w diagramach
sekwencji
wobec tego po prostu chodzi o to
aby taki diagram sekwencji
mieścił się na jednym ekranie
nie był zbyt złożony bo
jeżeli będzie bardzo bardzo złożony to
po prostu nie zapanujemy nad tą złożonością
wobec tego może być tak
że z pewnego diagramu sekwencji
wysyłamy komunikat
taki który być może będzie
łapany czy będzie odbierany
przez inny diagram sekwencji
i tu mamy taki przykład
że tutaj
no wyobraźmy sobie tu mamy
jakąś dalszą część tego diagramu
sekwencji który tutaj nie został pokazany
ale w każdym razie z jednego z obiektów
w tym diagramie jest wysyłany
komunikat tutaj wyświetl
idzie on gdzieś
prawda natomiast nie ma tego
tego obiektu nie ma do którego
ten komunikat jest skierowany
nie ma już na tym diagramie
i to jest nazywa się
komunikat utracony
a teraz z kolei inny
diagram sekwencji tak żeby
zacząć swoją
swoje działanie oczekuję
na pewien komunikat
i tutaj mam taką sytuację
że właśnie ten miernik
obiekt klasy miernik
oczekuje na komunikat
z mierz który skądś do niego
dojdzie może dojdzie
z innego diagramu sekwencji
prawda żeby go aktywować
teraz
jeszcze jeden taki typ komunikatów
który czasem
się stosuje przy projektowaniu
modelu i waniu to jest tak zwany
bulking message
czyli komunikat opcjonalny
nadawca czyli
tutaj klient
wysyła komunikat oczekując
że ten odbiorca czyli ta
lista jest gotowy
do jego natychmiastowej obsługi
jeżeli komunikat
sortuj tak nie zostanie
nie może być przyjęty
to nadawca no nie podejmuje
kolejnych prób
jego realizacji czyli jak gdyby
no jak się uda to zrobić to super
a jak nie no to trudno
może być
również taki timeout message
nadawca wysyła
komunikat
oczekuje że odbiorca
czyli klasa baza danych
obsłuży ten komunikat
w ciągu określonego okresu
jeżeli
nie uda się
ten czas minie
to nadawca
rezygnuje z dalszej interakcji
proszę Państwa
mamy na diagramach
sekwencji
możliwości tutaj
no rozliczne
i krok po kroku
będziemy je poznawać
mianowicie
zacznę może od tego że
czasem te komunikaty
mogą być warunkowe
czyli na przykład czasem w przebiegu
diagramu sekwencji
chcemy zamodelować
taką sytuację kiedy
no pewien komunikat jest wysyłany
tylko wtedy kiedy określony
warunek jest spełniony
i tutaj mamy przykład
właśnie takiego
stosuje się wtedy tak zwane
dozory czyli inaczej to się nazywa
GARC proszę zwrócić uwagę
mamy tutaj nawiasy
kwadratowe
te nawiasy kwadratowe to są
właśnie te dozory czyli ten
GARC ten warunek
one też już występowały
we wcześniejszym materiale
popatrzmy
tutaj na jakiś
taki prosty przykład
czyli mam tutaj
jakiś obiekt register
pyta się obiektu
klasy
accounts receivable
czy jaki jest
czy student tu jest przekazany
identyfikator studenta
nie zalega z płatnościami
dostaje informacje o tym
past due balance czyli czy student zalega
z jakimiś należnościami
i teraz jeżeli ten
właśnie student
nie zalega z żadnymi płatnościami
past due balance równa się
zero tak to
dodajemy studenta tu jest jego
identyfikator przekazany do
tutaj jakiegoś
przedmiotu w tym wypadku prawda
na zajęcia jakieś
teatralne ten student się chce
o tym identyfikatorze zapisać
czyli ten komunikat
dodaj studenta tak
do wywołany
na obiekcie
drama klasy
no będzie wysłany
tylko wtedy kiedy prawda
tutaj wartość tego zwróconego
parametru past due balance jest
równa zero czyli można stosować
takie warunki dozory
to jest
to jest jak gdyby jedna z możliwości
prawda jeżeli ten warunek
nie jest spełniony no to
jak gdyby wykonuje się idzie
wykonanie idzie dalej ten fragment jest
pomijany wykonanie idzie dalej
dobra
popatrzmy na kolejną możliwość
otóż możemy czasem
mieć takie warunkowe
rozejście takie rozgałęzienie
komunikatów czyli właśnie mam
pewien warunek tak
jeżeli ten warunek jest
spełniony to wykonaj
operację 1
na obiekcie klasy B
jeżeli
natomiast nie tutaj ważne
jest że to musi być zanegowane
to wykonaj
operację w innym
w tym wypadku w innym obiekcie ale mogłoby być
także tylko inną
operację w tym samym obiekcie klasy B
istotne jest
że warunki muszą być
wzajemnie rozłączne dlaczego muszą być
wzajemnie rozłączne
dlatego że jeszcze raz przypominam
taki diagram sekwencji
to będzie potem wywołanie
pewien przebieg pewien
fragment wykonania programu
i ten program który my
tworzymy musi być
programem deterministycznym on zawsze
przy określonych parametrach musi się zachowywać
w ten sam sposób
wobec tego jeżeli chcemy mieć takie
rozejście warunkowe
to one muszą być tutaj te
warunki wzajemnie rozłączne
czyli jeżeli tu daje pewien warunek
to zaprzeczenie
negacja tego warunku
musi być przy operacji 2
no i popatrzmy
tutaj na kolejny przykład
no i proszę
popatrzeć właśnie jest możliwa
sytuacja taka
kiedy
będą różne
operacje w klasie
odbierającej wykonane
w tej klasie B
no w zależności
od warunku tutaj jakiejś
zmiennej x tak albo
będzie wykonany komunikat
pierwszy albo będzie wykonany
komunikat drugi
może być to tutaj różne
operacje w tym samym
trakcie mogą być wykonane
czy te warunki są wzajemnie
rozłączne
tak czy nie x większe od 2
x mniejsze równe 2
no tak a gdybym ja tutaj
zlikwidowała to równa się
tylko miała mniejsze
to wtedy jest to sytuacja
nieprawidłowa prawda wtedy
jest pytanie a co ma się dziać
wtedy kiedy to
jest równe 2 tak
nie mam to oprogramowane
a więc nie jest to
nie jest to właściwe
tutaj mamy warunki wzajemnie
rozłączne wszystko jest
w porządku
proszę Państwa no ja Państwu tutaj
prawda ciągle
przypominam
że mamy pewien system
notacyjny w tym UMLu i musimy go
stosować
czasem
na diagramach
na konferencji
stosujemy jeszcze pewne dodatkowe
oznaczenia obiektów
które określają nam
jaka jest rola tego
obiektu a więc
możemy zaznaczać takim
kółeczkiem ze
strzałeczką że
to jest obiekt taki który
steruje czymś
możemy zaznaczać kółeczko
z taką kreseczką że jest to
obiekt który przechowuje
coś i takie obiekty
graniczne które na przykład będą
służyły do komunikacji
powiedzmy zewnętrznym
i tutaj popatrzmy
na taki przykład
diagramu sekwencji w którym właśnie
przy tych obiektach
wprowadzono
dodatkowe oznaczenia
a więc mam obiekt
sterujący mam
taki obiekt graniczny
i mam taki obiekt przechowujący
którym jest obiekt klasy
baza danych
tutaj mam taki obiekt
graniczny zespół projektowy
który można sobie wyobrazić że
to jest na przykład klasa
reprezentująca aktora w systemie
wywoływana jest
operacja przydziel
w klasie dobór prac
tak dobór pracowników na przykład
przydziel l n pracowników
do tego zespołu projektowego
i tutaj
operacja przydziel specjalisty
tak jest wysyłana
do obiektu klasy baza danych
ale proszę popatrzeć
co tutaj się jeszcze dzieje
no po pierwsze widzimy te nawiasy
kwadratowe które oznaczają
warunek
czyli prac od 1 do n
tak będzie ten komunikat
przydziel spec
komunikat jest synchroniczny
będzie wysłany
no wiele razy
to że wiele razy oznacza
ta gwiazdeczka
gdybym nie miała tego
warunku to byłby
nie mówię ile razy
natomiast ten warunek
mówi że to będzie od 1 do n
tak ja szukam tych n specjalistów
w tej bazie danych
komunikat przydziel spec
będzie wysłany
wysyłany aż tych n
specjalistów skompletuje
to jest widzicie państwo
komunikat synchroniczny
sterowanie wraca tutaj
i wraca również
sterowanie do klasy zespół
projektowy przez wywołanie
operacji
skompletowany
to jest tutaj wywołanie
komunikatu asynchronicznego
czy może do tego mają państwo
jakieś pytania uwagi
proszę państwa to co tutaj pokazałam
że coś jest wykonane wiele razy
tak
no praktycznie w pętli jest
wykonywany aż tamto n
przy dziele to
tak było w tych pierwszych
wersjach uemela
wersji uemela od 2 w górę
zostały wprowadzone
tak zwane combined fragments
i teraz
troszkę powiem państwu o tym
combined fragments
polega to na tym że
pewną część jak gdyby
diagramu sekwencji
umieszczamy w takiej ramce
to się nazywa
frame czasem
ta ramka
ten combined fragments
będzie miał tutaj pewien
nagłówek ja za chwilę pokażę
którym będzie operator
to będzie nic innego jak będzie operator
i tutaj
czasem mam
dwa takie operandy
tego typu tej interakcji
czasem może być jeden
za chwileczkę zobaczycie państwo
po co to jest to jest po to żeby
no właśnie stosować
takie konstrukcje
trochę
podobne do języków programowania
jak na przykład alternatywa
jak pokazywać
iterację ja tutaj państwu pokazałam
taką prostą iterację
ale ta iteracja taka z gwiazdką
umożliwia wysyłanie w pętli
ale tylko jednego
komunikatu prawda tego przydziel specjalisty
a gdybyśmy chcieli
całą sekwencję komunikatów
w pętli wysyłać to jak to zrobić
no właśnie w ten sposób
że użyjemy odpowiedniego nagłówka
wtedy tym nagłówkiem będzie loop
i tą sekwencję komunikatów
tutaj w tej ramce
umieścimy popatrzmy
jakie to mogą być
operatory takie w tych
combined fragments a więc widzicie
państwo może być alternatywa
czyli jeśli coś
to coś a jak nie to coś
innego czyli takie if then else
może być opcja
czyli jeśli pewien warunek
jest spełniony to zrób
pewną sekwencję komunikatów
może być break
break oznacza wyjście
za chwileczkę może
do tego wrócę bo proszę popatrzeć
tutaj mamy loop czyli
iterację a więc mogę
w pętli jeżeli tutaj mam
tego loopa
to
to ten
to mam
nagłówek tak
i tu mam ileś tych komunikatów
to one w pętli są
wykonywane
ale w jakimś momencie jeśli pewien
warunek jest spełniony to ja chcę
wyjść z tej pętli tak
czyli wyjść na zewnątrz i wtedy
użyjemy tutaj wewnątrz
tego breaka
możemy pokazywać że
pewne
sekwencje są wykonywane
współbieżnie
możemy teraz
pokazywać że pewne sekwencje
muszą być dokładnie w tej
kolejności wykonane albo
niekoniecznie słabsze
uporządkowanie
mogą być to również obszary
krytyczne tutaj mamy pokazuję
państwu
zbiór takich operatorów które
w tych combined fragments
mogą się pojawić i popatrzmy
na jakieś przykłady
a więc
mam tutaj w tym
combined fragment
nam operator out
czyli alternatywa
i teraz
tutaj tym warunkiem jest
autoryzacja
jeżeli ta autoryzacja jest
prawdziwa
to wykonywana jest sekwencja
tych
komunikatów które tu widzimy
czyli do bazy zamówień wysyłany
jest komunikat
zapisz zmianę synchroniczny
i komunikat asynchroniczny
zwracany jest do klienta
że aktualizacja jest
ok bo jak gdyby to się
zaczęło od komunikatu
klasie zamówienie
na obiekcie klasy zamówienie
wykonane aktualizuj
i tutaj
jeżeli ta autoryzacja jest ok
to zapisana zmiana w bazie
zamówień i zwraca się informacja
że aktualizacja została zrobiona
jeżeli jest negacja
tego czyli jeżeli ten warunek jest
nie jest prawdziwy
no to tutaj widzicie państwo jest
wywoływana inna operacja
z tej klasy klient
że jest brak
aktualizacji to jest taka
prościutka
alternatywa
w jednym tutaj mamy
w tej części wtedy kiedy warunek
jest prawdziwy mamy tutaj dwa
komunikaty w tej części kiedy
warunek nie jest prawdziwy czyli w tej
części else mamy jeden
komunikat ale oczywiście tych
komunikatów może być troszkę
więcej i popatrzcie państwo
tutaj właśnie na taki troszkę
bardziej złożony przykład tej
alternatywy
czyli
mamy na przykład
chcemy pobrać
jakieś tam
pieniądze
pytamy się ile mamy
na rachunku tak
stan naszego rachunku jest
tutaj zwracany
to jest to co chcemy pobrać
to get amount
to co chcemy pobrać na przykład z bankomatu
i teraz jeżeli mamy alternatywę
jeżeli to co
mamy na rachunku stan rachunku
balans rachunku jest większe
równy od tego co chcemy pobrać
czy wypłacić no to
widzicie państwo jest
wykonywana transakcja
tam numer rachunku
ile
zapisywane są te informacje
to oczywiście ten ta
kwota jest tam obejmowana
w innym przypadku
jeżeli brakuje nam tych środków
no to tutaj dodawane
są te insufficient
fund dodawane są do
naszego rachunku no pewnie zupełnie
innym oprocentowaniem
no i też
coś jest zwracane tutaj widzimy że jest
pewna operacja
prywatna wykonywana na
na obiekcie tej klasy
proszę państwa
bardzo często
mamy
konieczność wykonania
pewnej sekwencji komunikatów
no w cyklu
w pętli
i tutaj
taki typowy przykład
użycia właśnie takiej pętli
wyobraźmy sobie że
mamy katalog który
zawiera ileś pozycji
tak opisuje ileś pozycji
i w tej klasie katalogu
mam operację pokaż katalog
pokaż zawartość tego katalogu
to żeby pokazać zawartość
tego katalogu to ja muszę przejść
po wszystkich tych pozycjach
które wchodzą w jego skład
tak i każda
pozycja musi być pokazana
więc proszę popatrzeć tu jest jednocześnie
w ten sposób pokazane w jaki
sposób pokazujemy modelujemy w jaki
sposób pewne operacje są
realizowane czyli operacja
pokaż katalog na
klasie katalog mamy
tutaj w tej ramce w tym
combined fragment mamy
operator loop czyli
operator cyklu operator pętli
od 1 do
nieskończenie wiele gwiazdka
oznacza dowolnie wiele
czyli tyle ile mamy tych
pozycji w tym katalogu
opisanym wywołujemy
operację pokaż pozycję która
jest operacją klasy
pozycja tak i
przechodzimy po wszystkich
pozycjach które w tym katalogu są
zapisane jak musi
wyglądać żebym taki
diagram sekwencji chciała
narysować czy mogła narysować
jak musi wyglądać diagram
klas no na przykład tak
mam klasę katalog mam
tutaj relacje agregacji
katalog zawiera wiele pozycji
tak w klasie pozycja
być może mam tutaj prawda
tu nie mam informacji o
tym ale mam
operację tutaj operację
pokaż pozycję
tak i tutaj
w klasie katalog też
mam no pewnie n które
mówi ile mam tych pozycji
i tutaj mam
pokaż katalog
to są też
operacje publiczne
a więc klient wywołuje
tą operację z klasy
katalog
tak pokaż
katalog żeby tą
operację zrealizować
to obiekt klasy
katalog musi przejść po
wszystkich pozycjach które
są w nim zagregowane
od 1 do gwiazdka
tyle ile ich jest prawda
i wywołuje tą
operację z tej klasy
pozycja w ten sposób
pokazujemy zawartość
tego katalogu pokazując
wszystkie pozycje które
w jego skład wchodzą
czy do tego
może mają państwo jakieś pytania
czy to jest oczywiste
przepraszam za daleko
o poszłem
momencik nie w tę stronę
czyli
cykl taki
fragment z cyklem z pętlą
tak i
odpowiednik jak to zwykle wygląda
na diagramie klas na
diagramie klas zwykle to wygląda
w ten sposób bo właśnie relacja
agregacji pokazuje nam prawda że
to jest całość a to
są elementy składowe
nie ma pytań do tego
no to popatrzmy
teraz na
na tutaj
opcje
to jest
taka no
pokazuje że jeżeli
ta kombajn fragment
że jeżeli ten warunek
jest spełniony to wykona
tutaj ten ciąg
komunikatów jeżeli
natomiast nie no to po prostu
to cała ta ramka nie jest
wykonywana i wykonywane jest coś co
jest tutaj poniżej
a więc zobaczmy jak to
jak to może wyglądać
mamy
tutaj podobną sytuację jak już
wcześniej była prawda z jakimiś tam
stanem konta tak
i na przykład z możliwością zapisu
studenta na określone
zajęcia na przykład na jakieś zajęcia
teatralne a więc znowu
pytamy się czy student nie
zalega z opłatami zwracana
jest tutaj przez obie
klasy accounts receivable
zwracany jest stan konta studenta
zaległości studenta
jeżeli ta
pass due balance jest równe zero
no to dopisujemy studenta
do tych zajęć tak
pytamy się jaki
jest get cost of class
jakie są koszty
tych zajęć teatralnych dostajemy
o tym informacje zwrotne
i teraz no
na tym rachunku studenta
obciążamy go tą
opłatą za te zajęcia
teatralne czyli
i jeżeli prawda natomiast
student tutaj by zalegał
z opłatami pass due balance byłaby
różne od zera to
cała ta ramka nie jest wykonywana
wykonywany jest komunikat
który tu jest poniżej
czy do
tego co tutaj pokazywałam
jeśli ma się jeszcze
zadają państwo
może jakieś pytanie uwagi
jeżeli nie to
proponuję proszę państwa
zrobić przerwę
w tym momencie napiszę
na czacie
przerwa do godziny 10
Dziękuję.
---------------------------------------------Wracam do wykładu i chwileczkę tylko, żeby udostępnić.
Otóż proszę Państwa, mówiłam Państwu, że czas biegnie w kierunku dołu.
Więc jeżeli tutaj mamy na tej osi,
w tej osi czasu ustawione komunikaty,
to widzimy w jakiej kolejności one będą się wykonywać.
Teraz to jest projekt, model, który robimy.
Potem zgodnie z tym naszym modelem, projektem
powinien działać program już gotowy, wynikowy.
No i w tym programie gotowym, wynikowym
często jeszcze...
Jeszcze chodzi nam o to, żeby były zachowane pewne relacje czasowe.
Na przykład wyobraźmy sobie, że tutaj przez X jest zaznaczony moment
wysłania tego komunikatu, przez Y wysłania tego i przez Z wysłania tego.
No i być może w tym konkretnym systemie, który realizujemy,
istotne są pewne zależności czasowe.
A więc na przykład istotne jest, żeby pomiędzy tutaj,
tym Y i X, żeby ten czas, który faktycznie upływa,
był mniejszy od 3 sekund, a na przykład tutaj ten czas
pomiędzy Z i Y, żeby był mniejszy od 1 sekundy.
Możemy takie ograniczenia, możemy na tym diagramie sekwencji napisać,
tak przypominam nawiasy klamrowe, to są constraints w WML-u,
więc możemy te ograniczenia wpisać.
Natomiast kiedy będziemy...
Będziemy mogli to sprawdzić.
Będziemy mogli to sprawdzić tylko wtedy, kiedy będziemy mieli już gotowy program.
No to wtedy można będzie zmierzyć, prawda,
czy włączyć wywołania funkcji mierzących czas
i sprawdzić, czy faktycznie te relacje czasowe są zachowane.
Ale w projekcie możemy takie rzeczy umieszczać.
Momencik dalej.
Teraz, proszę Państwa, też wspomniałam Państwu o tym,
że często te diagramy sekwencji są bardzo złożone,
a my nie chcemy takiego bardzo złożonego diagramu robić,
tylko jeżeli jest on bardzo złożony, to będziemy go dzielili
na jakieś mniejsze takie funkcjonalne części.
No tak jak dzielimy program na procedury, na funkcje,
to tutaj postępujemy dokładnie w ten sam sposób.
No i wtedy musimy mieć możliwość przywołania,
pewnego diagramu sekwencji, tak jak wywołujemy procedurę czy funkcję.
Taka możliwość również jest,
bo mamy taki operator przywołania, który się nazywa REF.
Nazywa się to inaczej Interaction Occurrences,
czyli odwołujemy się w diagramie bazowym do innego diagramu sekwencji.
Jak gdyby przekazujemy, włączamy w tym momencie
wykonanie innego diagramu sekwencji.
I ten inny diagram sekwencji może być,
albo zainicjowany przez komunikat,
tak jak Państwu pokazywałam, taki komunikat wysyłany do kąś,
no to właśnie będzie oczekiwanie na taki komunikat,
który aktywuje całą sekwencję wykonań komunikatów,
albo może być to czynnikiem czasu aktywowanym.
Popatrzmy, jakie tutaj mamy możliwości.
A więc popatrzmy.
Przypomnę Państwu,
że mam tutaj taki operator strict,
czyli dokładnie taka kolejność, jak tutaj jest pokazana.
I mam tutaj przywołanie dwóch takich diagramów sekwencji.
Jeden się nazywa logowanie, drugi się nazywa wyszukaj produkt.
Ponieważ mam operator strict, to widzimy one są umieszczone,
wywołanie tych REF referencja logowanie, REF wyszukaj produkt,
umieszczone są na osi czasu.
Poprzez użycie tego operatora strict,
ja mówię, że to musi być dokładnie w takiej kolejności.
Czyli najpierw musi być wywołany ten diagram sekwencji,
który się nazywa logowanie,
a po nim będzie wywołany diagram sekwencji,
który się nazywa wyszukaj produkt.
Tutaj proszę zwrócić uwagę również na te ramki, na te frames.
One obejmują linie życia obiektów,
które działają, wchodzą ze sobą w interakcję właśnie wewnątrz,
tego diagramu sekwencji logowanie klient i baza klientów.
Natomiast wyszukaj produkt, proszę popatrzeć,
obejmuje linie życia również katalog, produkt,
no bo to pewnie będzie wyszukaj produkt w katalogu.
Ale też widzimy, że on jest też na osi,
tutaj na linii życia klienta i bazy klientów.
A więc możemy takie wywołania,
takich procedur, czyli takich diagramów sekwencji
umieszczać na osi czasu.
Tutaj popatrzmy z kolei, mamy sytuację taką,
kiedy jest wywołanie pewnego diagramu,
ale ten diagram jest aktywowany komunikatem.
I popatrzmy, jak to tutaj wygląda.
No wyobraźmy sobie, że mamy taki bankomat,
mamy klienta, mamy bank,
i klient na tym bankomacie wybiera,
czy wkłada kartę, która mówi z jakiego rachunku
i określa, jaką kwotę chciałby podnieść.
Wysyłane jest pytanie do banku,
get balance, podaj stan rachunku,
tutaj ten numer rachunku jest podawany.
I przywołujemy cały diagram, ref,
balans, lookup, mamy podany tutaj numer rachunku,
zwracana jest wartość, liczba typu real,
balans, ile jest na stanie tego rachunku.
I tu jest przywołanie tego, wywołanie tego całej takiej sekwencji,
która sprawdza, jaki jest stan rachunku konkretnego klienta,
właśnie za pomocą tego komunikatu get balance
z odpowiednimi parametrami.
Następnie mamy tutaj znowu ramkę,
frame, mamy z operatorem opt, czyli opcja.
I mamy tutaj warunek balans, większe od amount,
czyli jeżeli stan rachunku jest większy niż to,
co klient chciałby podjąć z maszyny,
no to obciążamy ten rachunek teraz tą kwotą,
i tutaj jest przywołanie znowu całego takiego diagramu sekwencji,
debit account, czyli obciążenie rachunku,
z numerem i z kwotą, ilą dany klient pobrał z tego rachunku,
no i zwracany jest cash, prawda, gotówka do klienta.
Czy to jest jasne, jak to działa,
czy może mają Państwo jakieś jeszcze wątpliwości, pytania?
Proszę Państwa, teraz często mamy właśnie taką sytuację,
jak na przykład przy tym sprawdzeniu stanu rachunku,
że no właśnie, ta sekwencja jest aktywowana
poprzez otrzymanie pewnego komunikatu,
i ona zwraca pewną wartość.
A więc mamy jak gdyby punkt wejścia do takiego,
do takiego diagramu sekwencji,
i mamy punkt wyjścia.
I to można właśnie za pomocą takich bramek zrobić.
Tutaj widzimy, że jest właśnie wejście, jest ten get balance,
pytamy się, ile mamy na tym rachunku,
i zwracany jest jego stan.
I można takie, takie bramki właśnie można pokazywać również,
bo oczywiście te combined fragment
mogą być wzajemnie zagnieżdżone, jedna w drugim.
I tutaj mam taki przykład pokazany.
Mam ileś obiektów klasy A, B, C, D,
które uczestniczą w interakcji.
Tutaj mam na osi czasu, prawda, wywołany diagram,
który się nazywa sekwencja 1.
Tu mam bramę wejściową tego, tej ramki,
która się nazywa diag bramy.
I to jest jednocześnie bramka wejściowa do tego diagramu sekwencja 1.
Ten diagram zwraca pewną wartość,
która jednocześnie jest, jak Państwo widzicie,
zwracana na zewnątrz, bo tutaj mam bramkę wyjściową
tego, tej zewnętrznej ramki.
Więc przechodzi to, czyli zwracana jest na zewnątrz.
No dalej na osi czasu tutaj mamy, prawda, umieszczone znowu coś się dzieje
w tym obiekcie klasy A.
W szczególności on tutaj wywołuje teraz pewną warunkową,
pewną opcję, czyli pewną sekwencję jest wywołana warunkowo.
No nie wiemy, jak ten warunek tutaj wygląda,
ale jeżeli tak, to ona też produkuje coś
do takiej bramki wyjściowej tego dużego diagramu sekwencji,
tego diagramu bramy.
Tu natomiast wchodzimy, prawda, czyli
na jakieś wywołanie komunikatu na przykład
do tego diagramu sekwencja 2.
Czyli właśnie widzicie Państwo, zagnieżdżanie jest możliwe.
Jak gdyby w jednej ramce możemy wkładać wiele ramek wewnętrznych.
No tak, jak to jest w programowaniu, że wewnątrz, prawda,
jednego, jednej procedury możemy wkładać,
możemy umieszczać wywołania kolejnej,
a w tej kolejnej jeszcze innej.
I dokładnie w ten sam sposób możemy postępować
w przypadku diagramów sekwencji.
Teraz, proszę Państwa, w przypadku,
no kiedy właśnie tych diagramów sekwencji mamy dużo,
kiedy one są dosyć złożone,
to czasem tworzymy takie diagramy sterowania tą interakcją.
Czyli, no jeszcze raz przypomnę,
że tutaj celem tych diagramów sekwencji
jest zamodelowanie, zaprojektowanie,
jak pewne funkcje,
jak pewne funkcje w systemie są realizowane.
I czasem ta realizacja jest bardzo złożona,
więc czasem trzeba to właśnie na takich diagramach sterowania zaprojektować.
I tutaj zobaczymy na takich diagramach
taki przepływ sterowania pomiędzy różnymi diagramami sekwencji,
pomiędzy fragmentami interakcji.
I tutaj również mogą się pojawić pewne operatory,
pewne rozejścia warunkowe.
Czyli na przykład, popatrzmy,
mamy tutaj taki diagram przebiegu interakcją,
która się nazywa egzaminowanie.
Mamy punkt początkowy, mamy punkt końcowy
i mamy przywołanie pierwszego diagramu sekwencji,
który się nazywa przygotowywanie pytań.
Drugi następnie po jego zakończeniu przeprowadzenie egzaminu
i trzeci sprawdzanie.
Czyli tutaj mamy po prostu kolejno,
jedno po drugim wywoływane są diagramy sekwencji.
Tutaj można to również pokazywać w taki sposób,
tak jak Państwo widzicie,
przywoływana jest diagram sekwencji autoryzacja.
Tutaj jest z kolei wywoływany kolejny,
pewien fragment takiego,
wręcz czasem możemy taki diagram sekwencji rozwinąć,
jeżeli to jest potrzebne nam na przykład dla zrozumienia,
tak jak Państwo widzicie,
że nie tylko jest sama jak gdyby ramka z nazwą,
tak jak tu,
ale czasem można pokazać co jest w środku
i tutaj mamy podobnie też taki rozwinięty diagram sekwencji.
W tych diagramach przebiegu interakcją
można czasem używać rozejścia decyzyjnych,
tak jak tutaj Państwo widzicie.
Na przykład,
mam wywołany jako pierwszy początkowy
diagram wyszukaj produkt
i teraz no albo go znaleźmy,
albo nie.
Jeżeli go znaleziono,
to na przykład jest przejście do wykonania kolejnego diagramu sekwencji,
takiego przywołania,
które się nazywa rezerwu.
Jeżeli nie,
to na przykład tutaj wracamy do tego wyszukiwania produktu.
No i mówiłam Państwu,
że oczywiście można te combined fragmenty,
można te ramki,
można zagnieżdżać jedno w drugim
i tutaj mamy właśnie pokazany taki przykład,
że mam pewną pętlę,
wewnątrz tej pętli jest taki diagram z operatorem alt,
czyli takim warunkowym.
Jeżeli ten warunek jest spełniony,
to wykonaj tę sekwencję.
Jeżeli natomiast nie,
to w tej drugiej części pod tą linią przerywanej
wykonaj tę sekwencję,
jeżeli ten warunek jest niespełniony.
Nie ma tutaj żadnych ograniczeń
na głębokość takiego zagłębienia,
bo oczywiście może być tak,
że wewnątrz pętli mamy kolejną pętlę,
wewnątrz alta,
tutaj wewnątrz w środku też mogą znajdować się alty,
opcje i tak dalej.
Nie ma.
Tak jak w konstrukcjach w języku programowania,
nie ma ograniczeń, prawda,
ile może być pętli.
W pętli tak samo jest również tutaj.
No tutaj niestety jest,
czytelność tego diagramu jest kiepska.
Chodziło mi o pokazanie pewnej pętli,
ale obraz się rozmiął,
także przepraszam.
Tutaj mamy jeszcze pokazany przykład
tej ramki z konstrukcją break,
która też bardzo często się przydaje
i popatrzmy na tutaj jego przykład użycia.
Ten początek, prawda,
sprawdzenie stanu rachunku,
to już w kilku przykładach występował,
więc go pominę.
I mamy teraz tutaj taką ramkę
właśnie z operatorem break.
Czyli jeżeli tutaj jest balans,
stan tego rachunku jest mniej,
jest mniejszy od liczby,
którą chcemy pobrać, tak,
no to tu dodawane są właśnie
te dodatkowe jak gdyby fundusze, tak,
i wtedy zakończymy tutaj,
chodzimy dalej.
Natomiast ten break bardzo często
jest używany po to,
żeby w pętli wyjść w jakimś momencie.
Niestety nie mam takiego przykładu,
to jest, zaraz może,
może wrócę się dalej tutaj do jakiejś pętli.
Bardzo często właśnie,
no mam tutaj jakąś pętlę
i teraz tutaj akurat jest, prawda,
chodzę tak długo,
że pewien warunek jest spełniony,
ale czasem jest tak,
że ja coś biorę
i jak gdyby już uważam,
że mogę wtedy wyjść,
jeżeli pewien warunek jest spełniony,
więc na przykład właśnie tej konstrukcji break
bardzo często używamy,
żeby wejść z pętli,
czyli wewnątrz,
wcześniej opuścić pętlę,
a nie przejść po wszystkich,
wszystkich elementach tej pętli.
Teraz mówiłam Państwu,
że jednym z operatorów jest operator PAR,
który wtedy pokazujemy,
że modelujemy,
że pewne sekwencje mogą być wykonywane równolegle.
Tu akurat jest taki przykład abstrakcyjny
z kuchenki mikrofalowej,
gdzie mamy zarówno,
no kręci się ten talerz,
jak i jest podgrzewany,
więc te czynności podgrzewanie i kręcenie,
odbywają i ruch obrotowy,
odbywają się równolegle
i tutaj ten model właśnie to pokazuje,
że to jest równolegle podgrzewanie i obrot.
I to jak Państwo widzicie,
jest koniec tych moich materiałów
dotyczących diagramu sekwencji,
czy do tego, co tutaj Państwu pokazywałam,
może ktoś z Państwa ma jakieś pytania,
uwagi?
Proszę Państwa,
przy okazji może zwrócę uwagę
na coś, co się zwykle pojawia na egzaminie,
mianowicie tu pokazywałam taki prosty przykład,
czyli mam pewien diagram...
Można takie pytanie?
Tak, bardzo proszę.
Jakieś źródło,
takie fajne,
gdzie można by to sobie poćwiczyć,
jakieś zadania z rozwiązaniami,
mogłaby Pani wskazać?
Proszę Pana,
no nie mam takiego czegoś.
Nie wiem, czy w tym pliku zadania,
który...
taka jest prezentacja zadania,
w której są zebrane różnego rodzaju zadania,
ale nie przypominam sobie,
wydaje mi się,
że tam nie ma takiego zadania
dotyczącego diagramu sekwencji.
Ja mogę Państwu,
takie zadanie jeszcze w formie pracy domowej
dzisiaj jakieś podać,
żebyście mogli sobie przećwiczyć,
a ja to ewentualnie obejrzę
i jakieś tam uwagi mogę mieć.
Natomiast to, na co właśnie zwykle zwracam uwagę
w przypadku tych diagramów sekwencji,
to jest to, żebyście Państwo pamiętali o tym,
że te modele UML-owe muszą być spójne,
że my za pomocą tych diagramów projektujemy,
modelujemy system.
I musi być ta spójność.
I takie zadania dotyczące spójności
często się pojawiają.
Czyli na przykład takie zadanie,
jakie tutaj żeśmy dzisiaj robili,
że daję diagram sekwencji,
na przykład taki jak ten
i zadanie polega na tym
narysuj diagram klas,
który możesz wywnioskować
na podstawie tego diagramu sekwencji.
Czyli właśnie na przykład taki.
I uzasadnij.
A więc uzasadnij, dlaczego ta asocjacja jest dwukierunkowa.
Albo może wystarczy asocjacja jednokierunkowa.
To jest zadanie, które się bardzo często pojawia na egzaminie.
Sekundeczkę, jeżeli Państwo tutaj chcecie,
to ja popatrzę, czy ja nie mam takiego przykładowego zadania,
które mogłabym Wam pokazać.
Zaraz, momencik.
Jeszcze chwileczkę.
Jeszcze chwileczkę.
To nie jest.
Nie wiem, czy mi się uda szybko trafić,
ale jeszcze jedną próbę zrobię.
Nie. Nieudane trafienie.
Dobra.
Dobra, nie.
uwaga, trafiłam w coś.
Dziękuję.
I widzimy, no akurat dwa takie zadania są, które by pasowały do tego materiału, który dzisiaj czy na poprzednim wykładzie prezentowałam, a więc narysuj, macie Państwo dany diagram sekwencji, narysuj diagram klasy, relacje, operacji, który wynika z tego diagramu sekwencji.
Uzasadnij swoje rozwiązanie, co znaczy uzasadnij rozwiązanie.
Uzasadnij typ relacji.
Uzasadnij, czy ta relacja ma być jednokierunkowa, czy dwukierunkowa.
Uzasadnij również rozmieszczenie operacji w obiektach, w poszczególnych klasach.
To jest i w chwili obecnej, kiedy korzystamy z tego systemu zdalnego egzaminowania, tego typu zadania również się tam pojawiają.
Musicie zrobić.
Mogę zrobić rysunek, zdjęcie tego rysunku, albo narysować go takimi prostymi symbolami, które zwykle są dostępne, albo po prostu dołączyć zdjęcie, czy rysunek zrobiony w innej formie.
Dobra, czy coś może jeszcze, jeśli Państwo chcecie, to ja na przykład to zadanie mogę umieścić jako zadanie, jako assignment.
I potem no tym osobom, które przyślą rozwiązania, to sprawdzę to i jakiś komentarz, komentarz jakiś będzie.
Chcecie takie coś? Sprawdzić sobie siebie?
Tak, tak.
Dobra, to ja to dzisiaj po wykładzie przygotuję, umieszczę i też dam termin do piątku rano,
gdy w piątek rano mam szansę to sprawdzić i jakieś tam Państwu uwagi podać.
I być może, że jakieś rozwiązanie znowu na kolejnym wykładzie będę omawiać.
I...
Dobra, kończę teraz tą prezentację.
Aha, no i proszę Państwa, teraz chcę Państwu powiedzieć o kolejnym typie diagramów,
mianowicie o diagramach komunikacji.
Inaczej one się nazywają, nazywane są również collaboration diagramy,
diagramy współpracy, diagramy komunikacji pomiędzy,
pomiędzy,
pomiędzy obiektami.
I to jest, proszę Państwa, jak gdyby możliwości modelowania
na tych diagramach współpracy, diagramach komunikacji
są bardzo podobne do tego, co możemy zrobić w diagramach sekwencji.
Pewne ich możliwości podstawowe są równoważne
i
i w niektórych narzędziach
case'owych jest możliwość
automatycznej transformacji diagramu
komunikacji na diagram sekwencji i w drugą stronę.
Za chwilę zobaczycie Państwo, na czym to polega.
Otóż diagram collaboration diagram albo communication diagram
to jest, jak nazwa wskazuje, diagram, który pokazuje
komunikację pomiędzy obiektami.
Czyli proszę popatrzeć, to jest diagram, który przypomina
diagram obiektów systemu, bo ja mam
ja mam obiekt, tak, obiekt kabina, mam drugi obiekt,
mam asocjację, która łączy te obiekty
i to jest to, co mogę wywnioskować, co wynika z diagramu klas, prawda?
Bo myjamy w diagramie klas klasę kabina, klasę drzwi
i asocjację dwukierunkową pomiędzy nimi.
Więc to jest, jak gdyby, taki rzut diagramu obiektów,
ale dodatkową rzeczą, którą na tym diagramie mam,
to mam pokazaną komunikację pomiędzy tymi obiektami.
Widzimy tutaj komunikat.
Oznaczenia tego komunikatu są analogiczne,
jak oznaczenia.
Znaczenia komunikatów w diagramach sekwencji. Czyli takie samo jest znaczenie tych grotów strzałek. A więc tutaj mamy grot strzałki otwarty, a więc jest to komunikat asynchroniczny. Od kabiny do drzwi idzie asynchroniczny komunikat, który się nazywa otwarcie. No może lepiej byłoby użyć czasownika otwórz.
No ale proszę Państwa, nie widzimy tutaj, nie mamy tu osi czasu. A jeżeli chcemy modelować, projektować komunikację pomiędzy obiektami systemu, no to jakaś ta kolejność pomiędzy tymi obiektami powinna być określona.
To jak to zrobić? No to robi się to w ten sposób, że na diagramach, na communication diagram, czy collaboration diagram,
komunikaty się numeruje. A więc proszę popatrzeć, tutaj idzie od obiektu klasy kabina do obiektu klasy winda, idzie komunikat synchroniczny w górę.
Drugi komunikat, dwójka, następnie wykonywany jest komunikat zapal, który idzie do klasy światło, obiektu klasy światło.
I trzeci, w kolejności komunikat, to jest komunikat, który jest tutaj zamknij i który jest kierowany do obiektu klasy drzwi.
Czyli mam numerowanie tych komunikatów po to, żeby zapisać ich, żeby zamodelować ich kolejność.
Momencik.
Tak jak Państwu mówiłam, rodzaje komunikatów są dokładnie takie same, czyli otwarty grot to jest komunikat asynchroniczny,
synchroniczny grot wypełniony i czasem można pokazywać również komunikaty zwrotne.
No to wracam tutaj, proszę Państwa, do tego diagramu, communication diagram. Wiemy już, co znaczą te numery.
Wobec tego, proszę Państwa, możemy,
dla tego diagramu komunikacji możemy narysować równoważny mu diagram sekwencji.
No bo wiem, że na tym diagramie sekwencji będę miała obiekt kabina, obiekt klasy winda, obiekt klasy drzwi, obiekt klasy światło.
Jak mam numery tych komunikatów, no to te komunikaty po prostu umieszczę odpowiednio na osi czasu.
Pierwszy do windy, drugi do światła, trzeci do drzwi.
I tutaj mamy właśnie pokazany równoważny diagram sekwencji dla tego diagramu komunikacji, który przed chwileczką pokazałam.
Czyli mamy teraz już, ta numeracja tutaj nie jest potrzebna, bo mamy tutaj te komunikaty umieszczone na osi czasu,
no ale zamieściłam je po to, żebyście Państwo widzieli, istotna jest kolejność, tutaj czas idzie w kierunku dołu ekranu.
Czyli widzicie Państwo...
No przy pewnych takich podstawowych możliwościach, które mamy w diagramach komunikacji, współpracy,
to można je przekształcić na diagram sekwencji.
I w drugą stronę, takie proste diagramy sekwencji, w których mamy tylko komunikaty, jakieś kolejności umieszczone,
to można je przekształcić, nawet korzystając z narzędzi CASE, w równoważny diagram.
Czyli komunikacji.
Ale już takie, te diagramy sekwencji, w których mamy te combined fragments, no to tu już takiej automatycznej transformacji nie ma.
I proszę Państwa, no to ktoś mógłby się spytać, no to po co, skoro tu ich możliwości są podobne, to po co?
No, w UML-u mamy różne rzeczy.
Nie musimy ze wszystkich możliwości UML-a korzystać, prawda?
Zespół projektowy wybiera te możliwości, które w tym konkretnym systemie są mu przydatne i pomocne.
I tutaj mogłaby być decyzja, nie wiem, czy kierownika projektu, czy nawet członków zespołu,
którzy pewne rzeczy mogą lepiej zamodelować, pewne rzeczy mogą lepiej widać na diagramach komunikacji,
a pewne rzeczy lepiej widać na diagramach sekwencji.
Tutaj, jeśli chodzi o te diagramy komunikacji, diagramy collaboration diagrams,
to takim typowym elementem, który widzimy na tych diagramach, jest aktor, który inicjuje, rozpoczyna cały przebieg tej komunikacji.
Ale my na diagramach sekwencji też możemy aktora pokazać.
Bo to aktor wysyła do obiektu.
Obiektu jakiejś tam klasy, prawda?
Ten, powiedzmy, ten komunikat pierwszy, który cały ten przebieg sekwencji pokazuje.
Albo wręcz aktor, albo możemy umieścić klasę, która reprezentuje tego aktora.
Bo zwykle tak jest, że dla wszystkich aktorów, których mamy w danym systemie, to w systemie będzie klasa, która tego aktora będzie reprezentowała.
Ale bardzo często taki ludzik jest przez nas umieszczany właśnie na diagramach.
No właśnie, i tutaj, prawda, widzimy, idą te komunikaty, jest numeracja tych komunikatów.
Teraz, proszę Państwa, możemy tutaj na tych diagramach komunikacji pokazać, że pewien komunikat jest kierowany do wielu obiektów, no w tym wypadku klasy student.
Czyli tutaj mam komunikat zwrot pracy egzaminacyjnej.
Mam w nawiasach kwadratowych, czyli jako warunek.
Mam all, mogę się domyślić, że chodzi o wszystkie obiekty, które są w tym związku.
A że do wszystkich jeszcze, że to ma być w cyklu, prawda, wysyłane kolejno do tych obiektów, to to oznacza ta gwiazdka.
Czyli tutaj mogę też modelować.
Czyli tutaj mogę też modelować.
Że pewien komunikat jest wysyłany do wielu obiektów.
Także ten diagram komunikacji pokazujemy, czy korzystamy wtedy, kiedy istotne dla nas są obiekty, które ze sobą się komunikują, które ze sobą współpracują.
No ale też kolejność tych obiektów, prawda, musimy pokazać.
Proszę Państwa, ta numeracja, ona czasem jest wielopoziomowa.
Tutaj, prawda, widzimy, kiedy ona będzie składała się z takich właśnie kilku cyfr.
Mianowicie, tu mam komunikat o numerze 1.
Ale żeby ten komunikat o numerze 1 zrealizować,
jest wysyłany do jakiegoś innego obiektu.
Komunikat, no, jak gdyby, czyli to by było w diagramie sekwencji, byłoby tak, że tu mam komunikat ten, powiedzmy, z jedynką.
Wsyłany, no, na przykład zrobię synchroniczny.
Żeby on do swojego wykonania musi komuś jeszcze wysłać ten komunikat 1.1.
A ten obiekt, żeby to zrealizować,
jeszcze do kogoś innego, do innego obiektu wysyła ten komunikat 1.1.1, tak?
A potem może jeszcze jakiś inny komunikat 1.1 i na przykład 2.
Czyli to, te kropki pokazują kolejne, no, jak gdyby, kolejne zagnieżdżenia,
które są, no, wywołania tych komunikatów.
Potrzebne, żeby, żeby ten komunikat zrealizować.
Tutaj widzimy taki jeden komunikat na tym, pierwszy komunikat, drugi komunikat na tym głównym poziomie.
No i teraz, jak wiemy już, co to oznacza, tak?
Że to, te poziomy są oznaczane.
To jeszcze popatrzmy tutaj na taką możliwość określania poprzedników komunikatów.
Czyli mamy tutaj obiekt klasy.
A wysyła do obiektu klasy B komunikat.
I to jest komunikat o tym identyfikatorze 4.4.
Ale tutaj mam listę komunikatów, które go poprzedzają.
Czyli, no, rodzaj pewnego warunku.
Co musiało być wcześniej wysłane, wykonane?
No, właśnie.
Ten komunikat 1.1.1.3.
Musiałyby być wykonane, żeby można było wysłać komunikat do obiektu klasy B.
Teraz, proszę Państwa, na tych diagramach komunikacji można również pokazywać,
że pewne rzeczy są wykonywane równolegle.
I tutaj, czy że mogą być wykonywane równolegle.
I tutaj mamy taki właśnie przykład.
To jest ten mój taki prosty przykład diagramu komunikacji z kabiną,
na przykład, prawda, w windzie, która ma światło.
Są jakieś tam drzwi.
I chcemy jechać w górę.
Żeby jechać w górę, dobrze byłoby zapalić światło w tej kabinie i zamknąć drzwi.
I proszę popatrzeć.
Tutaj jest komunikat na tym moim pierwszym rozwiązaniu.
Był zapal światło, potem zamknij drzwi.
A tutaj ten model pokazuje, że te komunikaty zapal, światło, zamknij drzwi,
mogą być wykonywane równolegle.
Jeżeli używam literek w tych kolejnych, jak gdyby, poziomach numerowania,
a nie cyfr,
no to to znaczy, że te komunikaty mogą być wykonane równolegle.
No i jeszcze kolejna rzecz.
Pamiętacie Państwo na diagramie sekwencji,
czasem pokazywałam Państwu,
znaczy pokazałam Państwu, że jest taka możliwość określenia struktury sterowania
i że czasem mówiłam Państwu, że czasem robimy tak,
że wręcz tworzymy takie obiekty specjalne,
które sterują przebiegiem use case'a dostarczającego pewną konkretną funkcję
pewnemu konkretnemu użytkownikowi, aktorowi.
I takie obiekty, właśnie takie sterujące obiekty aktywne.
I tutaj również można takie obiekty aktywne modelować.
Właśnie będą one inicjowały pewną serię,
wysyłanych komunikatów.
Mogą w określonym czasie samoistnie wysyłać takie komunikaty.
One mają specjalny symbol graficzny,
czyli symbol obiektu, ale tutaj ten obiekt jeszcze ma takie paseczki,
które mówią ten obiekt user, obiekt A klasy user,
jest tym obiektem aktywnym.
On inicjuje, od niego rozpoczyna się wykonanie czegoś.
No i to byłby koniec, jeśli chodzi o te diagramy komunikacji.
Czy do tego może mają Państwo jakieś pytania, uwagi, obserwacje?
Nie słychać, nie widać.
Dobra, to proszę Państwa, teraz momencik,
ja muszę otworzyć kolejną prezentację.
Dobra, proszę Państwa, znamy tak, jeszcze raz podsumowuję.
Diagramy use case, które mówią kto w systemie może pracować
i co w tym systemie może robić.
Diagramy class, za pomocą których modelujemy co w tym systemie musi być,
co ten system musi zawierać, jakie obiekty, jakich class są nam potrzebne,
żeby te funkcje, te use case dało się zrealizować.
Diagramy sekwencji, czyli diagramy komunikacji, które pokazują jak modelują,
jak te funkcje należy zrealizować.
No, ale potrzebne nam jest również takie narzędzie,
za pomocą którego będziemy modelowali zachowanie obiektów niektórych class,
czyli zachowanie niektórych class.
Nie wszystkich, bo nie wszystkie classy mają jakieś złożone zachowanie,
ale jeżeli jest to class,
która może mieć, której obiekty mogą mieć bardzo złożone zachowanie,
to zachowanie tej klasy, obiektów tej klasy będziemy projektować,
będziemy modelować za pomocą diagramów maszyny stanowej.
State Machine Diagram.
To jest, proszę Państwa, rzecz, która weszła do UML-a
z tych wcześniejszych materiałów,
metod strukturalnych, funkcjonalnych projektowania systemów.
Bo właśnie w ten sposób się bardzo dobrze modeluje zmiany zachowania,
zachowanie czegoś.
Diagram maszyny stanowej to jest, proszę Państwa, taki graf,
którego węzłami są stany.
Taki stan to jest abstrakcja zbioru wartości,
atrybutów i połączeń danego obiektu.
W tym grafie mamy skierowane krawędzie,
które pokazują, jakie zmiany stanów są możliwe.
I na tych krawędziach mogą się pojawiać etykiety,
które będą określały, jakie zdarzenie powoduje zmianę tego stanu.
I, co jest ważne, musi być to diagram deterministyczny,
dlatego że wszystkie obiekty danej klasy muszą się zawsze zachowywać
w ten zaprojektowany przez nas sposób.
Stan to jest, tak jak Państwu mówiłam,
pewna abstrakcja zbioru wartości, atrybutów, powiązań danego obiektu.
Ale można powiedzieć, że taki stan określa reakcję obiektu
na pewne zdarzenie.
Czyli jak gdyby jest taka stymulacja,
przychodzi jakiś stimuli, przychodzi jakieś zdarzenie
i obiekt przechodzi do stanu.
Na przykład otwarta, zamknięta, dostępna, niedostępna.
No właśnie, bo tutaj też, proszę Państwa,
zwracam uwagę na nazwy stanu.
Zaraz o tym będę mówiła.
Ale jeszcze przypominając niektóre rzeczy
już z tych wcześniejszych modeli.
To jeśli chodzi o nazwę use case'a,
to używamy czasowników.
Jeśli chodzi o nazwy class, to używamy czego?
No, punkt dodatkowy można dostać za dobre powiedzenie.
Nazwy class to są to...
rzeczowniki.
Zaczynamy od rzeczowników z dziedziny problemu,
potem mogą dojść jakieś jeszcze dodatkowe,
na przykład związane ze sterowaniem.
Natomiast jeśli chodzi o nazwy stanów,
to będziemy szukać przymiotników,
imię słowów przymiotnikowych.
Teraz takie zdarzenia reprezentują pewne chwile czasu,
a stan to jest interwał czasu,
czyli od pewnego zdarzenia do kolejnego zdarzenia
obiekt znajduje się w jakimś takim stanie.
No na przykład, że jest chory albo że jest zdrowy.
I oczywiście to w jakim stanie jest obiekt
zależy od tego jakie sygnały,
jakie stymulacje ten obiekt otrzymał w przeszłości.
Co się z nim działo?
Co się z nim działo?
Czyli jak gdyby zależy to od pewnej historii,
która miała miejsce.
No właśnie, już wspomniałam Państwu,
że stan musi mieć nazwę
i że tutaj będziemy używać,
szukać przymiotników,
imię słowów przymiotnikowych
dla określenia właśnie takiej nazwy stanu.
Ten stan wynika z pewnej historii.
On reprezentuje pewien interwał czasu,
pewien przedział czasu.
I wynika on z tego co się działo wcześniej z tym obiektem.
Jakie zdarzenia wpływały na ten obiekt.
Czyli jest to również pewna sekwencja zdarzeń,
które powodowały wejście do tego stanu.
Jak obiekt jest w pewnym stanie,
to on oczekuje na pewne zdarzenia.
Jak takie zdarzenie będzie miało miejsce,
to on na przykład może zmienić stan na inny.
Może przejść do innego stanu
albo może będzie mógł coś wykonać.
Właśnie dlatego, że tutaj projektując te diagramy maszyny stanowej,
będziemy również określać akcje,
jakie obiekt będzie mógł wykonywać.
No wtedy, kiedy pewne zdarzenia
wystąpią, kiedy coś się przydarzy,
coś będzie miało miejsce.
Co to będą te akcje?
A tutaj może jeszcze warto powiedzieć,
że diagram maszyny stanowej robimy dla klasy.
Już o tym mówiłam,
ale przypominam.
Diagram maszyny stanowej robimy dla klasy,
bo on właśnie modeluje zachowanie obiektu w tej klasy.
Wobec tego, jeżeli tutaj jest powiedziane,
że ta akcja obiektu jest reakcją na pewnego zdarzenia,
to co to będą te akcje,
które ten obiekt może wykonać?
To będą, proszę Państwa, operacje w tej klasie.
Mogą być to operacje prywatne,
jakie ten obiekt będzie wykonywał.
Być może prywatne,
może również publiczne.
Ale te akcje to są właśnie operacje
i mogą one być reakcją obiektu
na wystąpienie pewnego zdarzenia.
Mamy takie kółeczko,
takie czarne kółeczko oznacza stan początkowy,
to oznacza stan końcowy, takie podwójne.
No i właśnie reakcją na pewne zdarzenie
może być stan następny.
Czyli stany następne też są pewną charakterystyką danego stanu.
Stan początkowy, stan końcowy.
No dobra, no to popatrzmy
na jakiś bardzo prosty diagram maszyny stanowej.
Na przykład pewien przedmiot na uczelni,
powiedzmy na WIT-cie,
może być najpierw zgłoszony,
stan, w jakim ten przedmiot,
czy ten kurs się może znajdować.
Może być w stanie zgłoszony,
może być w stanie zaakceptowany,
może być w stanie realizowany,
może być w stanie zakończony.
Czyli mamy przymiotniki,
które określają ten kurs na uczelni
i mamy przejścia pomiędzy tymi stanami.
Tutaj nie mamy żadnych zdarzeń na tych przejściach.
Tak też jest możliwe, zaraz Państwo zobaczycie dlaczego.
Ale ja mogę tu wpisać jakieś etykiety.
Na przykład był, zgłaszam jakiś przedmiot
i dziekan Sikorski go akceptuje.
Więc mam tutaj zdarzenie na przykład akceptacja.
Ten mój przedmiot przechodzi do stanu zaakceptowany.
Teraz na przykład tu mam jakieś zdarzenie,
na przykład początek semestru, start semestru.
No to zaczyna być przedmiot realizowany.
Koniec semestru, end, przechodzi do stanu zakończony.
I możemy sobie tutaj jeszcze jakieś tam inne rzeczy wymyślać.
Proszę Państwa,
jak to wygląda graficznie?
Proszę popatrzeć.
Stan, symbol graficzny stanu.
Mamy prostokąt, ale uwaga, krawędzie są zaokrąglone.
Czyli to nie jest dokładnie ten sam symbol co klasa czy obiekt,
gdzie był po prostu prostokąt.
Tylko,
tutaj widzimy te zaokrąglone krawędzie.
No i w narzędziach case'owych mamy stosowną ikonkę,
która pozwala nam taki symbol graficzny stanu wprowadzić.
Mamy nazwę tego stanu.
Tak jak Państwu mówiłam,
szukamy przymiotników, które będą określały właśnie,
w jakim stanie obiekt tej klasy może się znajdować.
Teraz, proszę Państwa,
dla stanu określać pewne czynności wewnętrzne i zdarzenia,
które będą te czynności wewnętrzne wyzwalały.
Czyli obiekt robi coś, ale nie zmienia stanu.
Mogą być pewne przejścia wewnętrzne również tutaj wykonywane.
Za chwileczkę zobaczycie Państwo.
I stany mogą być stanami złożonymi.
Dlatego, że czasem model zachowania jest bardzo złożony,
bardzo skomplikowany.
I gdybyśmy narysowali taki diagram maszyny stanowej,
w której byłoby 50 stanów na przykład,
no to nie bylibyśmy w stanie zapanować nad tym,
jak faktycznie wygląda zachowanie obiektu tej klasy.
Musimy stosować jakieś tutaj metody dekompozycji tych stanów
i zobaczycie Państwo, co tutaj możemy zrobić.
No właśnie.
Czyli ten model zachowania obiektów danej klasy,
robimy to dla jednej klasy,
to jest diagram maszyny stanowej.
Oczywiście, jeżeli mam kilka obiektów tej klasy,
to każdy z tych obiektów będzie się zachowywał w ten sam sposób.
W taki sposób, jak ja to zaprojektuję na diagramie maszyny stanowej.
Ale te obiekty mogą być w różnych stanach.
Czyli na przykład ja mam powiedzmy 3 stany i 5 obiektów.
Pierwszy może być w stanie pierwszym, drugi w stanie trzecim,
trzeci w stanie drugim i tak dalej.
Zupełnie dowolnie.
Więc one jak gdyby zachowują się tak, jak ja to zaprojektuję
na diagramie maszyny stanowej,
ale każdy może być w swoim stanie
i mogą być niezależne od siebie.
Właśnie już wspomniałam o tym,
że mogą mieć miejsca pewne zdarzenia.
I tutaj takie zdarzenia jakieś tutaj Państwu wymyślałam.
Akceptacja, początek semestru, koniec semestru.
Więc mogą być to jakieś zdarzenia.
Mówi się o stimuli, o stymulacji.
I czasem takie zdarzenie może powodować,
że obiekt ma wykonać pewną akcję.
Wtedy tą akcję piszemy tutaj,
po slashu, po tym zdarzeniu.
Ta akcja to jest jeszcze raz, mówię,
operacja, którą obiekt wykonuje.
Bo to jest coś, co obiekt może wykonać.
Czyli to musi być jego operacja, jego metoda.
No właśnie i pewne zdarzenia mogą być takimi zdarzeniami,
które ja sobie identyfikuję w tym stanie,
w tym naszym systemie.
Ale są pewne zdarzenia predefiniowane.
I zaraz zobaczycie Państwo, jakie to są.
.
.
Otóż,
.

,
.
.
.
.
,
.
.
.
,
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
No dłuższy czas, bo normalnie to jak gdyby określamy te akcje, które obiekt może wykonywać wtedy, kiedy ma miejsce pewne zdarzenie, że one się wykonują w czasie pomijalnie małym, czyli jak gdyby błyskawicznie się wykonują.
Ale zdajemy sobie sprawę z tego, że czasem taka czynność trwa, tak jak tutaj było na przykład ten przykład, mamy kurs i odbywa się nauczanie, trwa to cały semestr, więc mogą być takie akcje, których wykonanie ma czas długi, taki czas, którego nie możemy pominąć.
I wtedy też możemy takie akcje poprzedzić słowem kluczowym do, czyli albo zawsze, kiedy obiekt jest w tym stanie, albo wtedy, kiedy jest to czynność, która trwa dosyć długo.
Uwaga, te akcje, które mamy określone, poprzedzone słowem kluczowym do, wykonywane są po entry, czyli najpierw obiekt robi przy wejściu do stanu.
To, co jest określone słowem kluczowym entry, a jeżeli ma jeszcze coś określone jako do, to wtedy przechodzi do wykonywania tego do.
Mamy jeszcze słowo kluczowe exit i tutaj po tym słowie kluczowym exit też mogę tylko jedną czynność podać, którą obiekt będzie wykonywał wtedy, kiedy następuje entry.
Wyjście z tego stanu.
A więc wchodzimy do stanu, obiekt wchodzi do pewnego stanu, wykonuje to, co jest określone po entry, jest w tym stanie, robi w sposób ciągły akcję, czyli wykonuje operację, która jest poprzedzona słowem kluczowym do.
A jeżeli wychodzi z tego stanu, to jeszcze jak gdyby przed wyjściem.
Wyjściem z tego stanu wykonuje tą czynność poprzedzoną słowem kluczowym exit.
Mogą być również, proszę Państwa, takie zdarzenia wewnętrzne, czyli na przykład mam stan ustaw godziny w jakimś zegarku, mam czynność do wyświetla godzinę,
ale jeżeli mam miejsce zdarzenie INC, na przykład przycisnę przycisk,
to wykonywana jest operacja INKREMENTUJ godzinę, którą tutaj Państwo widzicie.
Czyli mogą być również pewne zdarzenia wewnętrzne.
Mogą być również pewne zdarzenia, które powodują wyjścia z tego stanu.
Popatrzmy tutaj na taki troszkę bardziej złożony przykład.
Stan początkowy, stan końcowy.
Mamy tutaj taki model.
Zachowania klasy, na przykład klasy seminarium w jakiejś tam szkole, w jakimś uniwersytecie.
I mamy stany.
To seminarium może być w stanie PROPOSED, SCHEDULED, czyli może być zaproponowane, już przydzielony jakiś harmonogram.
Może być otwarte dla zapisów, może być zamknięte, pełne, może być teraz zamknięte do zapisów i stan końcowy.
I popatrzmy teraz.
Co tutaj się dzieje?
Jak taki diagram maszyny stanowej może działać?
Czyli mamy stan początkowy PROPOSED.
Mamy zdarzenie SCHEDULED.
Zostało ono wprowadzone do planu zajęć.
Przechodzimy do stanu SCHEDULED.
Teraz ma miejsce zdarzenia OPEN.
Czyli na przykład przychodzi pewna data, otwieramy zapisy na jakiś przedmiot, w tym wypadku na to seminarium.
Przechodzi ono do stanu OPEN FOR ENROLLMENT.
I teraz proszę popatrzeć.
Mamy tutaj zdarzenie ENTRY, kluczowe, LOCK SIZE, czyli zapisz wielkość, ile osób się zapisało.
Jeżeli mamy zdarzenie STUDENT ENROLLED, student się zapisuje na to seminarium, no to po slashu mamy tutaj operację ADD STUDENT.
Ale ta operacja ADD STUDENT jest poprzedzona jeszcze warunkiem SIT AVAILABLE.
No więc na przykład przydzielona została sala, w której mamy 20 miejsc.
I dopóki te 20 osób się nie zapisze na ten przedmiot, to mamy go otwartego dla zapisów.
Jeżeli już i każde dodanie tutaj nowego studenta,
to jest zapisanie nowej wartości tego, no wielkości, ile osób mamy zapisanych.
Teraz proszę popatrzeć, co się tutaj dzieje w tym stanie.
Jeżeli tutaj mamy znowu zdarzenie STUDENT ENROLLED, takie samo, jak było wyżej,
ale teraz mamy tutaj inny warunek.
Powiedziałam Państwu, że warunki, że diagram musi być diagramem deterministycznym.
A więc, że muszą być zawsze w ten sam sposób.
A mam to samo zdarzenie.
Tu się student zapisuje i tu się zapisuje.
Ale ten diagram jest diagramem deterministycznym, dlatego że tu mam dodatkowo warunek.
No SIT AVAILABLE, czyli mam tu już 20 osób, przychodzi 21 student.
Nie mogę go zapisać, nie mam miejsca.
Ale wykonywana jest operacja ADD TO WAITING LIST.
Dopisujemy go do listy oczekującej i to seminarium przechodzi do stanu full.
Jeżeli znowu ma miejsce zdarzenie ENROLLED STUDENT,
to dodajemy go do listy oczekujących, ADD TO WAITING LIST.
I mamy tutaj jeszcze jedną operację CONSIDER SPLIT,
czyli rozważ, czy nie podzielić tego seminarium na na przykład dwie grupy.
Mogę mieć również miejsce STUDENT ZREZYGNOWAŁ.
Jeżeli student zrezygnował i w dalszym ciągu nie ma miejsc dostępnych,
bo miałam na przykład 24 osoby i ten 24 zrezygnował, mam 23, dalej mam za mało.
Więc wracam do tego stanu full.
Ale jeżeli teraz student zrezygnował,
i są jakieś miejsca dostępne,
to biorę studenta z tej listy oczekującej i zapisuję.
Więc widzimy, tutaj sporo się dzieje.
Jeżeli na przykład teraz seminarium zostało podzielone na dwie grupy,
no to znowu wracam być może do tego stanu OPEN FOR ENROLLMENT.
Mamy tu również zdarzenia CAMSET, proszę popatrzeć.
Praktycznie z każdego z tych stanów mam wyjście zdarzenia CAMSET.
No bo w każdym stanie na przykład może być decyzja dziekana.
Rezygnujemy z tego przedmiotu, rezygnujemy z tego seminarium.
A więc mamy tutaj takie zdarzenie, które zawsze nas tutaj przeprowadza do tego końca.
Dopuszczamy taki model.
No i to jest, proszę Państwa, taki pierwszy bardziej złożony diagram maszyny stanowej,
który troszkę pokazuje Państwu możliwości, jakie tutaj mamy,
modelowania, projektowania, zachowania właśnie za pomocą diagramy maszyny stanowej.
Czy może macie Państwo do tego jakieś pytania, uwagi?
Proszę.
Teraz, proszę Państwa, właśnie, ja już o tym wspomniałam tam jakiś czas temu, dzisiaj,
że czasem zachowanie jest bardzo złożone.
I że czasem taki diagram może zawierać kilkadziesiąt czy nawet kilkaset stanów.
Tego oczywiście na jednym diagramie nie jesteśmy w stanie zaprojektować, zamodelować.
Więc potrzebne będą tutaj mechanizmy takiej strukturalizacji diagramów maszyn stanowych,
po to, żebyśmy nad tą złożonością byli w stanie zapanować.
Czyli właśnie, stan albo może być stanem prostym,
tak jak tu było, powiedzmy, w tym przykładzie z tym seminarium,
ale może być również stanem złożonym.
I za chwileczkę zobaczycie Państwo, że można tutaj na przykład te rzeczy,
które tutaj miałam w tym zapisie na zajęcia, można by to włożyć w jeden stan,
taki zapis na zajęcia i mieć taki diagram, jak gdyby maszyny stanowej,
ale taki z hierarchią.
No właśnie, bo mamy możliwość strukturalizacji stanów.
Stan może być stanem złożonym.
I albo może być sytuacja taka,
że możemy powiedzieć, że pewien stan zawiera maszyny stanowe,
tych stanów, jak gdyby, składowych,
albo może być tak, że mogą być pewne obszary współbieżne,
że modelujemy takie zachowanie współbieżne, równoległe,
z kilku, jak gdyby, wątków się składające, takie podstany.
I za chwilę zobaczycie Państwo i ten model taki,
taki hierarchiczny, jak gdyby, i taki ten model kompozytowy, jak to wygląda.
No więc zacznę od właśnie takiej strukturalizacji, takiej hierarchii,
która się nazywa generalizacją stanów.
Popatrzmy, tutaj mamy taki bardzo prosty model właśnie takiego stanu,
no złożonego, to jest ten stan, który się nazywa do przodu.
Wyobraźmy sobie, że chcemy zaprojektować zachowanie automatycznej skrzyni biegów.
No i w pierwszym podejściu widzimy, że ta skrzynia biegów może być w stanie luz,
w stanie wsteczny i w stanie do przodu.
Ale ten stan do przodu zawiera całą maszynę stanową, którą tutaj widzimy.
Mamy stany, no moja maszyna, moja skrzynia automatyczna ma tylko trzy stany,
więcej mi się nie zmieściło.
Pierwszy, drugi, trzeci.
Są zdarzenia wyżej, niżej, które powodują zmianę tych stanów.
Pierwszy jest stanem początkowym.
Również jest takie zdarzenie stop, które powoduje, że ta maszyna,
ta skrzynia biegów też przechodzi do tego stanu pierwszym.
No i proszę popatrzeć, mam tutaj zdarzenie forward,
które jest skierowane, dochodzi do tego stanu abstrakcyjnego do przodu.
Czyli to jest zdarzenie, które uruchamia ten stan do przodu.
Ale zacznie on się zachowywać, teraz ta skrzynia biegów,
według tego projektu, który zawiera ten stan do przodu,
czyli ta maszyna stanowa do przodu.
Stanem początkowym tutaj będzie pierwszy.
Potem jak będą miały miejsca zdarzenia wyżej, niżej, no to te stany mogą się zmieniać.
Czyli mam stan taki abstrakcyjny do przodu
i mam stany konkretne, pierwszy, drugi, trzeci,
które są w tej maszynie stanowej modelującej ten stan do przodu.
To się również nazywa, tak jak Państwo tutaj widzicie, relacją OR.
Bo ta automatyczna skrzynia biegów jest w jednym z tych stanów na luz, wsteczny,
lub jednym z tych stanów,
konkretnych, które są tutaj.
Nie w tym stanie abstrakcyjnym, tylko jest albo w stanie pierwszy, albo drugi, albo trzeci.
Teraz, proszę Państwa, zwracam uwagę tutaj na tą strzałkę z napisem luz, czy L, zdarzenie L.
Przyciskam sobie guziczek L na tej mojej skrzyni biegów.
No i teraz, jak to tutaj się będzie działo?
Otóż, co to jest?
Proszę Państwa, to się nazywa generalizacja stanów.
Pamiętacie Państwo, taka relacja generalizacji była i na use case'ach,
była i na diagramie klas.
Co ona oznaczała?
Ona oznaczała, że coś jest dziedziczone, prawda?
Że jak miałam klasę ogólną i klasę specjalizowaną,
to ta klasa specjalizowana dziedziczyła możliwości tej klasy ogólnej.
Więc można się domyśleć, że tutaj też jest jakieś dziedziczenie.
Tylko co tu się dziedziczy?
No właśnie, tą się dziedziczy to przejście, które tutaj Państwu na żółto zaznaczyłam.
I to przejście dziedziczą wszystkie z tych stanów wewnętrznych.
Czyli, jeżeli skrzynia biegów jest w stanie trzeci i pojawi się zdarzenie L,
to przechodzi ona do stanu luz.
To samo w stanie drugim, czy w stanie pierwszym.
Teraz, jak to było z dziedziczeniem na przykład operacji w diagramach klas?
No było tak, że ja mogłam odziedziczoną operację przykryć swoją własną.
Tutaj też tak można.
Czy to ma sens, czy nie?
To nie wiem, ale mogę sobie wyobrazić, że ja tutaj narysuję takie przejście pod wpływem zdarzenia luz.
Że ja tym przejściem przykryję to przejście odziedziczone.
Czy to ma sens, czy nie?
No to jest inna sprawa.
Natomiast jest to możliwe, przykrycie tego przejścia odziedziczonego swoim własnym przejściem.
Teraz popatrzmy, jak ta zmiana biegów.
Czyli zaczynamy od stanu luz.
Powiedzmy, że ja wciskam literkę F.
Na przycisku chcę jechać do przodu.
Przechodzę do stanu pierwszy, bo stan pierwszy jest oznaczony jako stan początkowy.
Jeżeli teraz tutaj obroty już tam dojdą do pewnej wartości granicznej,
zdarzenie wyżej ma miejsce,
przechodzi skrzynia biegów w stan drugi.
Jeżeli teraz ma miejsce zdarzenie luz,
to ono jest to przejście, jest odziedziczone przez stan drugi
i następuje przejście do stanu luz.
I popatrzmy, i to jest właśnie tu zapisane.
Czyli ze stanu luz zdarzenie F ma miejsce,
przechodzę do stanu pierwszy,
zdarzenie wyżej ma miejsce,
przechodzę do stanu drugi,
zdarzenie luz ma miejsce,
przechodzę do stanu luz.
No i takie z dowolnego ze stanów tak jest, przepraszam.
Więc podobnie, jeżeli ten luz nastąpi w stanie trzecim,
no to też następuje przejście, powrót do stanu luz,
co Państwo tutaj widzicie na tej sekwencji zmian.
Generalizacja stanów, którą tutaj Państwu pokazałam,
jest bardzo przydatna, bardzo wygodna.
Dlatego, że możemy w taki strukturalny sposób
podchodzić do tego naszego modelu.
Możemy zacząć od opisu modelu na takim wysokim poziomie abstrakcji,
czyli tutaj, tak jak ta nasza skrzynia biegów taka prosta, prawda,
plus wsteczny do przodu,
a potem ten stan do przodu uszczegóławiamy całą maszyną zmian stanów,
dokładniej to modelując.
Czyli mamy taką strukturę hierarchiczną,
mamy właśnie takie, no możliwość dziedziczenia pewnych przejść
przez te podstany.
To zagłębianie może być dowolnie głębokie,
czyli ja tutaj Państwu pokazałam
taki jeden poziom zagnieżdżenia,
jeden poziom takiej struktury,
ale no może trzeba będzie pójść głębiej
i więcej tych hierarchicznych diagramów zastosować.
Czasem te maszyny,
ja tutaj miałam te trzy stany,
ta maszyna była prosta,
natomiast no idea jest taka,
że to stosujemy wtedy, kiedy to zachowanie jest złożone
i możemy takie te stany jak gdyby abstrakcyjne sobie tworzyć,
to możemy proszę Państwa tutaj pokazać tylko taki stan abstrakcyjny,
natomiast mamy jak gdyby podpięty pod ten stan
cały diagram maszyny stanowej,
który modeluje co się dzieje w tym stanie,
jak ten stan się zachowuje.
Jeżeli korzystamy z narzędzi typu CASE,
na przykład Software Architect,
czy Enterprise Architect,
to wtedy takie kliknięcie w taki stan złożony
otwiera nam ten diagram niższego poziomu.
No i popatrzmy tutaj teraz na taki
pełen diagram maszyny stanowej.
Mam właśnie, tak jak Państwu mówiłam,
taki stan enrollment zapisy wprowadzony
i tutaj ten diagram, który poprzednio Państwu pokazywałam,
został cały ten diagram wewnątrz tego stanu enrollment umieszczony,
a następnie, prawda, tu mamy ten stan enrollment,
od niego odchodzi krawędź ze zdarzeniem canceru,
bo tak jak Państwo pamiętacie,
zaraz to Państwu przypomnę,
o tutaj, z każdego z tych stanów, prawda,
cały ten diagram ja umieszczam
jako diagram maszyny stanowej stanu enrollment zapisy,
z każdego z tych stanów było wyjście,
jak gdyby do tego końca,
poprzez zdarzenie cancer.
I właśnie,
właśnie dzięki temu,
momencik,
o, to ja teraz to prowadzę nie od każdego z tych stanów wewnętrznych,
tylko od krawędzi tego stanu enrollment.
Ale przypominam Państwu,
to przejście, cancer,
będzie dziedziczone przez każdy z tych stanów wewnętrznych.
Czyli jeżeli w stanie scheduled,
będzie miało miejsce zdarzenie cancer,
to i tak wychodzimy do tego stanu końcowego, prawda,
to seminarium, czy ten kurs został skasowany.
Natomiast, proszę popatrzeć,
jest możliwość taka,
aby było przejście, wyjście,
z jednego z tych stanów wewnętrznych,
na przykład tu mamy ten stan zamknięte zapisy.
I my, Państwo,
mamy zdarzenie rozpoczyna się semestr.
No, to teraz to seminarium przechodzi do stanu,
jesteśmy w trakcie nauczania.
No, tutaj przewidujemy sytuację,
kiedy może się student wypisać z tego seminarium
i na przykład, no, wypisał się,
jeżeli ciągle mamy tutaj,
no, jeszcze nie zerową liczbę studentów,
to dalej nauczamy.
Ale jeśli wszyscy studenci opuścili ten kurs, tak,
no, to też wychodzimy student z DOP
i wielkość tego seminarium jest równa zero,
to wychodzimy do stanu końcowego.
Kończy się semestr, classes end,
przechodzimy do stanu egzaminy końcowe.
Też w jakimś momencie te egzaminy się zamykają, prawda,
i mamy przejście do stanu końcowego.
Czy może mają Państwo jakieś pytania, uwagi,
które tego tematu dotyczą?
Tego zagnieżdżania stanów,
takiego abstrakcyjnego modelu,
hierarchicznego modelu maszyny stanowej?
Nie ma pytań?
Nie ma pytań?
Nie ma pytań?
Nie ma pytań?
Nie ma pytań?
Nie ma wątpliwości?
Wszystko jasne?
Proszę Państwa, no to mamy jeszcze jeden mechanizm kompozycji stanów,
kompozycję stanów, inaczej agregacja.
To jest podział na części składowe,
które mogą być równolegle wykonywane.
Czyli tutaj możemy powiedzieć,
że pewien stan składa się z jakichś tam podstanów
i te podstany, te maszyny stanowe poszczególnych podstanów
mogą być równolegle wykonywane.
I tutaj popatrzmy na taki prosty przykład.
Mam stan jakiegoś urządzenia, jest stan praca, tak?
Może pracująca.
Mówiłam przymiotniki, imię słowy przymiotnikowe,
więc tutaj można by raczej tę nazwę tego stanu troszkę rozbudować.
Ale w trakcie pracy tego urządzenia,
to urządzenie wykonuje jakieś zlecenia,
które do niego są kierowane,
ale również wykonuje testowanie,
czyli podlega testowaniu takiemu wewnętrznemu.
Więc mam tutaj ten stan praca,
jest podzielony taką linią przerywaną
na dwie części.
Które jak widać są od siebie niezależne.
Te są niezależne od siebie.
Wobec tego jest stan tego urządzenia.
To jest jeden ze stanów tutaj z tej górnej części
i jeden ze stanów z tej dolnej części.
Więc skoro tak to jest,
to ja mogę ten diagram maszyny, ten stan taki z agregacją stanów,
mogę to przekształcić do takiego diagramu płaskiego
bez tej agregacji stanów.
Bo tak jak Państwu mówiłam,
stan to jest jeden ze stanów stąd,
jeden ze stanów stąd.
Muszę wszystkie możliwości rozważyć.
Czyli ten z tym, ten z tym, ten z tym.
I to mam pokazane tutaj na tym diagramie.
Czyli właśnie test i czeka, test i wykonuje,
samo test czeka, samo test wykonuje.
No i przejścia.
Stan początkowy to jest test z czeka,
bo to są stany początkowe obu maszyn stanowych.
Jeżeli ma miejsce komenda,
to czeka zmienia się na wykonuje,
a na testa komenda nie ma wpływu.
Jeżeli tu jest warunek continue,
to przechodzimy tutaj, tutaj też.
Komenda ze stanu czeka na wykonuje
i zdarzenie stop do końca.
Czyli jest możliwość
z tego modelu z agregacją stanów,
z tego modelu z agregacją stanów,
jest możliwość uzyskania takiego,
czy zrobienia wręcz transformacji,
takiego modelu płaskiego.
Ale widzicie Państwo, tu jest większa liczba stanów.
Jeżeli ja tutaj mam n stanów,
a tutaj mam m stanów,
to jak ja chcę mieć taki model płaski,
to ja mam n razy m,
a więc mogę mieć tych stanów bardzo dużo.
Tu było tylko dwa razy cztery.
Dwa razy dwa jest cztery.
Ale gdybym miała tutaj na przykład dwa,
a tutaj miała cztery,
to już tych stanów byłoby osiem
i to byłoby znacznie trudniejsze do zrozumienia.
Także takie modele strukturalne maszyn stanowych
też mamy w UML-u
i są one bardzo przydatne.
Maszyny stanowe,
maszyny stanowe mają jeszcze inne własności,
ale to już Państwu będę mówić na kolejnym wykładzie.
Na tym chcę dzisiaj zakończyć.
Jeszcze raz pytanie,
czy mają Państwo jakieś wątpliwości, pytania,
coś mogłabym wyjaśnić z tego,
co przed chwilą Państwu pokazywałam.
Nie ma pytań, nie ma wątpliwości,
więc kończymy dzisiaj tutaj na tym slajdzie
tą prezentację dotyczącą maszyny stanowej.
Zatrzymuję oczywiście nagrywanie.
---------------------------------------------Ja z inżynierii oprogramowania, ja może zacznę od pokazania Państwu, chwileczkę, bo muszę udostępnić, nie to, dobra.
Ja dzisiaj troszkę z innego miejsca prowadzę zajęcia niż zazwyczaj, więc gdyby coś było nie tak, to bardzo proszę o informację, na przykład czy mnie słychać w tej chwili?
Tak.
Tak, super, bardzo dziękuję.
Tak jak mówiłam Państwu, chciałabym zacząć od pokazania prawidłowych rozwiązań.
Ja tutaj się posłużę rozwiązaniem Pana Bartłomie Jaguty.
Mam nadzieję, że Pan Bartek wyrazi zgodę na pokazanie swoich odpowiedzi, jeżeli jest w tej chwili obecny.
I przy okazji powiem, jakie były inne możliwości.
Otóż zacznę może od tego prostszego zadania, czyli było podane, i tego typu zadania możecie się Państwo spodziewać właśnie na egzaminie,
że jest podane jakieś zadanie.
I na podstawie tego zdania trzeba narysować diagram klas, który będzie to modelował, będzie modelem tego.
I to zdanie było, w sklepie są telewizory, odtwarzacze, radioaparaty fotograficzne.
No więc tutaj, tak jak Państwu podpowiadałam, kandydatem do tego, aby być klasą są rzeczowniki, przy czym rzeczownik w liczbie pojedynczej,
a więc sklep, odtwarzacz, radio, aparat.
I mamy tutaj klasę, która modeluje sklep, mamy klasę abstrakcyjną urządzenie i właśnie ten telewizor, odtwarzacz, aparat fotograficzny, radio
są pewnym szczególnym typem urządzenia, stąd relacja generalizacji, one dziedziczą pewne cechy ogólne tego urządzenia
i mają swoje jakieś cechy charakterystyczne.
Także tych telewizorów, czy odtwarzaczy, czy aparatów fotograficznych jest wiele.
To jest tutaj zamodelowane za pomocą tej krotności gwiazdki, czyli znaczy to dowolnie wiele.
No i przy okazji chcę od razu zwrócić uwagę na taki, ktoś z Państwa jeszcze stawiał gwiazdki tutaj po tej stronie, przy tych klasach specjalizowanych.
To jest absolutnie niepotrzebne, dlatego że to, że tych urządzeń może być wiele,
jest właśnie zawarte w tej gwiazdce tutaj sklep i urządzenie.
I to jest jak najbardziej prawidłowe rozwiązanie, takie jakiego ja bym oczekiwała i jakie mam nadzieję, że tego typu dobre rozwiązania pokażecie Państwo na egzaminie.
Teraz kilka osób postawiło tutaj po stronie sklepu relacje agregacji, czyli jak gdyby widziało, że sklep jest pewnego rodzaju całością,
że w nim...
Są jakieś urządzenia, no i też te urządzenia określonego typu.
I proszę Państwa, ja bym takie rozwiązanie, ja zwykle tym osobom pisałam, że raczej nie agregacja.
Ta agregacja tutaj mogłaby być, gdybyście Państwo dodali swoje wyjaśnienie, czyli gdybyście napisali, że dla Was ten sklep to jest pewnego rodzaju...
Nie taki, prawda, fizyczny sklep, tylko że jest to pewnego rodzaju lista właśnie urządzeń, czy lista produktów.
Czyli z takim dodatkowym wyjaśnieniem, że dla mnie sklep jest pewną listą, pewnym może raczej pewnym zbiorem urządzeń, to wtedy ta relacja agregacji jest do zaakceptowania.
W innym przypadku raczej my ten sklep widzimy jako coś takiego...
No zazwyczaj fizycznego i wtedy no trudno powiedzieć, że takie urządzenia są częścią tego sklepu, więc ta relacja agregacji bez tego dodatkowego wyjaśnienia jest nieprawidłowa.
Czy może mają Państwo do tego jakieś pytania, może ktoś by się chciał spytać, nie wiem, o swoje rozwiązanie, które podesłał na Teamsach, coś jeszcze wymaga wyjaśnienia?
Tak, zaraz będzie drugie zadanie. Do tego nie ma pytań żadnych?
To zamykam ten plik i mamy zadanie drugie.
Mamy zadanie drugie. Zadanie drugie trudniejsze, ale też tego typu zadania należy się spodziewać na egzaminie, mogą się pojawić na egzaminie.
I to jest tak, ja chyba...
Ja Państwu mówiłam, z któregoś roku wręcz to zadanie wzięte z egzaminu, w którymś roku, narysowałam tutaj pewien diagram sekwencji, tak?
I pytanie było, narysuj fragment diagramu klas wynikający z podanego diagramu sekwencji.
Tutaj podkreślam, uzasadnij. Właśnie we wszystkich tego typu zadaniach musicie Państwo uzasadniać swój punkt widzenia.
Tak jak przed chwileczką Państwu mówiłam, że w tym sklepie ta agregacja...
Byłaby do przyjęcia, gdybyście dodali swoje wyjaśnienie, że dla Was ten sklep jest pewnym zbiorem urządzeń, produktów.
Więc koniecznie te wyjaśnienia. Czyli tutaj mamy diagram sekwencji, w którym mamy obiekty.
Jakiś obiekt typu X, jakiś obiekt typu Y, jakiś obiekt typu P, klasy P.
A więc słusznie.
Widzimy tutaj trzy klasy o właśnie nazwach X, Y i P.
Nie dwukropek X, nie dwukropek Y, tylko, bo jeżeli tutaj już mamy dwukropek i nazwa klasy, to widzimy, że to jest dla nas obiekt.
Tylko tu muszą być klasy, bo ja chciałam diagram klas, a nie diagram obiektu.
Stąd właśnie te nazwy klas tutaj przechodzą automatycznie.
Teraz patrzymy, jak wygląda komunikacja pomiędzy tymi obiektami.
I widzimy tak, że tu jest komunikacja, strzałeczka pokazuje w stronę obiektu klasy X, ale w drugą stronę do obiektu z X do Y nie ma żadnej komunikacji.
Tutaj mamy komunikat asynchroniczny, czyli te informacje przechodzą tylko w kierunku obiektu klasy X.
Stąd tutaj właściwie jest użyta asociacja jednokierunkowa, bo widzimy, że wystarczy ten jeden,
kierunek przesyłu informacji wynikający z tego komunikatu asynchronicznego.
Natomiast popatrzmy teraz, jak wygląda komunikacja pomiędzy obiektami klasy X i klasy P.
Widzimy, że jest komunikacja w stronę P i widzimy, że jest komunikacja od P do X.
Czyli z tego wynika, że pomiędzy klasą X i klasą P musi być asociacja dwukierunkowa.
Musimy umożliwić dwukierunkowy przepływ informacji, stąd widzimy, że tutaj jest asociacja dwukierunkowa.
Teraz popatrzmy na komunikację pomiędzy obiektem klasy Y i klasy P.
Tutaj widzimy komunikat synchroniczny, ale komunikat synchroniczny oznacza,
że musi wrócić sterowanie do obiektu wywołującego, czyli musi być tutaj komunikacja dwukierunkowa.
Stąd widzimy, że jest komunikacja dwukierunkowa.
Stąd widzimy, że jest komunikacja dwukierunkowa.
Jeżeli widzimy tutaj pomiędzy klasą Y i klasą P, mamy też asociację dwukierunkową,
bo właśnie musi wrócić to sterowanie, więc musi być możliwy przepływ informacji w obu kierunkach.
To były klasy i związki pomiędzy nimi.
Teraz kwestia umieszczenia operacji.
A więc przypomnę, że jeżeli tutaj widzimy taki komunikat przesyłany do obiektu klasy X,
i on się nazywa A.
To znaczy, że jest wywoływana operacja A z klasy X.
I tutaj bardzo dobrze jest umieszczona ta operacja A w klasie X.
Zwracam uwagę również na to, że musimy we właściwym polu tę operację wpisać.
Przypomnę, że w diagramie klas pierwsze pole to jest nazwa klasy,
drugie to jest pole dla atrybutów, o których tutaj nic nie wiemy,
i to trzecie pole na dole to są to operacje.
I tutaj też kilka osób jak gdyby zapomniało o tym i pisało mi operacje w polu drugim.
Ja pisałam wtedy komentarz, że to nie są atrybuty, tylko to mają być operacje.
Także niestety Państwo musicie stosować się do standardu UML-owego.
I operacje muszą być we właściwym polu umieszczone.
Teraz proszę popatrzeć na ta operacja.
Operacja A jest poprzedzona plusikiem.
No właśnie, bo żeby obiekt klasy Y mógł ją wywołać, to ona musi być publiczna.
Stąd poprzedzona jest plusem.
Operacja A jest publiczna, ale musi się znajdować w klasie X.
I tu widzimy kolejną operację, którą wywołuje obiekt klasy P,
też z obiektu X, operację D, stąd też ona musi być publiczna
i umieszczona jest w klasie X.
Jeśli chodzi o klasę Y, to popatrzmy tutaj, z niej jest wywoływana jedynie operacja C,
też musi być publiczna, stąd tutaj rozmieszczenie tej operacji C w klasie Y.
I w klasie P tutaj jest wywoływana operacja o nazwie B, też musi być operacją publiczną.
I to jest jedyne słuszne rozwiązanie tutaj tego zadania.
Czy ktoś z Państwa ma może do tego jakieś pytania?
A te C to jest przypisane do tej strzałki, która idzie z X do P, czy z P do Y?
To C? No idąc od góry, A do tej strzałki, bo musi być nazwa komunikatu,
więc tu jak gdyby pierwsza to do tej, B do tej, C do tej.
Nazwy komunikatów zwyczajowo się pisze nad strzałką.
Dobra, czy coś jeszcze może mają Państwo jakieś pytania?
A czy jak rozwiązałam te otwarte zadania, to też Pani punkty jakieś stawiała za to?
Proszę Państwa, ja stawiałam punkty za te zadania, które żeście mi przysłali w skali,
ale to są tak zwane małe punkty, czyli to wcale nie znaczy, że na koniec semestru one rzeczywiście w takiej formie przejdą,
bo one będą przeskalowane później.
Więc stawiałam jeden punkt za to zadanie z tym sklepem i z tymi urządzeniami
i do trzech punktów za to zadanie, które w tej chwili rozwiązanie oglądamy.
I teraz nawet jeżeli to rozwiązanie, ten diagram klasy, sklep, urządzenia nie był identyczny jak to rozwiązanie,
które Wam pokazywałam przed chwilą, ale były tam jakieś dobre elementy, czy brakowało powiedzmy tego,
założenia, jak Wy traktujecie ten sklep, to zwykle stawiałam ten jeden punkt.
Chyba, że ktoś to zrobił już całkiem niedobrze, na przykład ktoś relacje agregacji postawił po stronie urządzenia,
czyli dla kogoś sklep był elementem składowym urządzenia, co jest oczywiście nieprawdą.
No to wtedy dostał zero punktów.
Za to stawiałam po trzy punkty.
No i tutaj jeżeli ktoś na przykład te operacje wstawił w polu atrybutów,
to już nie miał tych trzech punktów, tylko nie wiem, może miał dwa punkty.
Także starałam się tam te punkty jakoś Wam przydzielić, natomiast no one są u mnie,
więc jeśli ktoś ma konkretną pytanie, znaczy ja bym, jeżeli Wam zależy,
to ja mogę te punkty częściowe jakoś Wam udostępnić, no tylko nie wiem, znowu nie wolno mi jakoś tam Waszych danych personalnych upublicznać,
więc, więc...
Nie wiem, czy po numerach indeksów, numerami indeksów, czy coś, jeśli, jeśli bardzo Wam zależy na tym,
to może albo się proszę ze mną indywidualnie, nie wiem, na czacie na przykład skontaktować, pytaniem mi wysłać.
Ile mam punktów?
Znaczy tak, ale to zadanie, tak jak robimy jeszcze, jeszcze mnóstwo takich pytań otwartych i, i właśnie je zrobimy,
czy właśnie to Pani też stawiała za to, za to punkty, czy...
Za co, za co?
Właśnie te zadania otwarte były jeszcze, pod tym, pod tym właśnie zadaniem właśnie narysowania diagramu klas i tak dalej,
tych sekwencji, diagramu sekwencji.
Tamtego w ogóle nie, jak gdyby tamtej części w ogóle nie sprawdzałam,
a tam rzeczywiście coś ktoś z Państwa coś napisał, to ja jakoś jak gdyby się skoncentrowałam tylko na tym.
Tak.
Nie wiem, może tam była druga strona?
Tak, tam były różne tam pytania takie.
A, to, no bo to był przykładowy egzamin, ale nie tamtej, jak gdyby tamtych części nie, nie sprawdzałam w ogóle, nie patrzyłam co tam,
czy tam ktoś coś napisał, jedynie jak gdyby na, na to zadanie patrzyłam. Natomiast no, jeśli macie tutaj jakieś pytania, jak, jak należy odpowiedzieć na to,
to bardzo proszę, żebyście, nie wiem, może ktoś, żeby, jak Pan ma pod ręką te pytania, to proszę je powiedzieć i spróbujemy wspólnie na te pytania odpowiedzieć.
Bo tutaj, no tutaj, prawda, ja nie, nie widzę nic więcej.
Dobrze, to ja zaraz otworzę.
Dobra, niech Pan otworzy, tak, i, i możemy, możemy punkt po punkcie przejść.
Jeżeli, jeżeli już ten materiał był na wykładzie, to spróbujemy na to odpowiedzieć.
Albo zaraz.
Bo ja spróbuję to znaleźć.
Czy to było w tym pliku z sekwencjami? Chyba tak.
Tak, tak, zadania, sekwencje, klasy.
Ok.
Ok, ok, dobra, to ja już to znalazłam. Spróbuję to otworzyć.
A, rzeczywiście, to są trzy strony.
A, ja tutaj tylko tą pierwszą.
Dobra, to zaraz popatrzymy, co tam dalej jest.
Dobra, tu było zadanie z sekwencją, a co było dalej?
Ok, faktycznie, to, to tego, znaczy tutaj jeszcze niektóre rzeczy są, no właśnie, tutaj jeszcze jest jakieś inne zadanie.
To, jak Państwo widzicie, kiedyś były dwie grupy, ja wzięłam zadanie z jednej grupy i całą.
Dobra, chcecie, żeby tutaj przejść przez te pytania otwarte?
Tak.
Tak, dobra. Więc, no właśnie, po co się stosuje UML-a? Ktoś ma jakiś pomysł?
Żeby stworzyć wyraźny algorytm jednoznacznie opisujący kody do implementacji.
Tak, żeby, przede wszystkim, żeby zrobić projekt systemu.
Przede wszystkim, żeby zrobić projekt systemu, który ma być realizowany, prawda?
I to taki projekt, no, różne, różne poziomy tego projektu, zarówno taki projekt, co ten system ma robić, to mamy diagramy class, prawda?
Co w tym systemie się musi znajdować, to mamy, przepraszam, diagramy use case mówią, co system robi, diagramy class, co w tym systemie się znajduje, diagramy sekwencji i diagramy czynności,
o których jeszcze chyba Wam nie mówiłam, mówią, w jaki sposób pewne rzeczy należy zrealizować.
Diagramy maszyny stanowej, o które żeśmy poznali ostatnio, dają model zachowania i takie diagramy, o których dzisiaj będę mówić, pokazują nam, modelujemy architekturę tego systemu.
Czyli właśnie po to, żeby mieć dobry projekt i co więcej, jeżeli korzystamy z narzędzi typu case,
to z diagramu class można mieć wygenerowane szkielety kodu tego systemu, także bardzo dużo.
Dobra, fazy modelu wodospadowego, ktoś pamięta? Bo na pierwszym wykładzie.
Określenie wymagań, projektowanie, implementacja, testowanie, eksploatacja i pielęgnowanie.
Tak, znaczy to, jak gdyby ta eksploatacja już nie jako faza, tylko tutaj chodzi o model procesu, czyli to pielęgnowanie wystarczy.
Również jako takie główne fazy wystarczy.
Natomiast też mówiliśmy tam, i będziemy się tego jeszcze uczyć, jeśli chodzi o testowanie, to będziemy to na mniejsze kawałeczki rozbierać, pewnie dzisiaj już.
I jeśli chodzi o ten projekt, no to też.
Dobra. Przykład relacji agregacji na diagramie class. Ktoś ma jakiś pomysł?
No na przykład, jak Pani tam na wykładzie...
No na przykład jak Pani tam na wykładzie...
No na przykład jak Pani tam na wykładzie...
Na przykład klasa książka i właśnie jest połączona agregacją z rozdziałem i paragrafem.
Tak, dobrze. A rozdział jest widziany jako pewien zbiór paragrafów, tak?
Tak.
Dzisiaj pojawił się ten sklep, więc na przykład można by powiedzieć, że nie wiem, sklep zawiera ileś pomieszczeń, także składa się z kilku pomieszczeń.
Jeżeli widzimy sklep jako taki pewien twór architektoniczny, to możemy użyć relacji agregacji i takim jego elementem składowym może być na przykład pomieszczenie.
Czyli na przykład powiedzmy sala, widziana jako znowu taki element architektoniczny.
Czyli na przykład powiedzmy sala, widziana jako znowu taki element architektoniczny.
Tak, a z tymi elementami składowymi może być sufit, podłoga, ściany.
Dobra, jeśli chodzi o kombajnt, fragment ktoś z Państwa pamięta?
Jakie były kombajnt, fragment, fragmenty złożone?
Na poprzednim wykładzie...
Combajnt... Alt, alternatywa.
Dobrze, dobrze. Alt, opt lub pętla, par, równoległość.
Tak, tak.
Tak, tak.
Super. O testowaniu będziemy się uczyć, narzędzia strukturalne, metody strukturalne jeszcze nie.
No i tutaj mamy też jeszcze taki do narysowania diagram klas.
Na stole są łyżeczki do herbaty i łyżki do zupy, noże, widelce, widelczyki do ciasta.
Tutaj Pan, który zauważył, że tam było więcej stron, czy Pan namalował rozwiązanie tego zadania?
Tak, tak, tak. To właśnie tylko mi się tak na telefonie tak wyskalowało, że takie zdjęcie jest małe, to spróbuję to ja otworzyć jakoś.
A jak Pan się nazywa? Może ja znajdę Pana pracę tutaj w Teamsach i może będzie to lepiej widać.
Jak Pana nazwisko?
Remkiewicz.
Okej, zaraz popatrzymy. Ja spróbuję tutaj Pana rozwiązanie znaleźć w...
No, gdzie my to mamy?
Z tymi sekwencami to mnie też właśnie nie poszło, z tymi parametrami, ale tak jeszcze to tam robiłem.
Okej.
O, tutaj, tak? Pan Michał Remkiewicz.
Dobra, spróbujemy popatrzeć, co?
Przy okazji.
Tak, ja tam dalej nie patrzę.
Nie patrzyłam, natomiast to rozumie Pan już, jak powinno być?
Tutaj pewne elementy były okej, prawda? Że są klasy X, Y, P, to to Pan zrobił dobrze.
Brakuje powiązania, asocjacji między klasą Y i C, tak? Tutaj nie ma powiązania.
A widzimy... Przepraszam, między klasą Y i P, tak?
A widzimy, że tutaj...
Jest ta asocjacja dwukierunkowa, więc musi być...
Jest komunikat synchroniczny, więc musi być asocjacja dwukierunkowa.
Operację Pan umieścił. Tutaj należałoby po prostu dodać informację, że na przykład u Pana ta kropeczka to oznacza, że to jest operacja publiczna.
To rozumiem, że ten rysunek Pan w jakimś tam narzędziu robił i być może, że...
Więc to należałoby albo tutaj w treści napisać, prawda? Tego opisu.
Że ta operacja P musi być... Czy operacja C, czy B, czy A, czy D, że są to operacje...
Są to operacje... Ok, tu Pan przepisał ten... Dobra, tu mamy...
O, i tu mamy te łyżeczki i coś, tak?
Stół. No właśnie, i tutaj mi się to nie podoba, że tutaj Pan zastosował agregację.
Dla mnie stół to jest coś takiego, no, co ma blat, ma cztery nogi.
Tak?
Więc tutaj nie relacja agregacji, tylko asocjacja, prawda?
Stół jest powiązany z obiektami klasy sztuciec i tych obiektów może być wiele.
Dobrze, Pan użył tutaj tej krotności wiele.
I teraz te łyżeczki, łyżki i tak dalej są pewnym szczególnym typem, prawda?
Pewnym... Także tutaj ta generalizacja jest ok.
Tu nie trzeba pisać, że coś dziedziczy, bo to, że dziedziczy, to wynika z tego
krotu strzałki, która jest właśnie relacją generalizacji.
Także tu nie pisze się nic na tej relacji generalizacji.
To, że dziedziczy, że wskazuje Pan klasę taką bardziej ogólną, w tym wypadku jeszcze warto by było,
żeby ta klasa sztuciec była klasą abstrakcyjną, więc można by tutaj zaznaczyć,
że klasa sztuciec jest abstrakcyjna i albo, no, jak się robi w jakimś narzędziu,
to taką czcionką pochylić.
Pochylona.
Dobra. I to rozumiem, że teraz już pewnie by Pan wiedział, czy to jest całkiem dobrze zrobione.
Chyba nie.
Chyba nie, tak.
Szukamy błędu u Pana, czy sam Pan?
Można poszukać.
Można poszukać, dobra.
Dobra, to poszukajmy w takim razie.
Popatrzmy tak.
Klasy ABC.
Ma Pan klasy ABC, super.
Teraz tak, operacje muszą być w tej klasie, do której ten komunikat jest kierowany.
Czyli w klasie B powinna być operacja X i Z, w klasie B operacje, a tutaj u Pana nie te operacje są.
Złe rozmieszczenie operacji.
W klasie A nie ma żadnej operacji, nic tu z niej nie jest wywoływane.
Operacja X to jest operacja,
w klasie odbierającej ten komunikat.
Czyli X musi być w klasie B.
V musi być w klasie C.
Y musi być w klasie B.
I Z musi być w klasie B.
A o klasie A, o jej operacjach nic nie wiemy.
Czyli te operacje niewłaściwie Pan umieścił.
Teraz, między A i B, asociacja dwukierunkowa.
Super, jest u Pana asociacja dwukierunkowa.
Przy czym tutaj Pan użył od jeden do wielu.
My nie wiemy, ile tych obiektów klasy B jest.
Czyli tutaj ta gwiazdka, którą Pan ma przy klasie B,
jest nieuzasadniona.
Nie wynika ona, być może tak jest,
ale bezpośrednio z tego diagramu ona by nie wynikała.
Wynikałaby, gdyby tutaj umieścić lupa.
Z tego wynikałoby, że może być coś tutaj,
wiele rzeczy się działo.
To wtedy może tak, ale w tej chwili nie.
I pomiędzy B i C operacja,
to jest właśnie asociacja dwukierunkowa.
Czyli asociacje ok, klasy ok, jeśli chodzi o nazwy klas,
natomiast operacje źle umieszczone.
Dobra, czy to już wszystko, czy jeszcze ktoś ma jakieś pytania?
Tam jeszcze te otwarte były trochę,
ale tam już było mnóstwo tego.
Jeszcze te otwarte, Pan mówi, że tam jeszcze coś było,
ale to być może, że to już jest,
nie wiem, czy to dotyczy tego materiału,
który już był.
Ja parę pominęłam, bo wynikało, że jeszcze nie było.
Jeszcze raz popatrzymy na Pana Michała pracę.
Dziękuję.
O modelach strukturalnych pominęłam, bo to będzie dopiero na wykładzie,
więc na razie to pominęłam całkowicie.
Aha, tu jeszcze są takie, tak?
Inżynieria, oprogramowania, czym się zajmuję,
metody, narzędzia, techniki projektowania.
To jest okej.
To jest okej.
Jak można organizować, strukturalizować aktorów.
Generalizacja.
Tak.
I w zasadzie tyle.
I w zasadzie tyle.
Dobra, agregacja, to mamy przykład.
Jak można już case'y strukturalizować?
Za pomocą generalizacji.
Dobrze.
Zależne od tego, jak można je strukturalizować.
Jak można je strukturalizować?
Za pomocą generalizacji. Dobrze.
Zależność z rozszerzeniem extend i include.
Zależność z rozszerzeniem extend i include.
To się nazywa stereotyp extend i include.
To się nazywa stereotyp extend i include.
Dobrze.
Testowanie pominę, bo jeszcze nie było.
Miara niezawodności oprogramowania też jeszcze nie była,
więc będziemy do tego wracać.
Dobra, to myślę, że to tyle.
Dobra, to myślę, że to tyle.
No to mieliśmy dzisiaj troszkę takich rzeczy powtórzeniowych.
No to mieliśmy dzisiaj troszkę takich rzeczy powtórzeniowych.
że to nikomu krzywdy nie zrobi. Troszkę czasu żeśmy na to zużyli, ale mam nadzieję, że to jak gdyby z korzyścią dla Państwa, bo pewne rzeczy powtórzyliśmy.
Dobra, rozumiem, że nie ma już więcej pytań. Czy ktoś jeszcze ma jakieś pytania dotyczące pracy domowej?
A Panu Michałowi ja dostawię punkt za wkład pracy w te rozwiązania, zadań, o których ja w ogóle nie wiedziałam, że Wam dałam. Byłam tego nieświadoma. Ja sobie zapiszę.
Pan Michał Rynkiewicz. Za wkład pracy w rozwiązywanie zadań otwartych, pytań otwartych dostanie Pan dodatkowe punkty.
Dobra, proszę Państwa, teraz chcę wrócić do diagramów maszyn stanowych, o których mówiłam Państwu na poprzednim wykładzie. Sekundeczkę jeszcze.
I na poprzednim wykładzie mówiłam Państwu, że jest możliwość strukturalizowania tych diagramów maszyn stanowych.
Diagram, taki model było zrozumieć, żeby łatwiej było taki model zachowania przygotować.
I tutaj, bo jeżeli taki, no jakby wymyślamy w jakich stanach może znajdować się obiekt, zastanawiamy się nad przejściami ze stanu do stanu, nad zdarzeniami, które wyzwalają takie przejścia,
to często ten model maszyny stanowej robi się bardzo, bardzo złożony.
I oczywiście jesteśmy w stanie zrozumieć, zaprojektować model, którym tych stanów jest, no nie wiem, kilkanaście, czy powiedzmy góra kilkadziesiąt, ale już jak jest kilkaset, to na pewno nie.
Więc trzeba sobie z tą złożonością jakoś radzić.
No i jedno podejście, o którym Państwu mówiłam na poprzednim wykładzie, to jest takie podejście, takie jak gdyby hierarchiczne.
Czyli widzimy...
Jest pewien stan, tutaj mam ten stan enrollment, zapisy na jakieś tam seminarium, czy na jakiś kurs.
I to jest dla nas taki stan abstrakcyjny, ale mamy cały model maszyny stanowej, który modeluje, co się dzieje w tym stanie.
Że może być kurs zaproponowany, przydzielony w harmonogramie, otwarte zapisy, już pełny dla zapisów, zamknięty.
Czyli widzimy ten stan enrollment, stan abstrakcyjny.
Mamy tutaj w postaci całej maszyny stanowej zrobionej, albo go pokazujemy w takiej postaci właśnie pełnej,
albo jeżeli on jest bardzo złożony, to tutaj pokazujemy tylko ten stan abstrakcyjny, a na całym diagramie mamy ten stan dokładnie rozpisany.
Teraz druga metoda, o której wspomniałam, że jest, ale której już nie omawiałam na poprzednich zajęciach,
to jest kompozycja, inaczej agregacja stanów.
To jest, proszę Państwa, znowu takie podejście, że my widzimy, że pewien stan, jak gdyby składa się z kilku części.
I to się nazywa agregacja stanów.
Tutaj widzimy, jak gdyby takie komponenty tego stanu, te komponenty mogą się wykonywać równolegle,
mogą być niezależne od siebie, mogą być zależne od siebie, to już te przejścia pomiędzy tymi stanami,
to już jak gdyby od nas zależy, jak ten model zrobimy.
I popatrzmy na taki bardzo prosty, czyli widzimy pewien stan, na przykład stan praca jakiegoś urządzenia,
czy może urządzenie pracujące, i to urządzenie w trakcie tej pracy, my widzimy, że ono może jak gdyby być,
agregacją dwóch stanów.
Jeden stan abstrakcyjny, testowanie, czyli to urządzenie pracuje, właśnie pracuje, wykonuje zlecenia, które do niego są kierowane,
ale równocześnie może być, może się testować.
Tu mamy ten drugi komponent, czyli tutaj mam taką agregację dwóch podstanów, stanu testowanie i stanu wykonywania zleceń.
Czyli ta praca jakiegoś urządzenia, na przykład, widziana jest jako taka kompozycja testowania i wykonywania zleceń.
I teraz ten stan testowanie, pokazujemy jego model.
Tutaj w tym moim przypadku ma on dwa proste stany, test, samotest, stan początkowy, stan końcowy.
Tutaj mamy po prostu diagram maszyny stanowej w tym wypadku, bardzo prosty, który ten stan testowanie modeluje.
I to wykonywanie zleceń też.
Mamy jakiś stan czeka, przychodzi komenda, coś on wykonuje, stan wykonuje, jest jakiś warunek continue spełniony, wracamy do stanu czeka.
Jeżeli jest jakiś warunek stop, przechodzimy do końca.
Czyli widzimy takie złożenie dwóch stanów.
I teraz możemy mieć taki właśnie model, no nazwijmy to właśnie taki strukturalizowany z agregacją stanów.
Ale możemy ten model przełożyć do takiego modelu płaskiego.
W ten sposób, że musimy każdy ze stanów tutaj z tej jak gdyby pierwszej składowej, tak, połączyć z każdym ze stanów z drugiej części składowej.
Czyli jeżeli ja mam zaraz, tutaj bym chciała coś namalować, o właśnie.
Czyli mogę stan test.
Połączyć ze stanem czeka.
Test ze stanem czeka.
I oba te stany są zaznaczone kropką jako stany początkowe.
Czyli taki stan test czeka będzie stanem początkowym.
Tak, potem ten test mogę połączyć z wykonuje.
Samo test z czeka i samo test z wykonuje.
Też mogę połączyć stąd.
Dostajemy, tak jak Państwo widzicie, takie cztery stany.
No w tym wypadku tylko...
Tylko cztery stany.
Natomiast w ogólnym przypadku, jeśli tutaj mam n stanów, a tu mam m stanów, no to gdybym chciała mieć taki model płaski zrobiony nie z taką strukturalizacją, to bym miała n razy m stanów.
Więc widzimy, że ta liczba stanów bardzo rośnie, więc łatwiej jest nam zrozumieć, przygotować taki model właśnie ze strukturą tych stanów.
Jeżeli rzeczywiście taka sytuacja ma miejsce.
Tutaj w tym przykładzie widzimy, że ta maszyna stanowa stanu testowanie i maszyna stanowa stanu wykonywanie zleceń, one pracują niezależnie.
Nie ma pomiędzy nimi żadnych zależności, ale mogą być takie zależności.
Mogą być jakieś zdarzenia, które na przykład...
Powodują, że tu jest przejście i to samo zdarzenie może być w tej drugiej maszynie stanowej użyte.
Także możemy takie zależności pomiędzy tymi maszynami stanowymi też robić, o ile oczywiście będzie to nam przydatne.
Dobra, gdzieś mi się tu jest.
Coś się stało, nie chce mi się...
O, jest.
Czyli łatwiej jest pracować, łatwiej jest przygotować, zrozumieć taki model ze strukturalizacją.
Niż taki model płaski, w którym żeśmy po prostu jawnie wymienili wszystkie możliwe złożone stany.
Czy to jest dla Państwa jasne, jak to działa?
Bo będziemy dzisiaj jeszcze też robić takie zadanie.
Ktoś ma jakieś pytanie do tego?
Dobra, to zobaczymy jak nam pójdzie potem zrobienie zadania.
Dobra, proszę Państwa, teraz chcę powiedzieć o kolejnych możliwościach.
Jakie mamy w diagramach maszyn stanowych.
Mianowicie o mechanizmie historii.
I najpierw wyobraźmy sobie, że mamy taki diagram maszyny stanowej, jak ten, który tutaj widzimy.
I nie ma tego mechanizmu, nie ma tego kółeczka z literką H, które ja na czerwono zaznaczyłam.
Tego na razie nie ma.
Wobec tego, jak będzie...
Będzie to się zachowywało.
Czyli na przykład powiedzmy, że to jest stan początkowy.
I teraz zaczynam w stanie A.
Wyobraźmy sobie, że ma miejsce, zachodzi zdarzenie IN.
No to jeżeli ma miejsce zdarzenie IN, to obiekt przechodzi do stanu którego?
Do stanu C, który tu został zaznaczony jako stan początkowy.
Czyli obiekt będzie w stanie C.
Jeżeli teraz będzie miało miejsce tutaj zdarzenie Y, to obiekt przechodzi do stanu B.
Jest w stanie B.
Jeżeli w stanie B teraz wystąpi zdarzenie OUT,
tak, wyobraźmy sobie, że wystąpi zdarzenie OUT,
widzimy, że to jest zdarzenie, które jest pociągnięte od tej krawędzi tego stanu abstrakcyjnego D.
Czyli ono będzie odziedziczone.
Zadziedziczone zarówno przez stan B, jak i przez stan C.
No to znaczy, że obiekt wróci do stanu A.
Wpływam zdarzenia OUT, on wróci do stanu A.
I teraz, jeżeli znowu się pojawi zdarzenie IN,
tego kółeczka na czerwono nie ma,
to on zawsze będzie zaczynał od stanu początkowego.
Czyli zawsze będzie zaczynał od tego, wchodząc do tego stanu,
zawsze będzie zaczynał od stanu początkowego.
W tym przypadku C.
A nie zawsze taka sytuacja jest pożądana.
Czasem chcemy, żeby to, jak gdyby ta maszyna tego stanu działała dalej.
Czyli jeżeli byśmy chcieli teraz właśnie,
jeżeli włączymy ten mechanizm historii,
mamy włączony mechanizm historii,
teraz to kółeczko z literką H już działa,
to znaczy, że będzie pamiętany stan,
w którym ostatnio byliśmy.
A więc też zaczynamy w stanie A.
Pod wpływem IN przechodzimy do stanu C.
Pod wpływem Y przechodzimy do stanu B.
Pod wpływem OUT,
ja tu napiszę tylko O, żeby było szybciej,
przechodzę do stanu A.
I teraz, proszę Państwa, jeżeli pojawia się zdarzenie IN,
ale mam ten mechanizm historii włączony,
to on pamięta, że był w stanie B.
I on nie zaczyna wszystkiego od początku,
tylko kontynuuje, będąc w stanie B.
No i czasem taki model nam jest przydatny.
Czy to jest jasne?
Czy ktoś z Państwa może ma jakieś pytania do tego?
Czyli jak wychodzi, to używa OUT,
a jak tak jakby wraca, to wraca...
To OUT?
To OUT jest dziedziczone,
czyli nawet gdyby był w stanie C i pojawia się zdarzenie OUT,
to też wyjdzie i też wrócimy do stanu A.
Ono jest, ponieważ jest prowadzone tutaj,
widzimy od tej krawędzi tego stanu abstrakcyjnego D,
to ono jest dziedziczone przez wszystkie stany,
które są wewnątrz.
Jeżeli nie ma mechanizmu historii,
to zawsze będzie zaczynał,
jak wchodzimy do tego stanu,
czyli zdarzenie IN,
zawsze będzie powodowało,
że zaczynamy w stanie,
który tu jest oznaczony jako początkowy.
Natomiast jeżeli włączymy mechanizm historii,
to on będzie pamiętał stan,
w którym ostatnio byliśmy.
Czyli na przykład,
jeżeli to OUT miało miejsce ze stanu B,
to kolejne zdarzenie IN
przywróci go do tego stanu B.
Będzie dalej kontynuował.
OK?
Może być?
Jasne?
Dobra.
Tutaj mamy to rozpisane,
to możecie Państwo sobie jeszcze potem to...
I tutaj proszę popatrzeć na taki przykład,
no z życia wzięty.
Wyobraźmy sobie,
że modelujemy zachowanie pralkosuszarki
i najpierw widzimy takie stany abstrakcyjne,
jak pranie,
które też jest pewnie stanem złożonym,
płukanie, suszenie.
No i teraz na przykład chcemy,
mamy tutaj zdarzenie otwarcie drzwi,
które widzimy, że jest zdarzeniem dziedziczonym
przez każdy z tych stanów wewnętrznych, tak?
I teraz wyobraźmy sobie,
że no rozpoczyna się ten proces, tak?
I tutaj ma miejsce zdarzenie,
na przykład już jesteśmy po tym,
gdy zaczyna się niby to suszenie,
ale otwieramy drzwi od tej pralki,
przechodzi ona do stanu czekaj, tak?
Wyjmujemy na przykład wełniany sweterek,
który nie chcemy,
żeby się sfilcował,
zamykamy drzwi
i nie chcemy, żeby cały proces prania ruszył od początku,
tylko, żeby to było dalej kontynuowane.
Więc włączamy mechanizm historii.
Jasne?
Widzicie Państwo przydatność takiego mechanizmu historii w życiu?
No właśnie i tutaj jest to po prostu pokazane,
jak to wygląda zmiana tych stanów, prawda?
Yhm.
Jak gdyby, żeby bez mechanizmu historii
zawsze będzie zaczynało od początku,
natomiast z włączonym mechanizmem historii
pamięta stan, w którym ostatnio był
i zamknięcie drzwi, prawda, jest kontynuacja tego, tego procesu.
Dobra, czy to jest jasne?
Jak to działa ten mechanizm historii?
Yhm.
No teraz ta historia może być wielopoziomowa,
no bo te stany też mogą być, prawda, stanami abstrakcyjnymi,
yhm, więc yhm, może być wielopoziomowa, no bo te stany też mogą być, prawda, stanami abstrakcyjnymi,
więc yhm, może być wielopoziomowa, no bo te stany też mogą być, prawda, stanami abstrakcyjnymi,
więc yhm, może być wielopoziomowa.
Dobra, czy do tego mechanizmu historii
coś, jakieś pytania, jeszcze ktoś ma wątpliwości?
Dobra, to uwaga, uwaga, proszę Państwa, budzimy się,
zrobimy teraz zadanie, które też się regularnie pojawia na egzaminach,
no jakieś tam zmieniam dane czy rysunek, ale
typ zadania pojawia się.
Regularnie zawsze, przynajmniej raz w sesji egzaminacyjnej, takie zadanie się pojawia.
No i popatrzmy teraz, jak to zadanie, to jest też wzięte z jakiegoś egzaminu, jak ono wygląda.
Otóż,
yhm, treść jest następująca.
Podano diagram zmian stanów dla pewnej klasy.
Podaj, jakie czynności będą kolejno wykonane przez obiekt tej klasy
dla następującej sekwencji zdarzeń. I tu mam,
wymienioną sekwencję zdarzeń, utworzenie obiektu, tu mam jakieś zdarzenia wymienione.
No i teraz ten nasz, ten nasz, ten nasz, prawda, diagram maszyny stanowej.
Tutaj, dla uproszczenia, ja mam tylko dwa stany.
Za to dużo się dzieje w tych stanach.
Przypomnę Państwu, że mamy takie zdarzenia predefiniowane, jak zdarzenia entry, exit i do, tak?
I widzimy, one są tutaj w tych stanach użyte i mamy tutaj jakąś czynność, którą obiekt ma wykonać wtedy,
kiedy to zdarzenie ma miejsce. Entry, czyli wtedy, kiedy wchodzę do tego stanu.
Exit, wtedy, kiedy wychodzimy z tego stanu.
Do, wtedy, kiedy jesteśmy w tym stanie.
Tu jest też jakieś zdarzenie, które może mieć miejsce.
Zdarzenie E2, wychodzimy, ale wracamy do tego stanu.
Za chwilę zobaczymy, jaka jest różnica pomiędzy takim zdarzeniem, właśnie takim wyjście.
Tu jest wejście i wejście, a tu jest tylko wewnątrz tego stanu.
I zdarzenie E1, które powoduje zmianę na stan E2.
Dobra, i teraz, momencik jeszcze, jakie tutaj były te stany.
Dzisiaj mam tylko jeden ekran, znaczy nie mam ekranu dodatkowego,
więc mi jest troszkę trudno.
Mogę mi tutaj ten wykład prowadzić, ale mam nadzieję, że jakoś sobie poradzimy.
Dobrze, zdarzenia były takie.
Utworzenie obiektu.
No to, to wracam tutaj.
Utworzenie obiektu.
Jak obiekt jest tworzony, to rozpoczyna w stanie, który tu jest oznaczony jako stan początkowy.
Czyli rozpoczyna w stanie,
tu jest nazwa tego stanu, tak, stan 1.
Bo było utworzenie obiektu.
No i teraz, co będziemy tutaj wypisywać, co on robi.
Co się dzieje, prawda, jakie czynności on wykonuje.
Jeżeli wchodzimy do tego stanu, to proszę popatrzeć, co ma być zrobione.
Ma być zrobiona akcja pierwsza.
Ja, żeby myszką się niedobrze piszę, więc ja będę to skracać tylko do jednej literki A.
Czyli robi obiekt akcję A1, akcję pierwszą.
I jest wewnątrz tego stanu.
Jak jest wewnątrz tego stanu, to następnie robi cały czas, będąc w tym stanie, to, co jest tutaj określone za pomocą słowa kluczowego DO.
Czyli robi akcję trzecią.
Dobrze, i to było utworzenie obiektu, tak, jako pierwsze zdarzenie.
Teraz robi tą akcję, która określona była, wykonuje to, co było określone przy słowie kluczowym DO.
Teraz ma miejsce zdarzenie E1.
No to popatrzmy, co to zdarzenie E1 powoduje.
Ono jest tutaj.
Na tym przejściu ze stanu pierwszego do stanu drugiego.
Ale, widzimy, wychodzi z tego stanu pierwszego.
A jak wychodzi z tego stanu pierwszego, to musi zrobić akcję drugą.
Czyli wykonuje akcję drugą.
Tak, tu mi się trochę przeciągnęło.
Teraz.
Jesteśmy na tym przejściu.
Na tym przejściu robi to, co tutaj jest określone jako akcja cztery.
Tak, robi to akcja cztery.
I wchodzi do stanu drugiego.
A tutaj przy entry ma akcję siódmą.
Więc robi akcję siódmą.
Tak.
Jak ją zrobi, takie akcje są zwykle, taki czas wykonania pomijalnie mały.
To przechodzi do wykonywania, zawsze jak jest w tym stanie, czegoś, co się nazywa akcja dziewięć.
Tak, więc ja tutaj napiszę A z dziewiątką.
Ale stan osiągnięty jest teraz stan drugi.
Czyli tutaj teraz stan drugi jest stanem osiągniętym po tej sekwencji czynności.
I robi w tym stanie tą akcję dziewiątą.
Teraz ma miejsce zdarzenie E3.
W zdarzeniu E3 widzimy, że nie zmienia stanu.
Czyli tutaj moglibyśmy zdarzenia jeszcze wpisywać.
Prawda?
To było do tego zdarzenia E1.
A teraz ma miejsce zdarzenie E3.
Stan pozostaje ten sam.
Widzimy, że nie zmienia stanu.
Więc ja tutaj sobie zaznaczę, że jesteśmy dalej w stanie drugim.
Ale zdarzenie E3 wiąże się z wykonaniem akcji dziesiątej.
Czyli wykonuje akcję dziesiątą.
Tak.
I jak ją skończy, to wraca do wykonywania akcji dziewiątej.
Czyli mamy tutaj akcję dziewiątą.
Dobra.
Następnym zdarzeniem, które ma miejsce, jest zdarzenie E2.
Jesteśmy w stanie drugim.
Co możecie Państwo powiedzieć, jak tutaj teraz jesteśmy w tym stanie drugim
i występuje zdarzenie E2?
Czy to jest zdarzenie oczekiwane w tym stanie?
Przewidzieliśmy, że takie zdarzenie może w tym stanie wystąpić?
No, jest gdzieś tutaj w tym stanie drugim?
Na wyjściach ze stanu, wewnątrz tego stanu?
Nie ma.
Nie ma, prawda? Nie oczekiwaliśmy.
Więc jesteśmy w dalszym ciągu.
Tutaj mamy teraz to zdarzenie E2.
Nie zmieniamy stanu.
Było to zdarzenie nieoczekiwane.
Ale gdyby nic nam to nie przeszkadza, tak może być.
Cały czas robimy, będąc w tym stanie, akcję dziewiątą.
Czyli robiona jest ta akcja dziewiąta.
Zmiana stanu nie następuje.
Teraz ma miejsce zdarzenie E2.
Teraz ma miejsce zdarzenie E1.
Kolejne zdarzenie to będzie zdarzenie E1.
Widzimy, że to zdarzenie E1 jest na wyjściu z tego stanu.
Czyli do jakiego stanu dojdziemy?
Dojdziemy do stanu pierwszego.
Tutaj będzie stan pierwszy jako rezultat tego zdarzenia E1.
Ale zanim do tego stanu wejdziemy, to co?
Musimy zrobić akcję ósmą, którą tu jest na wyjściu ze stanu.
Czyli tu będzie akcja ósma związana z exit.
Teraz na tym przejściu musimy wykonać akcję czwartą.
Wchodzimy do stanu.
Jak wchodzimy do stanu pierwszego, to musimy zrobić akcję entry, czyli akcję pierwszą.
I będąc w tym stanie, robimy to, co jest na wyjściu ze stanu.
Robimy to, co jest tutaj określone kluczem do, czyli robimy akcję trzecią.
Dobra, czy to jest jasne?
To, co Państwu tutaj namazałam myszką, więc to jest mało czytelne.
A za chwilę pokażę Państwu na kolejnym slajdzie.
Mamy to rozwiązanie już w takiej formie ładniejszej pokazane.
Czyli właśnie.
I tak możecie Państwo być proszeni o wypełnienie.
Takiej tabelki w trakcie egzaminu.
To jest jedna z możliwości.
Albo może być tak, że jakaś sytuacja będzie pokazana.
I będziecie Państwo musieli wybrać jedną właściwą odpowiedź z kilku, które będą udostępnione.
I właśnie tutaj pokazuję, co jest wykonywane.
I co było przyczyną tej czynności.
Czyli.
Akcja pierwsza, bo jest związana z entry.
Akcja trzecia jest związana z do.
Najpierw jak wychodzimy ze stanu, to robimy to, co jest związane z exit.
Potem to coś jest na przejściu.
Potem to coś, co jest na wejściu.
I będąc w stanie, zawsze obiekt robi to, co jest związane z do.
Jeżeli pojawia się zdarzenie, które jest nieoczekiwane.
No to jak gdyby nic się nie dzieje.
Obiekt dalej robi swoje.
Jest zdarzeniem nieoczekiwanym, ale nie przeszkadza to w działaniu obiektu.
Czy do tego może ktoś z Państwa ma pytania?
To jest, jak Państwo widzicie, początek tego rozwiązania.
A tutaj zrobiliśmy do końca, dalej w trakcie.
Czy ktoś z Państwa ma do tego jakieś pytania?
Coś trzeba powtórzyć, wyjaśnić inaczej.
To proszę Państwa jeszcze taką rzecz.
Otóż czasem takie zadanie.
To ja teraz chyba bohomazy tutaj powycieram.
Czasem takie zadanie.
Pojawiają się jeszcze tutaj dodatkowe wymagania.
Bo czasem jeszcze tutaj może się pojawić.
Tekst.
A co możesz powiedzieć o własnościach tej klasy,
dla której mamy taki diagram maszyny stanowej pokazany.
Czyli gdybyśmy właśnie, no mamy ten diagram maszyny stanowej
i teraz mamy odpowiedzieć na pytanie,
a co możesz powiedzieć o tej klasie,
dla której ten diagram jest narysowany.
Co możecie Państwo powiedzieć?
Ja tutaj Państwu mówię,
obiekt wykonuje akcję pierwszą, czy drugą, czy trzecią.
A jak obiekt wykonuje jakąś akcję,
to co to musi być?
To ta akcja co musi być?
Czym musi być?
To musi być operacja tej klasy.
Czyli to wszystko co tutaj Państwo macie, prawda,
akcja pierwsza, druga i tak dalej,
to wszystko są operacje tej klasy.
Czyli jak mamy tą klasę,
o której no nie wiemy jak ona się nazywa, tak,
o atrybutach nic nie możemy powiedzieć,
ale tutaj możemy powiedzieć bardzo dużo o tych akcjach,
o operacjach, prawda.
Wszystkie te, to co obiekt robi,
to jest to jego operacja,
czyli to muszą być operacje tej klasy.
No dobra, ale tutaj było powiedziane,
no obiekt to robi, tak, sam to robi.
To co, jak Państwo myślicie,
jaki będzie zakres widoczności tych operacji,
akcja jeden, dwa, trzy i tak dalej.
To nie jest z zewnątrz wywoływane,
czyli te operacje mogą być operacjami,
prywatnymi, tak, czyli mogą być to,
wystarczy, żeby to były operacje prywatne tego obiektu.
Może niektóre z nich będą również potrzebne
w innych sytuacjach i mogą być określone jako publiczne,
ale na podstawie tego diagramu,
który tutaj widzimy,
diagramu maszyn stanowych,
możemy powiedzieć te wszystkie czynności,
które obiekt ma wykonywać,
to są to operacje tej klasy o nieznanej nazwie, tak,
nie podana była nazwa tej klasy
i muszą być to operacje
i wystarczy, żeby to były operacje prywatne,
no bo obiekt jak gdyby sam je robi na myśl.
Czy do tego mają Państwo jakieś pytania, uwagi?
Wątpliwości? Wszystko jasne?
Rozumiem, że wszyscy potraficie Państwo
takie rozwiązanie za takiego zadania zrobić, prawda?
Tutaj początek jest pokazany.
No nie ukrywam, że ten rysunek często się pojawia,
zmienia się sekwencja czynności
i oczekuje rozwiązań.
Dobra, teraz popatrzmy proszę Państwa na kolejne zadanie.
Na kolejne zadanie.
Mamy tutaj taki przykład maszyny stanowej
z agregacją stanów.
To też może być na egzaminie, tak?
Też może być na egzaminie.
Też może być na egzaminie, tak.
I mamy tutaj jakiś stan S,
który widzimy składa się z dwóch części,
z T i z U.
I ten stan T jest tutaj zamodelowany
taką maszyną stanową ze stanami Z, X, Y.
Stan U też ma trzy stany,
inna maszyna stanowa.
I popatrzmy, są tutaj jakieś zdarzenia
na tych przejściach E1, E2, E3, tak?
Więc widzimy, że tutaj niektóre z nich
są na przejściach podane.
Proszę popatrzeć, tutaj są takie nawiasy kwadratowe.
Przypomnę Państwu, że nawiasy kwadratowe
to jest to warunek, tak?
Czyli tutaj mam zdarzenie E2
na tym przejściu ze stanu Y do X,
ale to przejście się wykona wtedy,
tu mam in B.
No więc co to znaczy in B?
To znaczy, że to przejście ze stanu Y do stanu Z
będzie miało miejsce wtedy,
kiedy tutaj on będzie w stanie Y,
ale w tej drugiej części maszyny stanowej
będzie w stanie B.
Czyli widzicie Państwo,
że właśnie za pomocą takich warunków,
a tutaj mamy znowu, że zdarzenie E4
zmienia stan B na stan A wtedy,
kiedy w tym drugim komponencie
on jest w stanie Z, tak?
A tutaj X.
Czyli widzimy, że za pomocą takich warunków
można no tutaj pewne przejścia uzależniać
w jednej maszynie od drugiej maszyny.
No i teraz proszę Państwa,
wyobraźmy sobie,
że nasze zadanie polega teraz na tym,
żeby zrobić,
ja tutaj Państwu dzisiaj pokazywałam taki,
o był jak gdyby podobny przykład,
tylko nie było zależności,
zrobić taki diagram maszyny stanowej płaski,
bez agregacji stanów, prawda?
Czyli N stanów,
na M stanów.
No i teraz chcę, żebyśmy to zrobili
dla tego troszkę trudniejszego przypadku.
Czyli jeżeli tutaj mam N stanów,
tutaj mam M stanów,
no to diagram taki płaski tej maszyny stanowej
to będzie N razy M stanów, tak?
Być może nie wszystkie one będą osiągalne,
ale no musimy je rozważyć.
Czyli 3 razy 3 to jest 9.
No i teraz mamy tutaj jak gdyby
dwa możliwe do rozwiązania,
jak w jaki sposób podchodzimy.
No jedna z możliwości to jest takie,
że rysują Państwo te 9 tych stanów,
czyli Z z A, Z z B, Z z C,
X z A, X z B, X z C
i to samo z Y, Y z A, Y z B, Y z C.
Także macie 9 stanów
i teraz patrzycie jakie te przejścia mogą wystąpić.
No i to chyba jest,
chyba jest takie pewniejsze rozwiązanie.
Druga możliwość to jest taka,
że jak gdyby na bieżąco te stany wyznaczacie,
czyli, że zaczynamy od stanu Z A,
czy A Z, jak to, tak?
To jest nasz stan początkowy,
dlatego, że to jest stan początkowy
z obu tych maszyn stanowych,
więc tu mu narysujemy kropeczkę,
jako stan początkowy
i teraz rozważamy tutaj,
jakie będą możliwe przejścia,
czyli popatrzmy.
Stan Z, oczekiwane jest przejście E3,
przenosi nas do stanu X.
Czy w stanie A zdarzenie E3 jest oczekiwane?
Nie, czyli ten stan się nie zmieni,
czyli jeżeli tutaj wystąpi zdarzenie E3,
to Z zmieni się na X,
ale A zostanie tak, jak był.
Dobra, a teraz popatrzmy,
tutaj mam przejście E1 w stanie A,
zmieni stan A na B, tak?
Ale zdarzenie E1 w stanie Z jest nieoczekiwane,
wobec tego to zdarzenie E1
nie zmieni stanu Z,
ale zmieni stan A na stan B,
A na stan B.
No i mamy, i teraz znowu,
dla każdego z tych stanów rozważamy,
jakie są możliwe przejście.
Czy to jest jasne?
Na jakiej zasadzie przechodzi pomiędzy tymi,
tymi, nie pamiętam, jak to się nazywa,
tymi prostokątami, tak?
Stany, stany, mówimy o stanach cały czas,
czyli te prostokąty tutaj,
z zaokrąglonymi krawędziami,
to jest symbol graficzny stanu
i to są nazwy stanów,
Z, Y, Z, jakieś takie abstrakcyjne.
A ten większy prostokąt,
który przechodzi na ten inny większy prostokąt,
no to na jakiej zasadzie to przechodzi wtedy?
To jest, proszę Państwa, zrobiliśmy taki model, tak?
Że dla nas stan S jest stanem złożonym,
który agreguje dwa stany takie złożone,
jeden się nazywa T, drugi się nazywa U.
I ten diagram tutaj z tymi stanami Z, X, Y,
to jest model zachowania tego stanu T.
Ten stan T nie jest stanem rzeczywistym,
tylko jest takim stanem abstrakcyjnym,
który właśnie jak gdyby grupuje tą maszynę stanową, tak?
I tutaj mamy ten stan U,
taki też abstrakcyjny, zamodelowany
w postaci maszyny stanowej,
z tymi stanami A, B i C.
I czasem możemy pracować na takim modelu.
Ale mówiłam Państwu,
że można ten model równoważny zrobić
w postaci takiego diagramu płaskiego,
gdzie będziemy po prostu te stany,
no jak gdyby łączyć nazwy tych stanów,
czyli Z z A, Z z B, Z z C.
Stąd nam wychodzi dziewięć takich stanów.
I będziemy rozważać teraz,
bo chodzi mi teraz o to,
abyśmy zbudowali dla tego diagramu
ze strukturalizacją, z kompozycją,
z generalizacją stanów,
żebyśmy zbudowali równoważny model,
no w cudzysłowie płaski,
czyli taki bez używania tych struktur,
bez używania generalizacji,
bez używania agregacji stanów.
Czyli chodzi mi o konwersję takiego modelu,
złożonego na taki model podstawowy płaski.
Teraz to jest jasne?
Tak mniej więcej.
Tak mniej więcej, dobra.
No dobra.
To teraz, czy chcecie Państwo spróbować sami to,
czy od razu pokazywać rozwiązanie, jakie jest?
Może pokażę rozwiązanie.
Proszę popatrzeć.
Ja tutaj podeszłam do tego rozwiązania,
no właśnie w taki sposób, jak Państwu sugerowałam.
Ja nawet nie wiem, czy tu nie ma błędu przypadkiem,
bo to mogło się zdarzyć, prawda?
Czyli jeszcze raz wracam tu do tego.
Może tutaj powycieram te bohomazy.
I chcę mieć dla takiego modelu ze strukturalizacją,
chcę mieć model płaski, równoważny.
Tutaj robiąc ten model płaski, równoważny,
chcę Państwu pokazać też, jak rośnie złożoność takiego modelu.
I chcę Państwa jak gdyby zachęcić do tego,
że jeżeli macie budować model zachowania czegoś, tak?
To czy jakiś złożony model zachowania klasy w projekcie,
czy nie wiem, modelujecie zachowanie jakiegoś urządzenia,
czy protokołu, czy czegoś tam,
to warto stosować te metody właśnie strukturalizacji stanów,
bo wtedy ten model jest po prostu prostszy,
łatwiejszy do zrozumienia.
Ale chcę Państwa również przekonać,
że jest możliwość transformacji takich modeli
i no można tą transformację,
my tu będziemy robić ręcznie,
ale można sobie wyobrazić, że jest to program,
który nam tą transformację zrobi.
Czyli chcę mieć dla takiego modelu ze strukturalizacją,
chcę mieć, zbudować model równoważny, model płaski.
Więc najpierw narysowałam sobie dziewięć stanów,
jakie są możliwe, tak?
Czyli tak jak Państwu mówiłam,
stan A powiązany z tymi stanami, prawda?
Tutaj A z każdym z tych stanów z maszyny górnej,
B z każdym z tych stanów i C z każdym z tych stanów.
Mam dziewięć stanów.
Zaczynam od stworzenia dziewięciu takich stanów.
Państwu pokazałam, że stan AZ jest stanem początkowym,
dlatego że proszę popatrzeć,
tutaj Z jest zaznaczony jako stan początkowy,
i tutaj A jest zaznaczony jako stan początkowy.
Wobec tego zaznaczam stan AZ jako stan początkowy.
No i pokazuję teraz, zastanawiam się, jakie są możliwe przejścia, prawda?
W stanie Z możliwe jest przejście pod wpływem E3,
a w stanie A to E3 nie ma żadnego znaczenia,
nie jest oczekiwane, więc stan A się nie zmieni.
Wobec tego widzicie Państwo, że zdarzenie E3 zmienia mi Z na X, tak?
Ale stan A pozostaje tak, jak był.
Zdarzenie E1 to jest z kolei, proszę popatrzeć,
zdarzenie oczekiwane w stanie A.
I ono stan A zmienia na B, natomiast nie jest oczekiwane w stanie Z.
Wobec tego nam Z zostało tak, jak było,
a B zostało zmienione, A zostało zmienione na B.
I mamy teraz dwa nowe stany, ten i ten, tak?
Ten zaznaczę, rozważyliśmy już tutaj,
wszystkie przejścia możliwe dla tego stanu.
No i teraz rozważam na przykład przejścia ze stanu BZ.
No to znowu wracam tutaj i teraz patrzę BZ, tak?
W stanie B oczekiwane jest przejście pod wpływem zdarzenia E2.
W stanie Z zdarzenie E2 jest nieoczekiwane,
czyli stan Z się nie zmieni, a B zmieni się pod wpływem zdarzenia E2 na C.
No to widzimy, że zdarzenie E2,
stan B zmieniło na C, Z nie uległo zmianie.
Teraz wracam jeszcze tutaj do tego
i teraz stan Z,
przepraszam, bo już się zgubiłem, moment,
czyli stan B, tutaj zaznaczę kropkę, już rozpatrzyłam,
teraz patrzę na stan Z, jakie on ma tutaj możliwości przejść.
Więc wracam tutaj, tak?
I stan Z, tak?
Widzimy, że zmienia mi Z zdarzenie E3 na X.
Zmienia, a w stanie B to zdarzenie E3 nie jest oczekiwane,
więc widzimy, że ono, stan B się nie zmienia,
a to zdarzenie E3 zmieniło mi, tak?
Z na X.
Natomiast tu jeszcze wrócę do tego stanu B, który był,
jest teraz, jeszcze tutaj rozważam jego przejścia,
proszę popatrzeć, prawda?
Ja tutaj rozważyłam to przejście E2,
ale tutaj, proszę popatrzeć, jeszcze jest takie przejście
pod wpływem zdarzenia E4,
które jest uwarunkowane in Z,
czyli wtedy, kiedy stan B jest sparowany ze stanem Z,
tak?
To to przejście pod wpływem E4 się wykona.
I co ono powoduje?
Powoduje zmianę stanu B na stan A.
No więc popatrzmy.
Rzeczywiście tutaj widzicie Państwo to zdarzenie E4.
Teraz ono już nie jest uwarunkowane niczym,
bo widzimy, że stan B jest w parze ze stanem Z,
więc wykona się to przejście do stanu AZ.
No i teraz już mogę ten stan zaznaczyć,
że...
Jeszcze tutaj mam przejście E2, tak?
Stan B na stan...
Tutaj jeszcze muszę to przejście E2 rozważyć, prawda?
Że stan B zmieni mi na C, tak?
A w stanie Z zdarzenie E2 nie jest w żaden sposób oczekiwane,
więc stan Z się nie zmieni,
natomiast B zmieniło się na C.
Teraz już mogę powiedzieć,
OK, wszystkie zdarzenia oczekiwane w stanie B rozważyłam,
wszystkie zdarzenia oczekiwane w stanie Z rozważyłam, tak?
Pojawił mi się nowy stan,
znowu opracowuję przejścia z tego stanu.
Czy to jest jasne to, co teraz Państwu wyjaśniłam?
Czy może, nie wiem, chcecie, żeby któryś konkretny,
któryś konkretny jeszcze z któregoś stanu przejścia
jeszcze Państwu tutaj wytłumaczyć, jak to działa?
Proszę popatrzeć tutaj, akurat tak się zdarzyło,
że ten stan AY, jak widać, on jest w ogóle nieosiągalny, prawda?
To się wszystko...
Mamy tutaj te przejścia zaczynają się od stanu AZ,
natomiast do tego stanu nie ma żadnego wejścia, prawda?
A tu z kolei się pojawiło coś takiego,
że ten stan CY jest taką czarną dziurą,
jak do niego wejdziemy, bo tu nie ma z niego żadnych przejść, tak?
Może rozważmy ten stan C i Y,
popatrzmy, czy faktycznie nie ma z niego żadnych przejść.
W stanie C przejście jest pod wpływem zdarzenia E2,
ale wtedy, kiedy on C jest z X, a nie z Y,
czyli to się nie wykona.
W stanie Y mamy przejście pod wpływem zdarzenia E2,
ale wtedy, kiedy Y jest łącznie ze stanem B,
a tu jest ze stanem C,
czyli również to przejście się nie wykona.
Czyli widzicie Państwo,
faktycznie tutaj z tego stanu nie ma żadnego przejścia do innego stanu.
Czy coś jeszcze może Państwo wytłumaczyć,
któreś z tych przejść?
O jasne, jak to się odbywa, zmiana stanu?
No i teraz proszę popatrzeć,
tutaj mamy taką siatkę dziewięciu stanów z różnymi przejściami.
Trudno jest to działanie, zachowanie tego sobie wyobrazić.
Łatwiej nam jest wyobrazić sobie właśnie taki model strukturalizowany,
że widzę, że pewien stan jest kompozycją takich dwóch stanów abstrakcyjnych.
Robię prosty model jednego stanu, robię prosty model drugiego stanu,
i jak gdyby łatwiej mi jest tutaj pewne rzeczy sobie wyobrazić.
A widzicie Państwo, że za pomocą właśnie takich zależności
można pewne przejścia z jednej maszyny stanowej i drugiej maszyny stanowej
można ze sobą wiązać.
Tak jak tutaj widzimy, prawda,
że te przejścia niektóre są przejściami warunkowymi.
Uzależnione są od tego, aby stan był jak gdyby tutaj w tej maszynie,
na przykład B,
a w tej maszynie powinno być to w stanie Z,
albo tu powinno być w stanie X.
Czy jeszcze może mają Państwo jakieś pytania do tego?
A czy można Pani jakieś przykładowe zadania do tego wysłać?
Mogę.
Teraz ja sobie to zapiszę, żeby to zrobić.
Proszę Państwa, ja po prostu pozmieniam.
Tutaj pozmieniam, korzystając,
domyślacie się Państwo, nie jest łatwo taki rysunek zrobić,
skoro już go mam,
więc coś pozmieniam na tym rysunku.
Na przykład zrobię inne zależności,
żebyście Państwo mogli.
Zadanie z płaskim modelem.
Dobra, i takie zadanie postaram się przygotować
i też umieścić i rozwiążemy je wspólnie,
czy pokażę rozwiązanie na przyszłych zajęciach.
Dobra, jeszcze jakieś życzenia z Państwa strony?
Z tego pierwszego zadania, które na pewno będzie,
to też może Pani takie przykładowe też jakieś inne...
Z tego?
Tak.
Ok.
Dobrze, czyli jeszcze zadanie z sekwencją czynności.
Dobrze.
Dobra, jeszcze jakieś życzenia?
Dobra, to proszę Państwa kończę to.
Absolutnie nie zachowujemy tych bohomazów.
Dobrze, zamknę ten plik.
No i jeszcze chwileczkę.
Jeszcze chwileczkę mamy.
To jest momencik.
To teraz jeszcze chcę Państwu pokazać,
no zbliżamy się pomalutku już do końca UML-a,
ale chcę Państwu jeszcze pokazać tzw.
Activity Diagram.
To są, proszę Państwa, takie bardzo fajne diagramy,
które stosuje się do różnych celów,
niekoniecznie przy projektowaniu oprogramowania.
Mogą, zobaczycie Państwo, one są takie uniwersalne,
że można jak gdyby przebieg pewnych procesów na nich pokazywać,
nie wiem, jakieś czynności w firmie, które się dzieją.
To są też diagramy, które pokazują co się dzieje,
pewną dynamikę.
I właśnie, często są używane przy modelowaniu
różnego rodzaju procesów biznesowych, które się dzieją w firmie.
Można je używać również do przygotowania
takiego scenariusza przebiegu przypadków użycia.
Ja Państwu mówiłam na poprzednich zajęciach,
że właśnie dla diagramu Use Case pokazujemy za pomocą
diagramu sekwencji, jak ta funkcja jest realizowana.
A druga możliwość to jest taka, że ja to pokazuję za pomocą
właśnie tak zwanego Activity Diagram, diagramu czynności.
Można je stosować na różnych poziomach,
na takim wysokim poziomie abstrakcji,
czyli taki model, nie wiem, pewnych czynności,
które się w całym systemie dzieją.
Można pokazywać to na takim niskim poziomie,
czyli na przykład można w ten sposób pokazywać algorytm jakiś,
który jest wykonywany w tym systemie.
Na przykład można pokazać algorytm operacji,
jaki algorytm realizuje.
Także tutaj możliwość zastosowania tego jest bardzo,
bardzo różne tutaj mamy.
Na wysokich poziomach abstrakcji całego systemu,
czy na takim niskim poziomie abstrakcji,
jak przebieg wykonania pewnej operacji.
Co więcej, można na tych diagramach,
jak za chwilę Państwo zobaczycie,
modelować pewne wątki takich równoległych czynności,
które się odbywają i ewentualnie pokazywać
jakieś powiązania pomiędzy nimi.
No właśnie, mówiłam, że do operacji też.
Algorytmy, także bardzo różnorodne zastosowanie tych diagramów,
nie tylko przy modelowaniu, projektowaniu, oprogramowaniu,
ale naprawdę w różnych, różnych sytuacjach.
One są też bardzo łatwe do zrozumienia.
Mianowicie też mamy symbol graficzny czynności,
czyli tak zwanego activity.
Z czym się Państwu ten symbol graficzny kojarzy?
Mieliśmy taki symbol?
Mieliśmy, prawda?
Przed chwilą tego samego symbolu używałam,
żeby pokazać stan.
Symbol graficzny,
może być to ten sam,
który jest używany dla stanu.
W większości narzędzi tak to jest realizowane.
W niektórych narzędziach te activity diagram
tutaj są takie bardziej krągłe,
ale ten sam symbol graficzny może być używany.
Ta czynność, to activity,
może być jakąś prostą czynnością,
albo może być pokazana tutaj taka,
no właśnie taka czynność bardziej złożona,
bardziej abstrakcyjna
i do niej może być podłączony cały diagram activity,
który będzie ją projektował,
ją modelował i wtedy pokazujemy,
że to jest taka czynność złożona.
No i popatrzcie Państwo teraz
na taki prosty przykład activity diagram.
Widzimy, że też mamy tutaj oznaczenie początku,
czarna kropeczka początek.
Mamy dwie kropeczki, które oznaczają koniec
i mamy czynność, tak?
Tutaj czynność, czyli powinniśmy tutaj korzystać z czasowników.
W maszynie stanowej szukamy przymiotników
wolny, zajęty, dostępny, niedostępny.
Natomiast w activity to są czasowniki,
czyli wypełnij formularz, zarejestruj się, tak?
Uczęszczaj, zapisz się i tak dalej.
Proszę Państwa, tutaj też zwracam uwagę na taką rzecz,
która jest dostępna w activity diagram,
a której raczej nie powinniśmy,
chociaż narzędzie nam tego nie blokuje,
ale nie powinniśmy tego symbolu używać
na diagramach maszyn stanowych.
Mianowicie mamy tutaj rozejście,
a możliwość stosowania rozejść decyzyjny.
Na maszynach stanowych myśmy te rozejścia
za pomocą warunków realizowali,
tak jak pokazywałam Wam dzisiaj na przykład na tym przykładzie, prawda?
Że tam było w nawiasach kwadratowych napisane coś, prawda?
A tutaj możemy stosować rozejścia decyzyjne
i widzimy, że wypełniamy formularz.
Jeżeli warunek korekt jest spełniony,
to zapisujemy na ten uniwersytet.
Jeżeli nie, to mamy tu rozejście warunkowe,
czy potrzebna jest pomoc,
czy jest trywialny problem,
to nie przeszkadza nam to,
w innym przypadku wracamy tutaj.
Czyli możliwe są tutaj takie różne rozejścia decyzyjne.
I, proszę Państwa, właśnie coś,
co tutaj jest taką istotną nowością.
Mianowicie mamy tutaj tak zwany fork,
a tutaj mamy join, czyli fork.
Rozchodzimy się na ścieżki, na wątki,
które są wykonywane równolegle,
a tutaj mamy join,
czyli tu się synchronizujemy.
Taka gruba czarna linia nazywa się synchronization bar.
Tutaj mam fork.
Rozwidlenie.
A więc równolegle.
Attend university presentation,
uczęszczaj na jakieś tam prezentacje,
zapisz się na seminaria, zapłać i tak dalej.
I mogą być to czynności wykonywane równolegle.
Czyli natomiast tu się synchronizujemy,
oba te wątki i ten i ten muszą być skończone,
żeby można było przejść dalej.
Tutaj akurat mam punkt końcowy,
ale tutaj mogą być jakieś dalsze czynności,
które mogą być wykonywane.
Czyli mamy możliwość pokazania,
tutaj mam dwa takie wątki,
które mogą być wykonywane równolegle,
oczywiście może być ich dowolnie wiele.
Czy to jest jasne?
Fork, join, czyli synchronization bar,
linia synchronizacji,
którą tu się faktycznie synchronizujemy,
ale tu się możemy rozejść na wątki,
które będą wykonywane równolegle.
No właśnie, mówiłam Państwu o tych rozejściach decyzyjnych,
które są tutaj dopuszczane.
Tutaj przy okazji pokazuję Państwu symbol graficzny,
który w niektórych narzędziach odróżnia czynność od stanu,
chociaż we współczesnych właściwie jest to ten sam symbol graficzny,
ale w tych pierwszych wersjach UML-a
korzystało się z tego troszkę innego symbolu graficznego,
bardziej okrągłe te kąty są.
I tak jak Państwu mówiłam,
dopuszczamy w Activity Diagram,
w diagramach czynności dopuszczamy rozejścia warunków.
No też dobrze byłoby,
żeby one były dobrze określone, deterministyczne,
czyli tak jak Państwo widzicie,
jeżeli jest warunek za zimno spełniony,
to grzejemy, jeżeli nie za zimno,
to nam przechłodzimy albo...
O właśnie, prawda?
I tutaj mamy teraz rozejście na czynności,
które możemy robić równolegle,
czyli równolegle włączamy ogrzewanie,
i otwarcie okna mogą być te czynności wykonywane równolegle.
Tu mamy synchronizację, czyli mamy Join,
czyli ta czynność i ta czynność muszą się zakończyć,
żeby mogła się rozpocząć wykonanie czynności
tutaj tej po linii synchronizacji.
W tym prostym przypadku jest to pomiar temperatury.
Czy to jest jasne?
To rozejście warunkowe.
No i tutaj mówiłam,
proszę Państwa, że te diagramy,
Activity Diagram są często używane
do takich bardziej abstrakcyjnych modeli.
I tu mamy właściwie taki proces projektowania,
wykonywania pokazany właśnie za pomocą
takiego diagramu Activity.
Zaczynamy od burzy mózgów,
szkicujemy jakieś projekty,
tutaj następuje nawrót,
potem te szkice są jakoś tam organizowane,
specyfikowane.
Też widzimy, że też mogą być nawroty.
Tu mamy jakieś czynności wykonywane równolegle.
Jak się skończą,
to mamy pewien prototyp,
na którym pracujemy.
Znaleźliśmy braki,
być może wracamy do tych czynności wcześniejszych.
Jeżeli jesteśmy zadowoleni,
no to jak gdyby przechodzimy dalej.
Czyli chciałam Państwu tutaj po prostu pokazać,
że te diagramy,
Activity Diagram są bardzo takie uniwersalne
i można je stosować nie tylko przy projektowaniu systemów
do modelowania i do projektowania algorytmów,
do projektowania za wykonania pewnych use case'ów,
ale również na takim poziomie biznesowym,
bardziej abstrakcyjnym.
Proszę Państwa, teraz mam pytanie do Państwa,
czy robimy przerwę w tym momencie,
tak jak to nam zegar pokazuje,
czy przeciągnąć trochę ten wykład
i skończyć tą prezentację?
Co Państwo?
Można przerwę zrobić.
Dobra, róbmy przerwę, tak.
Ja też potrzebuję przerwy.
Czyli tutaj na razie zakończę.
Dobra, zatrzymam również nagrywanie.
Trzecia przerwa,
Pani Artur,
co się dzieje?
KÉS captive?
KÉS nowy?
---------------------------------------------Dobra, i ekran udostępniam i wracamy do diagramu czynności.
Więc już zachwalałam Państwu ten diagram jako taki diagram, który pozwala na modelowanie na różnych poziomach abstrakcji,
zarówno od takiego niskiego poziomu abstrakcji, algorytm np. przed jakąś operacją, jak i do modeli procesów, które się dzieją w samym systemie.
Mówiłam Państwu również, że można ten diagram...
Można ten diagram używać do modelowania, projektowania przebiegu np. use case'ów.
I szczególnie wtedy warto te czynności pokazać, która klasa, znaczy nawet trzeba wtedy tak to zrobić, która klasa jest odpowiedzialna za wykonanie tej czynności.
Czyli która klasa realizuje...
Daną czynność.
I tutaj mamy właśnie taki przykład, czyli wtedy korzystamy z tak zwanych partycji, inaczej to się nazywa swim lanes, również takie tory wodne.
Czyli jak gdyby do takiego toru, do takiej partycji, no wkładamy tutaj, która klasa będzie realizowała te czynności, które na tym torze wodnym są wykonywane.
Zobaczmy.
Przepraszam, ja muszę tutaj...
Nagle słońce zaświeciło.
I lokuje wtedy te czynności w tym torze wodnym w tej partycji.
Czyli tu pokazuje klasę wykładowca i za co ta klasa wykładowca jest odpowiedzialna.
Klasa student, jakie czynności wykonuje i tutaj mam trzecią partycję, współpracownicy wykładowcy.
A więc np.
Wykładowca realizuje czynność, jaką jest nauczanie.
Student realizuje czynność, jaką jest uczenie się.
Tutaj widzimy, że jakieś mam braki, momencik.
Chwileczkę jeszcze tylko, pokaz slajdów.
Dobra, czyli mam klasę student, prawda?
Która realizuje czynność uczenie się.
Tutaj brakuje mi strzałeczki.
Pisanie egzaminu.
Po stronie wykładowcy jest nadzorowanie egzaminów.
Mamy tutaj linię synchronizacji, synchronization bar.
I kolejna czynność, która jest wykonywana.
Czyli możemy lokować tutaj czynności, za które dana klasa jest odpowiedzialna.
Te partycje mogą być w takiej formie pionowej, tak jak Państwo na poprzednim.
Diagramie pokazywałam.
Można je również w taki poziomy sposób.
Tu mamy właśnie taki przykład.
Czyli mamy klasę customer.
Mamy klasę accounting department.
Mamy klasę order department.
I tutaj mamy pokazaną pewną sekwencję czynności.
Czyli tutaj jak gdyby przychodzi pewne receive order.
Dostaniemy jakieś żądanie.
Mamy tutaj jakieś rozejście.
Rozejście warunkowe, tak.
Albo ono jest odrzucone, albo jest zaakceptowane.
Tutaj mamy czynności równoległe.
Na przykład takie w klasie order department, jak wysłanie tego zamówienia.
W klasie accounting department wysłanie rachunku.
I klient, prawda, wykonuje płatność.
Tutaj jest akceptacja.
I zamykamy to dopiero wtedy, kiedy tu się nam synchronizuje.
Czyli zarówno wysłaną to zamówienie, jak i zaakceptowaną płatność.
Tu chcę zwrócić Państwa uwagę na taki prostokącik.
Co oznacza symbol graficzny prostokątu?
Ktoś pamięta?
Słucham?
Klasa?
Dobrze.
Brawo, brawo.
Tak, tak.
Oczywiście klasę.
W tym wypadku możemy się domyśleć, że tu raczej chodzi o obiekt.
Tutaj powinno być po dwukropku i podkreślenie.
Ale to może oznaczać po prostu tyle, że na przykład właśnie ta czynność send invoice
wiąże się na przykład z utworzeniem obiektu invoice.
Z utworzeniem obiektu, prawda, rachunek.
Także możemy też na tych diagramach, activity diagrams,
pokazywać obiekty, które w jakiś sposób albo są tworzone na skutek wykonania pewnej czynności,
albo na przykład następuje zmiana stanu tych obiektów.
Co więcej, na tych diagramach activity możemy pokazywać również wysyłanie
czy odbieranie pewnych sygnałów, pewnych komunikatów.
Tutaj mamy też taki diagram czynności.
Włącz klimatyzację, podaj pewien warunek.
To podaj warunek jest wysyłane do klasy termostat.
Tu powinien być dwukropek jeszcze.
I mam jakiś stan, tak.
I jak gdyby oczekujemy.
Taki pięciokąt oznacza, że oczekujemy, jak gdyby wchodzi pewien komunikat.
Oczekujemy na przysłonę.
Wysyłanie komunikatu, warunek spełniony.
I jak ten komunikat przyjdzie, to wykonywana jest kolejna czynność.
Wyłączenie klimatyzacji.
Czyli można pokazywać obiekty klas, tak.
Można pokazywać wysłanie sygnałów, odebranie pewnych sygnałów.
I popatrzmy na troszkę bardziej ambitny taki diagram czynności.
Początek, koniec.
Mamy tory wodne, mamy partycje.
Konsultant księgowy.
Jakiś tam dział taki odpowiedzialny za płatności.
I mamy czynność tutaj wypełnienie takiego formularza.
Widzimy, że tutaj to ma wpływ na expense form.
Czyli na obiekt klasy expense form.
I mam tutaj initial.
Co znaczy, że obiekt tej klasy expense form będzie w stanie initial.
Czyli pewnie zostanie utworzony.
Tutaj z kolei widzimy, że ten expense form może być w stanie error, prawda.
Że to validate, ta czynność validate expenses.
Jeżeli stwierdzi, że te wydatki są niewłaściwe.
No to może spowodować zmianę stanu tego obiektu expense form na stan error.
W przeciwnym przypadku, prawda.
Jeżeli to jest, zostało to zwalidowane, tak.
Jest zaakceptowane.
To jest jak gdyby włożenie tego do.
Do paska płatności, tak.
I to jak gdyby ma wpływ na obiekt klasy payroll file, tak.
I na wypłacenie pracownikowi tam no tych pieniędzy związanych z jakimiś wydatkami.
Który dodatkowo wykonał.
Czyli widzicie Państwo, że nie tylko można czynności pokazywać.
Że można, że te czynności warto umieszczać właśnie w takich partycjach.
I pokazywać.
Która klasa jest odpowiedzialna za wykonanie tych czynności.
Można również pokazywać, że te czynności wpływają na przykład na zmianę stanu obiektów.
Czy na utworzenie obiektu pewnej klasy.
Znowu, jeżeli mamy taki diagram czynności.
Mogłoby być pytanie.
A co możesz powiedzieć o klasach.
Które no w modelu.
W tym diagramie klas powinny być.
Patrząc na ten diagram czynności.
No, że są klasy.
Konsultant.
Accountant.
Payroll service.
Tak.
Dalej można powiedzieć coś, nie coś.
O operacjach, które te klasy mają wykonać.
A więc na przykład to, że klasa konsultant wykonuje taką czynność.
Fill out expense form, tak.
Że klasa accountant wykonuje czynność validate expenses, tak.
Wykonuje czynność enter expenses.
A więc no właśnie musimy pamiętać, że te czynności, które tutaj są w tej partycji związanej z określoną klasą.
To są po prostu operacje w tej klasie.
Czy może do tego mają Państwo jakieś pytania, uwagi.
Teraz czasem się pokazuje tutaj taką.
Tu niestety.
Ten symbol graficzny.
Symbol graficzny klepsydry niezbyt udanie wyszedł.
Ale można pokazywać, używać go do pokazania, że pewne czynności są wykonywane.
Na przykład tak jak tutaj widzimy w tej pętli co, co dwadzieścia minut.
Czyli taką klepsydrę z czasem.
No i popatrzmy tutaj jeszcze na właśnie taką klepsydrę.
Pokazaną, że to pierwszego kwietnia, prawda.
Będzie coś tam wykonane.
Jest pewien komunikat tutaj.
I coś, coś się tutaj dzieje.
Jakieś czynności są wykonywane.
Więc widzimy, że właśnie ta odbiór komunikatu, prawda.
Tutaj wysłanie komunikatu.
Oczekujemy na pewien komunikat.
Że można różnego rodzaju rzeczy pokazywać na tych diagramach czynności.
Wysłanie komunikatów.
Oczekiwanie na pewien komunikat.
Wpływ na obiekt jakiejś klasy.
Także bardzo.
Takie różne.
Takie różnorodne możliwości tutaj mamy.
Też mogą być rozejścia decyzyjne.
Też możemy pokazać, że jak gdyby pewien wątek się kończy.
Punkty końcowe.
Czy może być zakończenie pewnego wątku właśnie takim krzyżem zamodelowanym.
No dobra.
To by było na tyle jeśli chodzi o diagram czynności.
Teraz proszę Państwa chcę jeszcze Państwu pokazać.
Taką króciutką prezentację o pakietach.
Otóż proszę Państwa no te nasze projekty zwykle są bardzo duże.
Mamy no nawet parę tysięcy klas na przykład w projekcie.
I jakoś sobie trzeba z tą złożonością radzić.
I właśnie no radzimy sobie z tą złożonością w ten sposób, że prawda coś złożonego dzielimy na pewne części.
Do takiego właśnie podziału służą pakiety.
Czyli taki pakiet jest pewnego rodzaju pojemnikiem, w którym możemy wkładać różne rzeczy.
Czyli na przykład.
Powiedziałam Państwu, że czasem w projekcie.
Jest bardzo dużo tych klas.
Kilkaset czy nawet parę tysięcy.
Więc dzielimy je na pakiety.
I taki diagram klas robimy nie dla całego systemu.
Bo byśmy nie byli w stanie tego zrozumieć, ogarnąć, przygotować.
Tylko robimy dla właśnie pakietu.
Pakiet ma pewną nazwę.
I jak gdyby w danym pakiecie tworzymy na przykład diagram klas.
Pokazujący klasy z danego pakietu.
Ale można w ten sposób również inne rzeczy grupować.
Czyli to jest po prostu zgrupowanie pewnego zbioru elementów.
Tak jak Państwu mówiłam, zazwyczaj stosuje się to do tego, aby grupować klasy.
I jest to pewna część systemu.
To pozwala nam również na pewną dekompozycję tego systemu.
I oczywiście robiąc tą dekompozycję trzeba używać jakiegoś logicznego podziału na te klasy.
Czyli mieć pewien pomysł na to, w jaki sposób te klasy dzielić.
Na przykład klasy związane z dostępem do określonych danych.
Czy z określoną funkcją.
Natomiast potem pokazujemy pewne zależności pomiędzy tymi pakietami.
Można pokazywać.
I tutaj na przykład widzimy taki właśnie diagram pakietów, który pokazuje nam zależności.
Przypomnę Państwu, że linia przerywana to jest linia zależności.
Dependency line w WML-u.
Przypomnę Państwu, że takie nawiasy kątowe, które tutaj widzimy.
Access czy import.
To są tak zwane stereotypy w WML-u.
I mamy tutaj w tym naszym systemie mamy cztery pakiety o takich nazwach A, B, C, D.
I mamy pokazane tutaj, że pakiet C i zależność z pakietem A jest import.
To oznacza, że elementy, które tu zdefiniujemy.
Na przykład te klasy.
Są importowane do pakietu C.
Natomiast jeżeli używamy stereotypu access.
To jak gdyby one stają się prywatnym elementem tego pakietu C.
No i tutaj jak gdyby można całą strukturę takich importów czy accessów sobie utworzyć.
Można również te pakiety w sobie zagnieżdżać.
Tak jak tutaj na przykład widzimy.
Że mam w pakiecie E.
Mam pakiet C.
Który importuje pakiet A.
Zależy on od pakietu A.
Importuje go.
Natomiast one wszystkie znajdują się w pakiecie E.
Proszę popatrzeć co to jest za relacja.
Taka duży biały groc strzały.
To oznacza relację jaką?
Dziedziczenie.
Super. Dziedziczenie.
Czyli mam pakiet C.
I dziedziczą po nim pakiety B i D.
Też można właśnie takie dziedziczenie stosować pomiędzy pakietami.
Ja chyba mam tutaj jakiś przykład.
Być może za chwileczkę.
Jeszcze jedna z możliwości zależności pomiędzy pakietami.
To jest merge.
Jak się można domyśleć merge to jest łączenie.
Czyli pakiet C jak gdyby stala pakiety A i B w sobie.
Teraz na tych diagramach pakietów stosuje się również takie stereotypy, których tutaj kilka wymieniłam Państwu.
A więc takie jak system, jak podsystem.
Czyli można w ten sposób jak gdyby modelować pewną architekturę tego systemu.
Że system składa się z pakietów takich, które są podsystemami.
Można używać stereotypów ASAID.
To znaczy, że jest to jak gdyby opis fasada, opis interfejsu innego pakietu.
Taki STAP, czyli taka jak gdyby zaślepka, taki reprezentant innego pakietu.
Framework też można, a więc to takie wzorce sparametryzowane.
Można używać stereotypu model library, czyli właśnie taka biblioteka.
Zawieranie pakietów można również modelować za pomocą takiego plusika.
Czyli pakiet C zawiera pakiety A i B.
No i jak podchodzimy do tworzenia takiego diagramu pakietów?
Jakoś sobie musimy wymyśleć nazwy tych pakietów.
Zrobić pewną, wymyśleć pewną strukturę.
Właśnie system składa się, z czego się składa, z jakich frameworków, z jakich podsystemów.
Pokazać zagnieżdżenia, czy pokazać zależności właśnie takie jak
jak import, jak access, czy jak merch.
I tak dalej.
Dobra, i teraz jeszcze.
No i proszę Państwa, zbliżamy się do końca już tutaj UML-a.
Tam jeszcze tak zwane diagramy implementacyjne.
Diagram komponentów i diagram rozmieszczenia.
Tak zwany deployment diagram.
Często jest to po prostu jeden diagram, na którym mamy oba te elementy pokazane.
Diagram komponentów pokazuje no właśnie komponenty tego oprogramowania.
Takim komponentem często są pakiety lub pewien zbiór pakietów.
I właśnie zależności, które wskazują na to, że
które wskazują potrzebę zastosowania, czy dostosowania.
Te komponenty mogą być różnego rodzaju typów.
A więc może być to plik wykonywalny, może być to biblioteka,
może być to baza danych, może być to podsystem,
czy może być to coś, co dostarcza pewnych usług, prawda?
Czy takie komponenty przetwarzające.
Symbol graficzny komponentu.
To po prostu taki symbol prostokąta, tak jak to mamy w diagramie klas.
Wtedy dobrze byłoby użyć stereotypu, że jest to jednak komponent, a nie klasa, prawda?
I podać jego nazwę, na przykład tutaj zamówienia PHP są komponentem.
Można stosować taki symbol graficzny, który tutaj Państwo widzicie,
jaki prostokąt jest zwana małymi, to jest właśnie jak gdyby symbol komponentu.
Po to, żeby powiedzieć, że ta grafika DLL to nie jest klasa,
tylko to jest właśnie komponent i to komponent z rozszerzeniem DLL,
bo właśnie taki prostokąt z takimi dwoma tutaj prostokącikami,
tu mam client.db, tak, to jest komponent.
Czyli różnego rodzaju, w różnych narzędziach mamy różne symbole graficzne.
Najczęściej obecnie używany jest po prostu ten prostokąt dla pokazania, że jest to komponent.
Teraz, proszę Państwa, tak, komponent robi coś.
Wykonuje pewne czynności, które mu, czy pewne funkcje, które mu zostały przypisane
i na przykład udostępnia coś.
I to jest pokazane, jak można pokazać interfejs udostępniany przez komponent.
Tutaj u mnie ten komponent nazywa się szkolenie grafika DLL.
Jest to komponent i rejestracja w postaci kółeczka pokazujemy interfejs udostępniany.
Ale.
Żeby ten komponent wykonał swoje czynności, swoje funkcje,
to być może potrzebuje coś od innego komponentu.
I tutaj mamy taki komponent zamawianie, tak, który potrzebuje czegoś
i to coś, co on potrzebuje, nazywa się iClient.
I to jest tak zwany kominterfejs wymagany.
Zamawianie wymaga tego iClient, żeby mogło zrealizować swoje funkcje.
No to proszę popatrzeć, jak mamy taki udostępniany w postaci kółeczka
i wymagany w postaci półkółeczka, to można sobie wyobrazić,
że one nam się łatwo składają, prawda?
I to za chwileczkę pokażę.
Właśnie czasem się tak bezpośrednio daje łączyć te komponenty.
Teraz, ponieważ często komponent wymaga na przykład kilku interfejsów na wejściu,
może udostępnia kilka,
kilka swoich tych interfejsów.
Tutaj magazyn, tak, potrzebuje iClient, potrzebuje i dostawca,
udostępnia i księgowość.
Więc można te interfejsy wymagane, interfejs udostępniany,
można pokazać w postaci takiego portu.
Czyli tu widzimy, co ma wchodzić, tak, i co ma wychodzić z tego komponentu.
No i mówiłam Państwu, że możemy również pokazywać zależności pomiędzy komponentami.
No na przykład, żeby pokazać, że komponent korzysta z usług oferowanych przez inny komponent.
Jest to, zależności zawsze są linią przerywaną w WML-u zaznaczane,
w kierunku komponentu, który dostarcza tych usług jest to skierowane.
No właśnie, mówiłam Państwu, interfejs kółeczko to jest udostępniany,
pół kółeczka to jest wymagany.
Więc można te komponenty ze sobą łączyć w postaci takiego konektora składowego.
Teraz można również pewne rzeczy delegować,
na przykład te interfejsy wejściowe i wyjściowe, za chwileczkę to zobaczymy.
I można używać takiego symbolu, który się nazywa realizacja WML-u.
Widzimy, no przypomina to dziedziczenie, jeśli chodzi o grod strzałki,
tyle, że linia nie jest ciągła, a linia jest przerywana i to oznacza realizację.
Popatrzmy teraz na jakiś przykład takiego właśnie diagramu komponentów,
czyli mamy tutaj komponent, który się nazywa store, on udostępnia,
tu jest jego wyjście, udostępnia order entry, a wymaga account,
takiego interfejsu account.
W jego skład wchodzą komponenty order, customer i product,
też widzimy, że są to komponenty, widzimy, że tutaj one są składane,
customer udostępnia person i ten person jest wymagany przez order,
ale order wymaga również komponentu orderable item, tak,
który udostępnia komponent product i to order udostępnia,
udostępnia interfejs order entry i to order entry, proszę popatrzeć,
tutaj mamy delegate, tak, jest właśnie tym faktycznie na zewnątrz
udostępnianym interfejsem tego komponentu store.
Natomiast ten customer wymaga interfejsu account, tak, który, jak widzimy tutaj,
musi przejść z zewnątrz tego komponentu.
Z zewnątrz tego komponentu store.
Czyli mamy tutaj właśnie też, mamy tutaj ten stereotyp delegate, tak, delegowany.
Wymagany komponent jest delegowany do tego wymaganego komponentu
z tego poziomu zewnętrznego, a tutaj z kolei, jak gdyby ten udostępniany na zewnątrz
jest delegowany do tego interfejsu, który jest wewnątrz komponentu store.
I to jest właśnie taki, no, prosty, stosunkowo prosty przykład diagramu komponentów,
który, tak jak Państwo widzicie, no, pokazuje pewną strukturę tego systemu, który budujemy.
Popatrzmy, tutaj mamy troszkę bardziej złożony taki diagram komponentów,
na którym mogą się pojawić tutaj stereotypy framework, czyli tak, jak Państwu mówiłam,
można stosować tutaj relacje dziedziczenia. Widzimy, że może być to online ordering,
aplikacja lub shipping, tak, że one dziedziczą z tego ePash Strouds, tak.
Tutaj mamy komponenty customer order delivery, ich udostępniane interfejsy
i to, co one wymagają. Tutaj widzimy, skąd to się bierze.
Mamy jakiś komponent bazy danowej, uniwersytecka baza danych, tak.
Tutaj tym interfejsem jest, jak gdyby wymaga ten interfejs jest przez JDBC,
a więc w ten sposób, no, modelujemy pewną strukturę tych komponentów,
powiązania pomiędzy nimi, co który komponent udostępnia, jak to jest związane wszystko.
No i teraz, proszę Państwa, hura, ostatni diagram UML-owy, to jest tak zwany deployment diagram.
Te komponenty to są, no, nasze produkty, to są fragmenty tego naszego systemu.
I teraz jeszcze jest pytanie, a jak to ma być rozmieszczone?
I właśnie do tego celu służy diagram deployment diagram, gdzie pokazujemy,
jak to ma być zainstalowane na konkretnych elementach.
Korzysta się tutaj z takich węzłów, te węzły to może być urządzenie,
może być dysk, może być po prostu komputer.
Tutaj mamy taki prosty przykład deployment diagram połączony z diagramem komponentów,
bo właśnie najczęściej tak to się robi, że mamy pewne elementy sprzętowe,
jakieś urządzenia, tak, jakiś mamy web-serwer, mamy tutaj coś, co działa na systemie,
Solaris, tak, application server, mamy jakiś serwer bazodanowy działający na Linuxie,
mamy jakiś komputer mainframe'owy działający pod starym systemem MVS,
na którym jest stary system zarządzania kursami, tutaj legacy system,
czyli taki bardzo, bardzo stary.
Tutaj jest komunikacja poprzez szynę komunikatów, tak, i widzimy, że tutaj,
tutaj mamy komponent EJB container, który zawiera komponenty student,
seminarium, jakiś rozkład zajęć i jak gdyby kilka rzeczy.
Mamy fasadę tego kursu zarządzania, tak, w postaci takich web-serwisów,
więc widzimy, gdzie te komponenty mają być zainstalowane, prawda,
i w ten sposób modelujemy, gdzie co ma być, jakie fragmenty to ma być,
do czego oprogramowania mają być zainstalowane.
Natomiast te komponenty, taki komponent to często jest po prostu określony pakiet
lub może być to nawet kilka pakietów.
I tutaj jest w zasadzie ten sam model, który tutaj żeśmy widzieli,
tyle że tutaj korzystaliśmy z symboli graficznych pakietów,
które, no widzimy, troszkę nam tutaj ten obraz zaciemniają,
więc czasem się po prostu robi tak, że jak gdyby tylko ich nazwy się podaje, prawda,
nie używając tego symbolu komponentów.
Jeśli chodzi o bazę danych, to często używa się właśnie takiego symbolu graficznego
w postaci takiego jak gdyby dużego dysku, na którym ta baza danych jest zainstalowana.
No i tu jeszcze mają Państwo jeszcze jakiś przykład.
No i w ten sposób, proszę Państwa, doszliśmy do końca,
łemela i jeszcze tutaj jedną rzecz będę chciała Państwu chwileczkę pokazać.
Otóż, proszę Państwa, jeszcze chcę, króciutko już nie wchodząc w jakieś szczegóły,
ale zwrócić Państwa uwagę na tak zwane wzorce projektowe.
Otóż wzorce projektowe po raz pierwszy wprowadzono w architekturze
i tutaj Aleksander jest takim, jak gdyby uznawany jest niejako za twórcę tych wzorców projektowych
i po prostu co on zaproponował.
No, on stwierdził, że jak gdyby wiele rzeczy, no na przykład w architekturze,
często się pojawia w projekcie, tak, nie wiem, projekt drzwi, okien, tam czegoś,
że to się pojawia często w projekcie ileś razy,
więc można by przygotować takie wzorcowe rozwiązanie
i to rozwiązanie tylko parametryzować w zależności od, no, danej sytuacji.
Czyli właśnie taki wzorzec to jest pewien, opisuje pewien problem,
który ciągle pojawia się w naszej dziedzinie, określa się jego zasadniczą część rozwiązania,
tak, żeby można było to wielokrotnie stosować, być może z jakimiś zmianami,
właśnie parametrami, tak, żeby to dostosować do potrzeb.
I teraz, proszę Państwa, ten pomysł został włożony do inżynierii oprogramowania,
do budowy programów przez tak zwaną bandę czworga
w postaci Gamma, Helm, Jonsson i Flissides,
którzy w 1995 roku napisali właśnie taką książkę, na którą ja się tutaj powołuję,
Wzorce projektowe.
Elementy takiego software'u, który można ponownie użyć.
I po prostu stwierdzili, że podobnie jest przy tworzeniu programów.
Mamy często takie problemy, które można rozwiązać w podobny sposób,
więc można korzystać z tych gotowych rozwiązań.
Oni w tej swojej książce skatalogowali, zaproponowali 23 wzorce
i, proszę Państwa, w tej chwili tych wzorców jest już bardzo, bardzo dużo.
Tworząc, prawda, projekt, program, warto korzystać z tych,
korzystanie z tych wzorców znacznie przyspiesza pracę nad projektem,
dlatego że, proszę Państwa, z tymi wzorcami wiążą się gotowe fragmenty kodu,
które można po prostu włożyć do swojego oprogramowania,
zmieniając jakieś tam drobne elementy.
To jest również taki punkt odniesienia wspólny.
Ułatwia to pracę i komunikację w zespole.
I, tak jak mówiłam, tych wzorców jest w tej chwili bardzo, bardzo wiele.
One są jak gdyby różnej kategorii, czyli mogą być to wzorce strukturalne,
które służą do wiązania istniejących obiektów,
na przykład do obsługi interfejsów,
do powiązania abstrakcji i implementacji,
mogą być wzorce czynnościowe, wzorce kreacyjne,
czyli fabryki, metoda produkcyjna.
I właśnie, tak jak Państwu mówiłam,
to ułatwia bardzo pracę nad projektem,
bo jeżeli mamy grupę osób, która zna kilka tych wzorców,
tak?
Na przykład jeżeli powiemy w jakimś momencie,
że tutaj zastosujemy metodę produkcyjną,
czy fabrykę abstrakcyjną,
to wszyscy wiedzą, co to jest, prawda?
I taki gotowy wzorzec można wykorzystać w swoich projektach.
Teraz te wzorce oczywiście muszą być opisane.
Opis zwykle, no, zaczyna się, prawda, od jakiejś intencji.
Jest opis problemu, jest ogólny opis rozwiązania.
Często...
Często są związane właśnie z tym wzorcem diagram klas,
który pokazuje, jak to wygląda,
i szkielety kodu, które dotyczą tego wzorca.
I tutaj, no, na przykład właśnie mamy taki przykład takiego wzorca,
czyli mamy, powiedzmy, jakąś klasę abstrakcyjną figura,
która ma operację pole powierzchni,
może być jakieś obliczenie pomocnicze,
i tą figurą może być okrąg i prostokąt, tak?
I to, ta operacja obliczenie pomocnicze,
ona inaczej jest realizowana w klasie okrąg,
inaczej w klasie prostokąt.
Natomiast operacja pole powierzchni, prawda,
tutaj w tym oknie dialogowym będzie wykorzystana.
Także tutaj właśnie tak to mniej więcej wygląda.
Tutaj też taki typowy wzorzec.
Bardzo często stosowany, mianowicie metoda produkcyjna,
czyli mamy pewien produkt abstrakcyjny
i możemy mieć jakieś konkretne produkty.
Ten, mamy klasę abstrakcyjną takiej fabryki
i konkretną fabrykę, która tworzy już produkt określony,
konkretny określony produkt.
I tutaj chyba mam, o właśnie, taki przykład,
który pokazuje, że mamy jakieś dwie konkretne fabryki,
mamy jakieś produkty właśnie dwóch typów, tak?
I tutaj jedna fabryka produkuje produkty pierwsze,
druga produkuje produkty drugie, tak?
Być może takich produktów będzie też kilka.
A więc właśnie za pomocą takiej fabryki abstrak,
wzorzec, fabryka abstrakcyjna można to zrealizować.
Także tu właśnie mamy też jakiś przykład,
takiej fabryki abstrakcyjnej.
Często to stosuje się właśnie na przykład
czy do różnych środowisk,
w jakich ten, to oprogramowanie ma działać,
czy właśnie do tworzenia,
tu też klasa adapter, wzorzec jest takim
typowo stosowanym wzorcem projektowym
i również taki wzorzec,
zaraz gdzieś go mam tutaj,
wzorzec obserwator, prawda?
Czyli mamy tutaj pewne dane,
takie abstrakcyjne,
ale mamy pewne konkretne dane
i jak gdyby ten obserwator konkretny,
tak jak gdyby jak zmiana nastąpi w pewnych danych,
to to powinno być uwidocznione
i to jak gdyby na przykład do wyświetlania danych,
które mogą się ewentualnie zmienić,
jest często stosowane,
w zależności od tego, prawda?
Różne formy tego wyświetlenia mogą być realizowane.
Także to nie wchodzę tutaj w te szczegóły,
troszkę więcej tych kilka takich typowych wzorców
mają Państwo w tej prezentacji podane,
ale chcę tylko jak gdyby tutaj
zwrócić uwagę Państwa,
że jeżeli tworzymy oprogramowanie,
budujemy oprogramowanie,
warto korzystać z tych wzorców projektowych,
gotowy kod do realizujący taki wzorzec,
bo w różnych językach programowania
te wzorce są zrealizowane,
można sobie ściągnąć i jak gdyby użyć
i to znacznie przyspiesza realizację projektu
i również ułatwia taką komunikację, prawda?
Bo tak jak Państwu mówiłam,
że jeżeli powiemy,
a tu zastosujemy wzorzec obserwatora,
no to wszyscy wiedzą na czym to polega,
więc bardzo ułatwia to również komunikację
w zespole projektowym.
I to by było jeśli chodzi o UML-a.
Na tyle.
Natomiast teraz jeszcze chcę już przejść
do innej tematyki,
mianowicie do testowania pomalutku wchodzimy.
Dzisiaj zacznę od takich bardzo podstawowych rzeczy,
no po prostu do jak gdyby podejścia,
jak do tego testowania podejść.
Najpierw zacznę od tego,
że mamy takie dwa typowe,
dwie takie typowe strategie.
Albo tak zwany bottom up,
czyli testowanie wstępujące,
albo top down, czyli testowanie wstępujące.
Na czym to polega, to będzie za chwileczkę.
Natomiast teraz chcę zwrócić uwagę Państwa,
że zawsze trzeba stosować takie podejście inkrementalne.
Czyli powiedzmy,
jeżeli mam jakąś część systemu,
na przykład jakiś komponent,
do którego mam przygotowany zbiór testów T1 i T2.
I te testy już nie wykazują żadnych błędów,
bo właśnie istotne jest,
że w testowaniu interesuje nas,
czy testy wykazały istnienie jakiegoś błędu,
czy testy przechodzą,
nie ma żadnego błędu wykazanego.
Powiedzmy, że wykonaliśmy to,
że te testy nie wykazują błędu.
Teraz dodajemy nową część systemu,
część B, dla której przygotowaliśmy zbiór testów T3.
To proszę Państwa nie wystarczy,
żebyśmy tylko wykonali ten,
po dodaniu tej części B,
żebyśmy wykonali ten zbiór testów T3.
Tylko powiedzmy po integracji tych dwóch części,
trzeba cały zbiór testów przejść od początku do końca.
No i chociażby stąd właśnie,
że zawsze trzeba te testy wcześniejsze też wykonać,
bo one być może tutaj nie wykazywały błędów,
a teraz jak dodaliśmy nowy element,
to się mogło zmienić troszkę w środowisku,
więc mogą teraz błędy być wykazywane.
Także to, że zawsze cały ten zbiór testów
od początku do końca,
po dodaniu nowego elementu trzeba wykonać,
no to chociażby z tego wynika
ta duża pracochłonność,
złożoność tego testowania
i to, że koszty testowania przy produkcji systemów
często przekraczają 60% ogólnych kosztów produkcji.
Więc jak gdyby musimy sobie z tego zdawać sprawę.
Momencik, coś mi się zacięło, okej.
Dodajemy kolejny element,
znowu cały zbiór testów musimy przejść,
nie tylko te, które były wcześniej wykonane.
No dobra, no to wiedząc już,
że musimy takie te zbiory testów
od początku do końca powtarzać,
to teraz jeszcze popatrzmy na takie właśnie
ogólne bardzo strategie podejścia do testowania.
Wspomniałam, że może być to testowanie tożsame,
to jest pop-down,
czyli rozpoczynamy od komponentu takiego
najbardziej abstrakcyjnego
i posuwamy się w głąb.
To się wiąże, takie podejście możemy stosować wtedy,
kiedy w ten sposób tworzymy system.
Czasem tak się rzeczywiście buduje te systemy,
że zaczynamy od góry,
nie ma jeszcze tych elementów gotowych poziomu niższego,
one są przykryte pewnymi namiastkami,
pewnymi tak zwanymi stubs,
i właśnie, i jak gdyby, no...
Momencik...
Czyli zaczynamy od takiego elementu,
no powiedzmy tego górnego,
ale w zasadzie nie ma tych części niższych, prawda?
Jeszcze gotowych.
Tutaj są tylko jakieś wywołania ich,
musimy te wywołania przykryć właśnie tymi stubsami,
tymi namiastkami,
które na przykład nie realizują w ogóle tych funkcji,
a jedynie mają interfejs taki,
jak to tutaj jest wymagane.
Jakie są wady, zalety takiego podejścia?
No jeśli chodzi o zalety,
to ponieważ zaczynamy tutaj od tej górnej części,
a tych niższych części jeszcze nie ma,
one będą...
Potem stopniowo będziemy schodzić, tak?
Potem jedziemy tu, potem tu i tak dalej,
to błędy takie, jeśli chodzi o...
Błędy takie, jeśli chodzi o strukturę tego oprogramowania,
będą wykryte stosunkowo szybko,
więc jeszcze będzie można je w miarę wcześnie poprawić.
Poza tym, ponieważ tutaj musimy przygotowywać te stubsy,
te namiastki tego kodu,
którego jeszcze nie ma,
ale one będą jakąś tam symulowały,
no ten brakujący kod,
więc no nie w pełni funkcjonalny,
ale jak gdyby no coś robiący,
czy udający, że się coś dzieje,
ten system już będzie w miarę wcześnie dostępny.
Także to jest niewątpliwie zaleta.
Problem polega na tym,
że te zaślepski, te namiastki, te stubsy,
tych niższych części,
wcale nie są łatwe do oprogramowania.
No i że jest to dodatkowy wysiłek, prawda,
który trzeba zrobić.
No trzeba przygotować taką namiastkę kodu.
I czasem ona musi mieć jakąś tam bardzo okrojoną,
ale jednak jakąś tam funkcjonalność,
żeby w sumie cały ten system działał.
Także to są wady tego podejścia.
Drugie podejście, podejście wstępujące,
to jest, proszę Państwa, polega to na tym,
że zaczynamy to od testowania tych takich,
jak gdyby liści tej naszej struktury drzewiastej.
Testujemy ten elemencik, jak on jest gotowy,
tak, ten jest też przetestowany,
no to idziemy, idziemy w górę, tak,
do tego elementu, w którym na przykład one są wykorzystywane.
No, no super.
Tylko, że żeby taki elemencik, prawda,
zmusić do pracy, tak,
jak nie ma tych warstw wyższych,
tego jeszcze nie ma,
no to trzeba w jakiś sposób ten element zmusić do pracy,
żeby się go dało przetestować.
Więc trzeba przygotować, napisać po prostu driver testów.
Napisać taki kod, który będzie go wykonywał,
który będzie mu przekazywał te parametry,
żeby, no, sprawdzić, czy to działa, czy nie.
No i tutaj, prawda, jak to skończymy,
tutaj już się nic nie, nie wykazywane są żadne błędy.
Teraz ta rzecz może być użyta w tym poziomie wyższym
przez jakiś kolektor,
przez jakiś kolejny komponent.
Znowu, żeby go zmusić do pracy,
trzeba przygotować driver testów.
Więc to też się wiąże, prawda,
tam były namiastki kodu,
a tutaj są drivery testów, które trzeba przygotować,
więc też jest to dodatkowy wysiłek,
który musimy włożyć.
Jaka jest, jaki jest minus takiej metody?
Otóż, no, błędy w architekturze,
jeśli chodzi o strukturę, o architekturę tego oprogramowania,
no, będą wykryte późno,
wtedy, kiedy praktycznie ten system będzie już prawie działający.
Wobec tego, no, nie będzie sensu, żeby te błędy poprawiać.
To jest, proszę Państwa, takie podejście,
no, tak jak tutaj napisałam, jest krytykowane.
Jednak, no, jest używane również w systemach obiektowych,
prawda, zaczynamy od testowania obiektu takiego w izolacji,
przygotowując dla niego driver testów,
który będzie, na przykład, te jego operacje będzie wywoływał.
Potem przechodzimy do testowania takiego,
jak gdyby, klastra tych obiektów,
które ze sobą jakoś współpracują,
więc w systemach obiektowych jest to często stosowane.
Teraz chcę Państwu powiedzieć troszkę o zupełnie innym typie testowania.
To jest testowanie, które jest nazywane stress testing
i które jest wykonywane wtedy, kiedy mamy już gotowy system,
to znaczy system, w którym już nie wychodzą,
jak gdyby nie wykazywane są już błędy,
ale chcemy ten system, jak nazwa mówi, prawda,
zmusić do pracy w trudniejszych okolicznościach.
I na przykład, jeżeli mamy, powiedzmy, jakiś system,
no, nazwijmy, powiedzmy, jakiś sklep,
który ma w ciągu sekundy obsłużyć, powiedzmy,
100 transakcji przychodzących, tak, i ma je zrealizować,
no to, to spróbujmy, a jeżeli,
jak ten nasz sklep będzie się zachowywał wtedy,
kiedy tych transakcji w ciągu sekundy będzie 200, 300, 500, a może 1000.
Więc właśnie, jak gdyby, zmuszamy ten system do pracy
w trudniejszych sytuacjach, w trudniejszych sytuacjach,
niż to, na które był projektowany.
I patrzymy, jak on się będzie zachowywał.
Czy nie będą gubione, na przykład, jakieś transakcje,
w tym systemie.
Wiadomo, że będzie zwolniona jego praca,
ale na ile ta praca będzie zwolniona?
Czy jeszcze ten czas realizacji tej transakcji
będzie akceptowalny, czy już nie?
I przy jakiej liczbie tych transakcji
ten czas będzie nieakceptowalny?
Także to, no właśnie, jak gdyby, patrzymy,
patrzymy, jak nastąpi upadek tego systemu.
No właśnie, czy nie będzie utraty jakichś,
takich danych.
Po co również to się robi, takie stresowanie systemu?
Otóż, proszę Państwa, w takiej sytuacji właśnie,
kiedy ten system pracuje w trudniejszych warunkach,
niż to, na jakie był projektowany,
często wychodzą błędy, które wcześniej nie ujawniały się
w normalnym testowaniu.
Na przykład, właśnie, jakieś tam kolejności,
dostępu do pewnych danych, prawda,
wtedy w trakcie normalnego testowania
nie było z tym problemów,
a tutaj nagle, czy jakieś zakleszczenia
często właśnie przy takiej utrudnionej pracy systemu wychodzą.
No i, proszę Państwa, kolejne podejście,
to jest testowanie porównawcze.
To jest, nazywa się to,
back to back.
To jest, proszę Państwa,
coś, co się stosuje wtedy,
kiedy mamy więcej niż jedną wersję danego systemu.
Czyli na przykład wtedy, kiedy mamy,
powiedzmy, wersję systemu,
ja sobie tutaj napiszę wersja trzecia, tak,
to jest ta wersja aktualnie pracująca,
a teraz przygotowaliśmy wersję kolejną,
wersję czwartą tego systemu.
No i teraz, proszę Państwa, ta wersja czwarta,
na przykład ma nowe funkcje,
ma nowe możliwości,
ale ona powinna realizować wszystkie te funkcje,
które ta wersja poprzednia realizowała,
no bo użytkownicy się do niej przyzwyczaili,
będą chcieli z tych funkcji korzystać,
więc one powinny być zrealizowane.
No i w takich przypadkach, prawda,
obie te wersje zasila się tymi samymi danymi wejściowymi,
które wchodzą tu i tu, tak,
obserwuje się, co wychodzi z tych,
czy te rezultaty wychodzące są takie same, czy nie,
jak są takie same, to super,
jak nie, no to patrzymy, dlaczego nie są takie same, prawda,
i gdzie tutaj ten problem wystąpił.
To jest również testowanie, które stosuje się na przykład wtedy,
kiedy to samo oprogramowanie,
czyli to mogą być wersje niekoniecznie jakieś tam nowsza i starsza,
ale na przykład wersje systemu,
który do pracy w różnych środowiskach został przygotowany.
Na przykład przygotowaliśmy jakieś oprogramowanie,
które ma działać na Windowsach i ma działać na Linuxie.
No i jak gdyby musimy zasilać to tymi samymi danymi,
patrzeć, czy takie same rezultaty wychodzą.
Stosuje się tutaj jakieś komparatory tych wyników
i ewentualnie wychodzą różnice pomiędzy tymi wersjami oprogramowania.
Dobra.
Czy do tego, co mówiłam,
mają Państwo jakieś pytania, uwagi?
To były takie bardzo, bardzo podstawowe dane
dotyczące właśnie podejścia do testowania.
Proszę Państwa, trzy minuty przerwy.
Ja zablokuję na moment, zatrzymam nagrywanie.
I po prostu muszę znaleźć kolejną prezentację.
---------------------------------------------Teraz udostępnię swój ekran.
I tutaj teraz potworzę tą prezentację.
No i teraz, proszę Państwa, wiemy już, że mamy różne typy testowania, właśnie to porównawcze, czy to stresujące.
Natomiast ja się teraz chcę skoncentrować na tym takim testowaniu, jak gdyby utożsamianym przez nas słowem testowanie,
czyli takim testowaniu ukierunkowanym na wyszukiwanie defektów.
W trakcie tworzonego oprogramowania.
To się po angielsku nazywa defect testing.
No i proszę popatrzeć.
Specyfikacja wymagań, specyfikacja systemu, projekt systemu, ogólny, szczegółowy, kod.
To testy jednostkowe, integracji systemu, akceptacyjne.
To jest, proszę Państwa, tak zwany model V-testowania.
Bardzo taka podstawowa rzecz.
Specyfikacja wymagań, systemu, projekt, ogólny, szczegółowy, testy.
Z czym to się Państwu kojarzy? Co to jest?
Już dzisiaj też żeśmy na początku zajęć o tym mówili, że są to fazy modelu wodospadowego.
I teraz proszę popatrzeć, tutaj z tą fazą są związane testy.
Czyli jak wykonujemy specyfikację wymagań, jak określamy co oprogramowanie ma robić, w jakich warunkach ma pracować i jakie są funkcje, prawda?
Kto może te funkcje wykonać?
To przygotowujemy wtedy równolegle, powinniśmy przygotować testy akceptacyjne.
Czyli testy, które tutaj proszę popatrzeć już na gotowym systemie.
Prawda? Będą sprawdzały, czy rzeczywiście oprogramowanie te funkcje wykonało.
Jak mamy system tutaj wyspecyfikowany, no to testy całego systemu powinny być przygotowane.
Mamy projekt ogólny systemu.
Tutaj jako projekt ogólny, ja rozumiem projekt architektury tego systemu.
Czyli takiej struktury, z jakich części on się składa.
Dzisiaj mówiłam na przykład o tych komponentach, o ich zależnościach.
Więc tutaj przygotowujemy.
Dzisiaj przygotowujemy testy integracji.
Czyli testy, które będą sprawdzały, czy myśmy na przykład dobrze te komponenty ze sobą połączyli.
Czy te interfejsy pomiędzy nimi dobrze współpracują.
Testy integracji na tym poziomie powinny być przygotowane.
Jak robimy projekt szczegółowy jakiegoś modułu, no to testy tego modułu powinny być przygotowane.
Jak piszemy kod, to testy jednostkowe dla tego kodu od razu powinniśmy przygotować.
Od razu je wykonać i zrobić.
I teraz, jeśli tutaj te testy jednostkowe już nam nie wykazują błędów.
Integrujemy te jednostki takie malutkie w troszkę większe moduły.
No to wykonujemy testy modułów.
Tak długo, aż one przestaną nam wykazywać, nie będą się pojawiały nowe błędy.
Dalej tutaj, jak mamy moduł już przetestowany.
Moduł A, moduł B. Składamy je.
Wykonujemy testy, które sprawdzają, czy one dobrze współpracują ze sobą.
Mówiłam Państwu dzisiaj o tym podejściu takim inkrementalnym.
Czyli trzeba pamiętać o tym, że po dodaniu kolejnego elementu musimy cały zbiór testów wykonać.
Jeśli tutaj już nie wykazywane, nie wykonywane.
Nie wykazywane są błędy w całym systemie.
Ta struktura tych powiązań wydaje się być dobra.
Dobrze przekazywane parametry.
No to teraz patrzymy, czy od strony użytkownika ten system robi to, co w tych wymaganiach było zapisane.
Czyli czy przechodzą te testy akceptacyjne.
No a potem to już użytkownik, czy reprezentanci użytkownika pracują na tym systemie.
I mówią tak.
Ten system robi to, co ja chciałem.
Albo mówi, no ale ja bym chciał, nie widzę tutaj takiej, czy innej funkcji, której się spodziewałem.
To jest proszę Państwa taki bardzo, bardzo podstawowy model.
Model tak zwany V.
Model V testowania, który właśnie pokazuje, wiąże różne typy testów z odpowiednimi krokami, fazami modelu wodospadowego.
Czy może do tego są jakieś pytania?
Nie widzę tutaj wieku, kim jest.
Nie widzę odpowiedniej, czy tak powiem, aplikacji probowerów.
The manual test.
No właśnie, podkreślam, że celem tego testowania, de Tyson thats things, jest ujawnienie defektów systemu.
Testowanie walidacyjne.
Testowanie walidacyjne to jest proszę Państwa, w tym był bardzo peulturem, nie tylko profesor twardy, który stworzył te systemy, ale jeszcze naszymscy fitnessx.
To jest, proszę Państwa, testowanie tutaj.
Tu będzie testowanie walidacyjne jeszcze,
ale już przez użytkowników, prawda?
Więc celem testowania walidacyjnego jest odpowiedź na pytanie,
czy system robi to, co żeśmy, prawda, chcieli.
Natomiast tutaj nasze te testy akceptacyjne mają sprawdzać,
te akceptacyjne mają sprawdzać, czy są wymagania spełnione.
Czyli to są takie testy, które weryfikują, czy to oprogramowanie robi to, co powinno.
Proszę Państwa, dobry test to jest taki test, który wykrywa błąd w oprogramowaniu.
Musimy pamiętać o tym, że wykrycie wszystkich błędów jest niemożliwe,
więc...
Trzeba się starać, prawda, jak najwięcej tych błędów wykryć,
ale wiadomo, że i tak na pewno jakieś błędy pojawią się w trakcie eksploatacji tego systemu.
Musimy również być świadomi tego, że nawet jeżeli mamy tysiące testów wykonanych,
to wcale to nie znaczy, że to oprogramowanie, prawda, jest poprawne.
Jedynie znaczy to, że już niewykrywane są defekty.
Tutaj też popatrzmy na właśnie taki model testowania, jak to się robi.
Pierwsza rzecz, zacznę od tego, że proszę Państwa, te testy trzeba projektować.
No właśnie dlatego, że niemożliwe jest sprawdzenie wszystkich możliwości, wszystkich sytuacji.
Jeżeli mamy taką jakąś funkcję, która tam ma, nie wiem, dwie, trzy linijki kodu,
no to na niej być może jesteśmy w stanie takie testowanie wyczerpać.
Wyczerpujące zrobić, ale nie, prawda, przy większych partiach kodu.
Więc trzeba te testy projektować.
Ja dzisiaj troszeczkę wskazówek o tym projektowaniu testów Państwu podam.
Czyli trzeba mieć określony, jak gdyby, cel, co chcemy sprawdzić.
Dlatego chcę, tak, celu, prawda, trzeba przygotować dane
i trzeba wiedzieć, co dla tych danych powinno powstać, prawda,
jaki wynik powinniśmy dla tych konkretnych danych uzyskać.
No, teraz mamy tą jednostkę, którą testujemy,
czyli wykonujemy, czy to będzie funkcję, czy jakaś operacja,
czy będzie jakiś większy fragment kodu, prawda.
Wykonujemy to na tych danych testowych, które tu żeśmy przygotowali.
Dostajemy pewne rezultaty z wykonania tego programu
i te rezultaty, które dostajemy, są porównywane z tymi,
które żeśmy w tym projekcie testów przewidzieli.
No i albo nam się to zgadza, albo nam się to nie zgadza, tak.
Jak nam się to nie zgadza, no to prawdopodobnie,
to ten test prawdopodobnie wykrył błąd, chyba żeśmy się tutaj pomyli.
Ale w każdym razie mamy taki raport testowania, który mówi,
co wyszło, gdzie są jakieś różnice, no i wtedy trzeba,
trzeba te różnice analizować.
No i teraz popatrzmy właśnie na taki przypadek testowy.
A więc, tak jak już Państwu wspomniałam, trzeba określić cel tego testu,
funkcję tego testu.
Trzeba podać wejście, czyli dane, prawda, to są dane,
jakie ten test ma dostać.
I co?
Co pojawi się tutaj na wejściu, prawda, czyli co będziemy tutaj podkładać
na wejście tego programu i jakich rezultatów się spodziewamy.
To, to, to są jak gdyby takie trzy elementy nam określają ten przypadek testowy,
tak zwany test case.
Cel testu, dane wejściowe i rezultat.
Wspominałam, że testowanie wyczerpujące jest absolutnie,
jest absolutnie niemożliwe.
Więc my musimy, dlatego musimy te testy projektować, tak,
przewidywać pewne, pewne przypadki, które będziemy sprawdzać.
No i teraz proszę Państwa, jakimi wskazówkami możemy się kierować
przy przygotowywaniu tych danych, tych przypadków testowych.
Otóż ja tutaj,
pokazuję Państwu takie wskazówki, które dawno temu podał Petr Czenik,
ale właściwie one są aktualne również dzisiaj.
Czyli z punktu widzenia użytkownika, to użytkownika nie interesuje
na ile dobrze są przetestowane komponenty, tylko chciałby,
żeby cały system działał, prawda.
Więc testowanie możliwości systemu jest ważniejsze od testowania
jego komponentów.
No, ale z drugiej strony wiemy, że jeżeli komponenty nie są właściwie
przetestowane, no to cały system też nie będzie dobrze działał.
Jeżeli komponenty nie są właściwie przetestowane, no to tutaj przy
testowaniu całego systemu, jak nam wyjdą błędy, to trudno będzie
te błędy jak gdyby zlokalizować w odpowiednim komponencie.
Przygotowując te przypadki testowe, powinniśmy no szczególnie szukać,
takich błędów, które będą utrudniały pracę użytkownika,
uniemożliwiały, blokowały, opóźniały.
Kwestia utraty danych, prawda, to jest bardzo istotna rzecz w wielu
zastosowaniach, praktycznie w każdym zastosowaniu.
Czy to będzie system bankowy, czy to będzie jakiś sklep, to kwestia
utraty tych danych jest niezwykle ważna, więc szczególnie tego typu
przypadki powinny być wykrywane.
Teraz ja już o tym dzisiaj Państwu troszkę wspominałam, że jeżeli
opracowujemy nową wersję systemu, tak, to mamy nową wersję, tą na przykład
czwartą, tak, a poprzednio mieliśmy wersję trzecią, to mówiłam o tym
testowaniu bankowym, prawda, że warto wtedy to testowanie zrobić,
dlatego że wielu użytkowników będzie pracowało, nawet jeśli tu w tej
nowej wersji, dodamy nowe możliwości, nowe scenariusze.
Użycia tego systemu, to szczególnie na początku wielu użytkowników
będzie pracowało według tych starych scenariuszy, a więc będą się bardzo
irytowali, jeżeli coś, co działało w poprzedniej wersji systemu, nagle
przestaje im działać, więc właśnie ważne jest, żeby w tych nowych
wersjach systemu wszystkie stare funkcje również właściwie działały,
bo przez jakiś czas użytkownicy pracują według tych starych,
starych nawyków. No i tutaj Petrzenik powiedział tak, no ważniejsze jest
testowanie typowych sytuacji, prawda, takich, które będą przez większość
użytkowników używane, ale ja za chwilę będę Państwu mówić jeszcze o tym
przygotowywaniu tych przypadków testowych i powiem wtedy, że testuje się
właśnie te sytuacje brzegowe.
Jest to ważniejsze, ale to, że to jest ważniejsze, to nie znaczy, że nie należy
testować sytuacji brzegowych, wręcz przeciwnie, za chwilę będę Państwu
mówiła, tak trzeba przygotować takie dane testowe, które będą te sytuacje
brzegowe obejmować. To są bardzo takie ogólne wskazówki, ale nadal działające.
Teraz, proszę Państwa, wiemy, że tutaj naszym celem jest wykrycie defektów,
w tym testowanym fragmencie kodu. No i teraz, jak możemy do tego podchodzić?
Czyli, po pierwsze, możemy ten testowany fragment kodu traktować jako czarną
skrzynkę, czyli mamy tu coś do przetestowania, my nie wiemy, co w nim
w środku siedzi, tak, ale mamy specyfikację tego czegoś, tak, tej funkcji, czy tego
modułu, czy tego programu, tak.
Specyfikacja mówi nam, co mu należy podać na wejściu i specyfikacja mówi,
jakie rezultaty powinniśmy uzyskać. To jest tak zwane testowanie czarnych
skrzynek na podstawie specyfikacji. Drugi typ podejścia to jest testowanie
białych skrzynek. To tutaj teraz, proszę Państwa, ja wiem, jaki kod siedzi w środku,
mało tego, tutaj znam strukturę tego kodu, wiem, w jakim to jest języku, mam
dostęp do tego kodu źródłowego, właśnie znam ten kod, tak, mam do niego dostęp.
To jest testowanie tak zwanych białych skrzynek, niektórzy mówią o szklanych
skrzynkach, a inaczej to jest po prostu testowanie strukturalne, dlatego, że ja
mam dostęp do struktury tego programu, który testuję.
No dobrze, może teraz, jak Państwo myślicie, które z tych testowań jest
bardziej efektywne? Co się określa jako efektywność testowania?
Efektywność testowania to jest liczba wykrytych defektów na jednostkę czasu.
Czyli liczba defektów na jednostkę czasu.
To jest efektywność testowania.
Jak Państwo myślicie, które z tych testowań jest bardziej efektywne, funkcjonalne czy
strukturalne?
No jak Wam się wydaje?
Mi się wydaje, że funkcjonalne.
Funkcjonalne, dobra, macie rację, macie rację, chociaż z drugiej strony by się
wydawało, no dobra, ale jak ja mam tutaj dojście do kodu, to może,
to moje testy, no będą lepsze, tak, no one może, korzystając ze znajomości kodu,
jak one będą przygotowane, to ja tutaj mogę więcej rzeczy sprawdzić.
Więc, proszę Państwa, faktycznie tak jest, że testowanie funkcjonalne ma lepszą
efektywność, czyli no po prostu więcej błędów w jednostce czasu może być
wykrytych, ale niż testowanie białych skrzynek.
I takie eksperymenty były kilkakrotnie.
Nie przeprowadzane, można wyniki tych eksperymentów w literaturze znaleźć.
Z tym, że nie należy z tego wyciągać takiego wniosku, że skoro to testowanie
tych czarnych skrzynek, tak, nie mając dojścia do tego kodu, jest bardziej
efektywne niż białych skrzynek, gdzie mogę korzystać ze znajomości kodu,
no to, że to likwidujemy.
Nie, absolutnie, absolutnie.
Absolutnie nie.
Żeby mieć dobrze działające oprogramowanie, tak, w którym potem w trakcie
korzystania z tego oprogramowania, no będzie mało tych błędów wskazywanych
przez użytkownika, należy oba typy testowania stosować.
Teraz jeszcze tutaj tego nie mam, ale chcę, to jest, proszę Państwa, no tak zwane
takie dynamiczne, prawda, bo my dajemy pewne dane, tak, i testujemy,
czyli wykonujemy ten program, ale jeszcze możemy, ja tutaj użyję słowa
review, to jest literka R, review, czyli to się nazywa kod review,
czyli,
no, dosłownie tłumacząc, recenzja kodu, ale tu chodzi o przeglądanie kodu.
No i tutaj głównie się to porównuje, prawda, jedno z drugim, czy lepiej jest,
daje większą efektywność przygotowanie testu w oparciu o strukturę tego kodu,
czy, i wykonanie go, czy może wystarczy po prostu taka statyczna analiza kodu.
To kod review wygląda w ten sposób, że, no, mamy, nie wiem, na ekranie,
na przykład wyświetlamy sobie kod programu i przyglądamy się temu
i staramy się wykryć błędy, braki w tym.
Zwykle to robi nie osoba, która ten kod pisała, bo jak gdyby taka osoba pisząc ten kod mogła,
no, jak gdyby z pewnych takich poziomów,
podświadomie potem unikać pewnych rzeczy, tylko, no, na przykład ktoś inny
z tego zespołu projektowego ten kod będzie analizował i oglądał
i można w tym kodzie wykryć błędy.
I tutaj muszę Państwu powiedzieć, że były też robione takie eksperymenty
sprawdzające właśnie efektywność tego statycznej analizy kodu
i testowania tego kodu i z tego wyszło, że to,
statyczna analiza kodu daje większą efektywność, no, wykrytych defektów niż właśnie testowanie.
Ale jeszcze raz podkreślam, że to nie znaczy, że możemy z tego wykonywania i z testowania zrezygnować, prawda,
tylko będziemy dokładnie czytać, analizować ten kod i wykryjemy wszystkie błędy.
Nie. Wszystkie możliwe metody należy stosować, żeby to oprogramowanie,
było oprogramowaniem dobrej jakości, czyli zarówno analizę statyczną kodu,
jak i testy prowadzane na podstawie znajomości struktury,
jak i testy czarnych skrzynek należy stosować, żeby, no, uzyskać oprogramowanie dobrej jakości.
Tutaj jeszcze chcę zwrócić uwagę, prawda, mówiłam dzisiaj o tym strukturze,
architekturze oprogramowania, o tym, że te komponenty, prawda,
udostępniają interfejsy czy wymagają pewnych interfejsów,
więc oczywiście takie właśnie powiązania pomiędzy tymi komponentami,
pomiędzy tymi elementami oprogramowania, to też należy te interfejsy, prawda, testować.
No, tutaj już trzeba mieć pewną wiedzę troszkę o parametrach tych interfejsów,
żeby można było takie testy interfejsów przygotować.
Czy do tego, co mówiłam teraz, może mają Państwo jakieś pytania?
No właśnie, ja już troszeczkę zaczęłam tutaj wspominać o tym,
kto może poszczególne typy testów wykonywać, czy może kto powinien.
No to teraz popatrzmy jeszcze tutaj na taką strukturę.
Właśnie kto określone typy testowania może robić.
Otóż tak, testowanie strukturalne, czyli to jest testowanie tych białych skrzynek, tak.
Mam dostęp do kodu White Box Testing i przygotowuję testy na podstawie struktury.
No to proszę Państwa, muszą te testy przygotowywać osoby, które pracują przy budowie tego oprogramowania.
Tak.
I ja będę, no pewnie już nie dzisiaj, mówić Państwu o metodach, jakie tutaj są stosowane.
I zobaczycie Państwo, że jest no dosyć dużo nakładu pracy potrzebujemy, żeby właśnie te metody zastosować.
Więc nie można tego testowania strukturalnego stosować do dużych fragmentów kodu.
To muszą być małe fragmenty kodu.
Czyli?
Czyli na przykład funkcje, operacje w naszym systemie, prawda?
A nie cały, jakiś mały moduł, ale małe fragmenty kodu, tak.
Czyli te jednostki małe, mało małe.
Bo zobaczycie Państwo, jakie są podejścia tutaj przy tym testowaniu strukturalnym.
I po prostu ten kod, który w ten sposób będziemy testować, nie może być długi.
Teraz, jeśli chodzi o testy czarnych.
Czyli testy funkcjonalne, no to ja je tutaj przywiązałam, prawda, pokazałam do całych systemów, ale te testy funkcjonalne stosuje się zarówno do tych małych jednostek kodu, oczywiście też, też funkcje możemy testować właśnie w ten sposób, że, prawda, badamy tutaj, no pewne zakresy danych wejściowych, patrzymy, czy są dobre, dobre wyniki.
Możemy moduły, możemy podsystemy.
Możemy cały system.
Czyli testowanie funkcjonalne to jest testowanie, które powinno być i może być stosowane do różnych jednostek, jednostek o różnej wielkości.
Testy strukturalne tylko do małych jednostek.
No i jeśli chodzi o te testy funkcjonalne, to jest wykonywane przez zespół zupełnie inny, zespół testerów.
Nie teoretycznie.
Osoby, które pracują przy pisaniu kodu, tylko zupełnie inne osoby, które nie mają nic do czynienia z tym konkretnym kodem.
Dlaczego?
Dlatego, że okazuje się, że gdyby to były te osoby, które ten kod pisały, to pisząc ten kod, być może one zapomniały o pewnych sytuacjach i teraz w tych testach funkcjonalnych te sytuacje też by pomijały.
Dlatego.
Dlatego tutaj jest ten zespół testerów niezależnych, niezwiązanych z tworzeniem tego kodu po to, żeby właśnie te różne dziwne czy nieprzewidziane sytuacje wykryć.
Jeśli chodzi o te testy interfejsów, to mówiłam Państwu, tam są nam potrzebne pewne parametry, więc muszą tutaj uczestniczyć osoby, które tworzyły to oprogramowanie, żeby na przykład powiedziały nam jak te parametry mogą wyglądać.
W jakiej kolejności należy te parametry podać, prawda? Czyli jakie zakresy wartości. Czyli to zwykle jest, tak jak Państwo widzicie, taki zespół mieszany. Ktoś z tych osób, które to oprogramowanie tworzyły i jacyś testerzy niezależni po to, żeby właśnie różne dziwne przypadki tutaj w tych interfejsach też ewentualnie wykryć.
A właśnie tutaj mówiłam Państwu o tej efektywności testowania, liczba wykrytych defektów na jednostkę czasu.
Mówiłam Państwu, że były eksperymenty robione. To jest chyba pierwszy taki eksperyment, który wiele lat temu był zrobiony, ale było to potwierdzane i w późniejszych latach.
Mówiłam Państwu o tym kod review, o tej analizie statycznej kodu, o inspekcji kodu, że też jest ona bardzo efektywna. Jest tańsza, prawda? Bo nie potrzeba sprzętu, żeby go realizować, więc wychodzi to bardziej efektywne niż testowanie.
Ale jest to bardzo efektywne.
Ale jest to bardzo efektywne, bo nie potrzeba sprzętu, żeby go realizować, więc wychodzi to bardziej efektywne niż testowanie.
Ale wspominałam, trzeba stosować wszystkie możliwe podejścia, czyli i testy takie dynamiczne i analizę kodu po to, żeby wykryć jak najwięcej błędów, braków.
I ja bym w tym momencie dzisiaj zakończyła wykład, bo nie chcę wchodzić już w nową tematykę, natomiast na następnym wykładzie
Na następnym wykładzie będę mówiła Państwu o tym testowaniu funkcjonalnym, będę mówiła Państwu o testowaniu strukturalnym, no i troszkę tak bardzo ogólnie.
Tutaj chcę zaznaczyć, że tematyka testowania jest niezwykle rozległa i że jest bardzo wiele literatury na ten temat, taki jak gdyby guru jeśli chodzi o testowanie.
To jest Bezier, który napisał kilka bardzo grubych książek dotyczących testowania, jedna z nich jest również przetłumaczona na język polski, więc jest to bardzo, bardzo rozległa tematyka.
Na uniwersytetach są wykłady często, no co najmniej 30 godzin w semestrze dotyczących testowania, często nawet jest to wykład, który idzie przez dwa semestry.
Jest z kolei także o tym, ja jedynie Państwu zarysuję na czym to testowanie funkcjonalne i strukturalne polega, nie będę wchodziła w detale, bo tak jak mówię jest to tematyka niezwykle rozległa i wymagająca wiele czasu, którego już tutaj nie mamy.
Natomiast będę chciała, żebyście Państwo przynajmniej wiedzieli na czym to polega i troszkę wiedzieli jak się przygotowuje te dane testowe.
Więc do tej strony dziesiątej dzisiaj żeśmy doszli, a reszta już na kolejnym wykładzie.
Czy do tego co mówiłam, może mają Państwo jakieś pytania, uwagi?
Jeśli nie, to dziękuję Państwu dzisiaj za udział w zajęciach, no i życzę Państwu miłych świąt i szczęśliwego nowego roku i spotykamy się w styczniu.
Także dziękuję za udział dzisiejszy, gdzie ja mam tutaj, zatrzymaj, udostępnianie.
No i mam nadzieję, że się wyłączę już nagrywanie.
I że...
---------------------------------------------Myślę, że zacznę może od pokazania rozwiązań, zadań, które były i tutaj nie ukrywam, że pokażę Państwu rozwiązanie Waszej koleżanki i popatrzmy może jak to wygląda.
W podobnym trybie będę chciała, żebyście Państwo odpowiadali w trakcie egzaminu. Czyli tak, mamy diagram maszyny stanowej, w tym wypadku taki bardzo prosty, tylko dwa stany, ale sporo jest różnych czynności, które tutaj mogą być wykonywane
i te czynności są wyzwalane, stymulowane.
One są różnymi zdarzeniami, albo zdarzeniami takimi wewnętrznymi, albo jakimiś zdarzeniami zewnętrznymi, które tutaj są oznaczone literkami E1 do E4 bodajże.
Podana jest pewna sekwencja tych zdarzeń, które mają miejsce, ta sekwencja jest tutaj podana, no i właśnie Państwa zadaniem praktycznie jest wypełnienie takiej tabelki, czyli mamy tutaj tą sekwencję zdarzeń tak jak została ona podana,
należy wpisać jaki stan został osiągnięty wtedy, kiedy takie zdarzenie miało miejsce i również tutaj w odpowiedniej kolejności wypisać jakie czynności obiekt tej klasy będzie robił, z jakimś uzasadnieniem dlaczego taką, a nie inną czynność.
Przypomnę, że istotna jest sekwencja tych zdarzeń.
No i popatrzmy tutaj, w momencie jak obiekt jest stworzony, to rozpoczyna swoje, w cudzysłowie, życie.
No i popatrzmy tutaj, w momencie jak obiekt jest stworzony, to rozpoczyna swoje, w cudzysłowie, życie.
No i popatrzmy tutaj, w momencie jak obiekt jest stworzony, to rozpoczyna swoje, w cudzysłowie, życie.
Nowy zijn oznaczony jako stan początkowy, w tym wypadku jest to stan o nazwie Stan 1.
Tutaj zwracam uwagę Państwu, że cała ta nazwa stanu, która jest podana w Diagramie powinna być tutaj wpisana.
No i teraz jeżeli wchodzi obiekt do tego stanu, to przy wejściu do stanu wykonuje czynność, którą tutaj została poprzedzona słowem kluczowym ENTRY,
czyli czynnośćN1, a następnie przechodzi do wykonywania
czynności PRZEWADZилли, którą została poprzedzona słowem KLUCZOWYM ENTRY, czyli czynność N1, a następnie przechodzi do wykonywania czynności przednouszekowego tego Russian Standard, gdzie jest możliwo myśleć,い attitudes and projects, i socially and projects.
czynności oznaczonej słowem kluczowym do. I zawsze jak jest w tym stanie,
to tą czynność A3 robi, więc ona jest tutaj podana. Zdarzenie E3 jest zdarzeniem
tutaj widzimy wewnętrznym, w tym stanie nie powoduje to wyjścia, wejścia do stanu,
wobec tego wykonuje tą czynność, która jest wyzwolona tym zdarzeniem E3
i wraca do wykonywania czynności, która jest związana ze słowem kluczowym do.
W zdarzeniu E1, następne, które ma miejsce, widzimy jest tutaj napisane
na takim tym uchu, czyli widzimy wyjście ze stanu, potem jesteśmy jak gdyby
na tym przejściu i potem do stanu wchodzimy, czyli wychodzimy ze stanu,
a więc zdarzenie E2, bo exit, jesteśmy na tym przejściu, czyli zdarzenie E5,
które jest zdarzeniem E1 wyzwalane, wchodzimy do stanu, czyli obiekt wykonuje
czynność E1.
Będąc w tym stanie, wykonuje czynność A3, bo ona jest słowem kluczowym do poprzedzona.
Zdarzenie E2 powoduje przejście do, a może tutaj jeszcze pokażemy zdarzenie E4.
Widzimy, że zdarzenie E4 w stanie pierwszym jest zdarzeniem nieoczekiwanym,
nie ma takiego zdarzenia, więc po prostu jest ono ignorowane.
Stan się nie zmienia, obiekt w dalszym ciągu wykonuje to, co jest określone,
tutaj jako słowo kluczowe do.
No i zwykle wymagane jest również pewne wyjaśnienie, to wyjaśnienie tutaj jest podane.
Tutaj zwracam uwagę jeszcze na ten tekst na tłusto podany.
Co możesz powiedzieć o tej klasie, jej operacjach i atrybutach?
No więc patrząc na ten diagram maszyny stanowej, który tu widzimy,
możemy jedynie wnioskować coś o operacjach tej klasy,
bo te wszystkie rzeczy, które obiekt wykonuje jako reakcja na pewne zdarzenia,
które mają miejsce, które tutaj są oznaczone literkami od A1 do A10,
to jest nic innego jak operacje tej klasy.
Nie wiemy, jak ta klasa się nazywa, wiemy, że ma diagram maszyny stanowej
w postaci tych dwóch stanów tylko, ale wiemy, że ma te operacje oznaczone od A1 do A10.
Co więcej, te operacje...
są wykonywane przez obiekt tej klasy,
a więc możemy wnioskować, że wystarczy, aby to były operacje prywatne.
Na pewno nie muszą być publiczne, dlatego że ten obiekt je wykonuje.
O atrybutach nic nie możemy tutaj wywnioskować.
Czy może ktoś z Państwa ma jakieś pytania do tego?
Tak, ja bym chciał się zapytać o te może akcje tej maszyny.
Tak.
Z tych stanów.
E3, A6 i E3, A10.
Bo one nie są przypisane do żadnego entry, do ani exit.
Jeszcze raz.
A ile?
E3.
E3 jest wewnątrz stanu pierwszego.
Dlatego tutaj, jeżeli takie zdarzenie ma miejsce,
to obiekt stanu nie zmienia, tylko wykonuje to, co było związane z tym zdarzeniem.
I wraca do wykonywania tej czynności, która jest poprzedzona słowem do,
czyli czynności, którą zawsze powinien robić, jak jest w tym stanie.
Okej, dobrze rozumiem.
Czy to jest po prostu jakaś dodatkowa czynność?
Tak, to jest coś, co z projektu nam wyszło, że powinno, prawda, że coś się dzieje.
Ale to zdarzenie E3 nie jest zdarzeniem, które tak jak widzimy nie zmienia stanu, nic.
Tylko ono jest oczekiwane i myśmy je oprogramowali w ten sposób,
że tutaj związaliśmy z tym zdarzeniem pewną czynność, którą ten obiekt ma wykonać.
Czy to jest jasne teraz?
Tak.
Dobrze.
Może ktoś jeszcze ma jakieś pytania, uwagi?
Dobra, proszę Państwa.
Co jakby się stało, że może Pani...
Tak.
Czy można wkładać jakiś przykład, który...
Gdyby można było coś powiedzieć o atrybutach i klasie?
Na podstawie diagramu maszyny stanowej?
Tak?
Na podstawie diagramu maszyny stanowej nic Pan nie może powiedzieć o atrybutach tej klasy.
Możemy tylko coś mówić o operacjach tej klasy.
O atrybutach nie mamy skąd takiej wiedzy posiąść, więc nie.
Chyba, żeby były jeszcze jakieś dodatkowe informacje.
Ale sam diagram maszyny stanowej jedynie nam daje informacje o tym, jakie są operacje w tej klasie.
I w ilu stanach ona może być.
A, czyli o atrybutach nic.
Czy coś jeszcze? Może ktoś ma jeszcze jakieś pytania czy uwagi?
Dobra, to w takim razie to zamykam.
I, proszę Państwa, drugie zadanie, które polegało na tym, że mamy diagram maszyny stanowej
taki z równoległością stanów, prawda?
Czyli mamy tutaj takie kompozycje stanów, stan jeden i stan drugi.
I zadanie miało polegać na tym, że trzeba było skonstruować diagram maszyny stanowej, który jest równoważny temu.
I ja w trakcie wykładu Państwu pokazywałam, jak to się robi.
Jakiś prosty przykład robiliśmy.
Ja tutaj ten przykład wykładowy minimalnie zmodyfikowałam,
zdejmując tutaj jakieś, prawda, jeszcze dodatkowe ograniczenia.
No i króciutkie przypomnienie.
Taki diagram maszyny stanowej, no właśnie taki płaski, bez strukturalizacji,
to robimy w ten sposób, że składamy jeden, bo to jest kompozycja stanów,
jeden ze stanów tej pierwszej maszyny z jednym ze stanów tej drugiej maszyny.
I musimy wszystkie możliwości rozważyć.
Więc jak tu mamy trzy i tu mamy trzy, no to takich możliwych zestawień
mamy trzy razy trzy, czyli mamy dziewięć.
I dobrze jest zacząć właśnie od tego, że sobie te stany najpierw po prostu tutaj wypisać.
Stan początkowy to jest ten stan, który wynika z pary.
Stan początkowy pierwszej maszyny i stan początkowy drugiej maszyny,
czyli w tym przypadku ZA czy AZ, jakbyście to tam Państwo zrobili, a więc stan.
No i następnie, proszę Państwa, musimy rozważyć zdarzenia,
które są oczekiwane w tym stanie, jednym i drugim,
i popatrzeć, jak wyglądają ich przejścia.
Czyli na przykład, jeżeli jesteśmy w stanie Z i ma miejsce zdarzenie E3,
to stan Z zmienia się na X.
Więc natomiast zdarzenie E3 w stanie A jest nieoczekiwane,
więc ono nie zmienia tego stanu.
Dlatego tutaj widzimy, że pod wpływem zdarzenia E3 stan ZA zmienia się na stan XA,
no bo to Z zmieniło się na X, a nie uległo zmianie.
Natomiast jeśli chodzi o zdarzenie E1, tutaj w stanie A,
to ono powoduje zmianę stanu A na B, prawda?
Czyli widzimy, ale nie jest ono oczekiwane w stanie Z,
więc widzimy, że powoduje tutaj to przejście do stanu ZB.
I tak dalej, prawda? Trzeba tutaj wszystkie te możliwe przejścia rozważyć.
Tutaj akurat Waszej koleżance wyszło, i nie tylko jej,
bo jeszcze komuś, że stan YA, który żeśmy tutaj zidentyfikowali,
że też może być potencjalnie, no nie ma do niego dojścia,
nie jest on osiągalny, ale jest.
Także tak wygląda.
To już jak gdyby wszystkich przejść tutaj nie chcę dokładnie tłumaczyć,
chyba że ktoś z Państwa ma jakieś konkretne pytanie dotyczące,
dlaczego w jednym stanie te przejścia wyglądają tak nieistnie,
czy inaczej?
No właśnie chciałem zadać pytanie, czy właśnie czemu to nie dochodzi,
bo tak się zastanawiałem nad tym i już nie pamiętam za bardzo,
w jaki sposób to, dlaczego te YA nie może być...
Osiągnięte, tak? Dlaczego ono tak sobie wisi tutaj luzem?
No tak tutaj wyszło Waszej koleżance z tych rozpatrywanych przejść,
że popatrzmy na stan Y, tak?
Czyli do stanu Y możemy dojść ze stanu X pod wpływem zdarzenia E1
i tutaj to...
Tutaj to widzimy, ale teraz jeżeli ten X jest w parze A,
zdarzenie E1 powoduje zmianę stanu A na B,
czyli równocześnie jak gdyby zmienia się stan X na Y i zmienia się stan A na B,
stąd widzimy, że tu jest przejście do YB.
No to trzeba było wszystkie przejścia we wszystkich tych stanach rozważyć
i to nam wyjdzie, że no nie ma tutaj możliwości wejścia do tego stanu.
Ale już chociażby tutaj, prawda, ta jedna rzecz, kiedy możemy wejść do stanu Y,
no właśnie ze stanu X pod wpływem zdarzenia E1,
ale zdarzenie E1, czyli tutaj z A, zmienia na Y, tak?
A zmienia równocześnie na B.
W stanie XB zdarzenie E1 zmienia X na Y, ale B się nie zmienia,
więc zostawiamy w tym stanie.
W stanie XC znowu X zmienia na Y,
ale w stanie C zdarzenie E1 jest nieoczekiwane,
więc ten stan się nie zmienia, dlatego przechodzimy do stanu YC.
Czyli no widać było, nie da się tutaj wejść do tego stanu w żaden sposób.
Tak, czy coś może ktoś jeszcze?
Tak, ja mam pytanko.
Tak?
To E4 in Z to jest po prostu ograniczenie,
że to E4 powoduje przejście do Z.
Powoduje przejście z B do A?
Tylko wtedy, jeżeli to B jest w parze z Z, prawda?
Czyli popatrzmy tutaj jakieś BZ nam tutaj, prawda?
I teraz tutaj zdarzenie E4, tak?
Jeżeli Z jest w parze z B, to zdarzenie E4 zmienia B na A,
więc widać, że nam zmieniło.
Natomiast jest ono nieoczekiwane w stanie B,
nieoczekiwane w stanie Z, więc stanu Z nie zmieni.
Więc widzicie Państwo tutaj to przejście pod wpływem E4.
I tutaj już nie ma tych warunków,
bo te nawiasy kwadratowe to są dodatkowe warunki,
dodatkowe ograniczenia.
Więc tutaj w tym płaskim diagramie maszyny stanowej ich już nie ma,
bo my je uwzględniamy, no jak gdyby szukając jakie to przejście będzie,
wyznaczając to przejście już żeśmy jak gdyby ten warunek tutaj,
in Z, załatwili.
Proszę Państwa, to jest prosta rzecz,
tylko wymaga troszkę uwagi i no takiej systematyczności,
więc to rozwiązanie, prawda, będzie, macie Państwo,
będzie ono w materiałach, w nagraniu dzisiaj,
dzisiejszego wykładu proponuję no te osoby,
które nie robiły tego zadania,
albo które się pomyliły w trakcie realizacji tego zadania,
żeby jak gdyby jeszcze raz do tego podeszły,
no spokojniutko krok po kroku spróbowały sobie to zrobić samemu
i potem ewentualnie sprawdzić z tym,
co tutaj w tej odpowiedzi zostało podane.
Te wszystkie zadania są dostępne na UBI, tak?
One na Teamsach znikają.
Znaczy one na Teamsach są jako zadania zaległe,
ja nie wiem, czy Wy za zaległe zadania macie,
znaczy nie macie szansy na nie odpowiedzieć.
Nie, nawet nie możemy chyba ich otworzyć już po tym,
bo one są ustawione, że odpowiedzi to...
Zadania zaległe powinny być.
Można wejść w zaległe i tam chyba można podejść.
Można wejść w zaległe.
Ich nie widać w bieżących,
ale powinien Pan je mieć dostępne w zaległych.
Czyli treść zadania będzie Pan miał udostępnioną,
natomiast no nie ma Pan szansy na przesłanie odpowiedzi na to zadanie.
A dobra, rozumiem rzeczywiście. Dziękuję.
Także one fizycznie są dostępne, tylko w innym miejscu.
No i radziłabym, mamy tam już wyznaczone terminy egzaminu,
więc radziłabym przed egzaminami przejrzeć te zadania jeszcze raz
i sobie je rozwiązać.
Będzie Państwu łatwiej wtedy pisać egzamin.
Dobra, czyli tu zamykamy.
Dobrze i teraz będę chciała już wrócić do materiału wykładowego.
Proszę Państwa, na poprzednich zajęciach zaczęłam Państwu opowiadać o testowaniu.
O testowaniu, które nazywa się defect testing.
Dosłownie tłumacząc tą nazwę, jest to testowanie,
które jest ukierunkowane na wyszukiwanie defektów w systemie.
I to jest jak gdyby takie określenie, z jakim my zazwyczaj wiążemy to słowo testowanie.
Szukamy błędów w programie.
Powiedziałam Państwu również na poprzednich zajęciach,
tutaj się może troszkę wycofam.
Przepraszam, nie w tą stronę włożę.
Że właśnie mamy takie dwa podejścia do tego defect testing,
czyli do tego testowania ukierunkowanego na wyszukiwanie defektów.
Mianowicie tak zwane testowanie czarnych skrzynek, inaczej testowanie funkcjonalne.
I o tym za chwilę będę mówić.
A troszkę później powiem Państwu o testowaniu małych skrzynek.
Tutaj nazwane to testowanie jest testowaniem strukturalnym.
I w tym testowaniu możemy testy przygotowywać,
korzystając ze znajomości kodu tego programu.
Na poprzednich zajęciach mówiłam Państwu również o efektywności testowania.
Przypomnę, że efektywność testowania mierzy się,
licząc jaką liczbę błędów żeśmy wykryli w jednostce czasu.
I wspominałam również Państwu o tym,
że błędy nie tylko w taki sposób dynamiczny można wykrywać,
ale mówiłam Państwu, że bardzo dobre efekty mamy.
Właśnie wysoką efektywność wykrytych błędów dostajemy wtedy,
kiedy po prostu analizujemy ten błąd.
Po prostu analizujemy ten kod programu.
Czyli jest to tak zwany kod review.
Taka statyczna inspekcja kodu.
Czytanie kodu i na tej podstawie wyszukiwanie błędów, braków w nim.
I też daje to wysoką efektywność.
Mówiłam Państwu również o tym,
no na razie musicie mi po prostu uwierzyć,
że zazwyczaj inne typy błędów wykrywane są wtedy,
kiedy czytamy ten kod,
analizujemy ten kod,
a inne typy błędów wychodzą wtedy,
kiedy zmuszamy ten program do wykonywania,
czyli jest to testowanie takie dynamiczne.
No a ponieważ naszym celem jest uzyskanie oprogramowania,
które działa dobrze, które jest niezawodne,
no to powinniśmy wszystkie możliwe środki stosować do tego,
żeby właśnie te błędy, braki wykryć.
Czyli zarówno stosować instrumenty,
czyli na przykład inspekcję kodu na etapie tworzenia tego kodu,
jak i potem testować i różne typy tego testowania stosować.
No właśnie, zacznę może od tego testowania czarnych skrzynek,
czyli inaczej testowania funkcjonalnego.
No właśnie tak jak Państwu powiedziałam,
to coś, co my mamy testować,
to to jest dla nas jedna wielka niewiadoma,
czyli mamy tutaj coś, tak, taką skrzyneczkę
i my nie wiemy, co tam w środku siedzi,
nie wiemy, w jakim języku to zostało napisane.
Mamy pewną specyfikację tego czegoś,
czyli wiemy, co my możemy tutaj jemu podłożyć na wejściu
i z opisu tego, co to coś, co ten kawałek kodu robi,
wiemy, co powinno się dla tych danych wejściowych,
co powinniśmy uzyskać na wyjściu.
A jeszcze raz powtarzam, nie mamy dostępu do tego kodu,
nie wiemy, w jakim to jest języku, jak to jest napisane.
A więc testowanie funkcjonalne,
bo my te testy przygotowujemy na podstawie specyfikacji, funkcji,
które ten testowany kod wykonuje.
Mówiłam również na poprzednim wykładzie,
że te typy testowania powinny być w pewien sposób dostosowane
do tego, jaka jest wielkość tego kodu, który testujemy.
Jeśli chodzi o testowanie funkcjonalne,
to nie ma tutaj żadnych ograniczeń,
czyli my możemy w ten sposób testować małą funkcję,
czy procedurę, która raptem ma trzy linie kodu,
ale możemy w ten sposób testować całą aplikację,
cały duży system.
Czyli tutaj nie ma żadnych ograniczeń na wielkość tego czegoś, co testujemy.
Zarówno malutkie elementy, jak i pełne, duże systemy.
Teraz, proszę Państwa, wspominałam również Państwu o tym na poprzednich zajęciach,
że dobry test to jest taki test, który wykrywa błędy.
Czyli spośród tych różnych danych wejściowych,
które ten testowany element,
może przyjąć na wejściu,
my powinniśmy jakoś tak wybrać pewne dane
i być może dla tych właśnie danych
okaże się, że dostaniemy rezultaty,
które będą niepoprawne,
czyli te dane wykryją pewien błąd w tym testowanym systemie.
No i teraz, proszę Państwa, tak,
mówiłam przed chwileczką,
już o tym, że to coś, co tutaj testujemy,
tutaj ja napisałam system, czyli spodziewam się czegoś dużego, tak,
ale że może być to również jakaś mała jednostka kodu testowana w ten sposób,
więc ponieważ to coś, co testujemy,
może być bardzo, bardzo duże, tak,
to my nie możemy wszystkich możliwych danych tego na wejście podać, tak,
bo pewnie gdybyśmy wszystkie możliwe dane podali, no,
to któreś z nich być może wykazałyby nam,
że wynik jest niepoprawny.
Tego się nie da zrobić,
bo te testowane elementy często są bardzo, bardzo duże.
Więc tak zwane testowanie wyczerpujące,
które polegałoby na tym,
że wszystkie możliwe dane wejściowe będziemy podać,
no, jest praktycznie nierealizowane.
Spośród tych możliwych danych wejściowych
trzeba wybrać pewne dane
i dla tych wybranych danych przeprowadzić,
te testy.
A więc jak trzeba wybrać coś,
to to coś trzeba zaprojektować.
Stąd, proszę Państwa, mówimy o projektowaniu przypadków testowych.
Przypomnę, że przypadek testowy,
to są pewne dane wejściowe,
to jest również oczekiwany rezultat,
no i mamy pewien cel tego testu,
który chcemy sprawdzić.
Wobec tego, proszę Państwa,
skoro się nie da testować w sposób wyczerpujący,
wszystkich możliwych danych wejściowych podać,
to trzeba te dane podzielić na pewne klasy równoważności.
To był pomysł zaproponowany,
jak Państwo widzicie, dawno temu przez Beziera.
Beziera to jest taki guru, jeśli chodzi o testowanie.
Napisał kilka bardzo dobrych i grubych książek
dotyczących testowania.
I powiedział on tak,
my musimy te dane wejściowe
podzielić na pewne klasy,
na pewne grupy,
które mają wspólną charakterystykę.
Co to znaczy wspólną charakterystykę?
To znaczy, że dla tej grupy danych
program zachowuje się w podobny sposób.
No i wtedy już będziemy, prawda,
nie wszystkie te dane podać,
tylko będziemy z tej klasy, z tej grupy
wybierać pewne dane,
jakie to za chwileczkę Państwu powiem.
A więc,
jest to kwestia podziału danych wejściowych
na klasy wejściowe,
na pewne grupy, klasy.
Ale, proszę Państwa,
to, co ten program produkuje,
też można podzielić na pewne grupy,
na pewne klasy.
Czyli na przykład,
wyobraźmy sobie taką prostą funkcję,
która ma sprawdzić,
czy w wektorze liczb
znajduje się określona liczba.
No to taka funkcja może dać
albo rezultat taki, że znaleziono,
albo może dać rezultat taki, że nie znaleziono.
Czyli już też mamy tutaj dwie grupy
rezultatów takiej prostej funkcji.
Czyli też musimy tutaj
dzielić na grupy rezultaty
tego programu, który testujemy.
No i znalezienie takich podziałów, prawda,
jest tutaj tym celem etapu,
na etapie projektowania przypadków,
projektowania przypadków testowych.
Jak znajdziemy te grupy
dotyczące danych wejściowych i rezultatów,
mamy takie grupy,
to wtedy wybieramy
przykłady ze środka grupy
i wybieramy również
przykłady brzegowe dla danej grupy.
Czyli dla danej grupy wybieramy przykład
dany pierwszy, środkowy i ostatni.
Właśnie.
Czyli jeśli mamy pewne dane wejściowe,
i mamy pewien na przykład wektor,
który może się na wejściu pojawić,
to bierzemy pierwszy możliwy element,
bierzemy ostatni i bierzemy ze środka grupy.
Jeżeli tą daną wejściową jest zbiór,
no to zobaczmy, jak ten nasz program
będzie się zachowywał wtedy,
kiedy ten zbiór jest pusty,
o ile taka możliwość jest.
Następnie znowu bierzemy zbiór,
który ma jeden element,
bierzemy zbiór, który ma wiele elementów
i jeśli są w tym kodzie jakieś ograniczenia
na wielkość tego zbioru,
to sprawdźmy, jak to się będzie ten program zachowywał
w przypadku tego maksymalnego zbioru.
Jeżeli mamy pewne dane właśnie dopuszczalne
i mają one wartości domyślne,
no to trzeba to sprawdzić dla tej wartości domyślnej.
Trzeba sprawdzić, a co będzie,
jeżeli ta wartość danych będzie pusta,
a może jeżeli jest spacją,
a może jeżeli jest zero,
a jak ten program będzie się zachowywał wtedy,
kiedy tych danych nie podamy.
Czyli to są takie podpowiedzi,
jakie elementy należy uwzględniać
przy projektowaniu tych przypadków testowych.
Czyli jeszcze raz popatrzmy,
wyobraźmy sobie, że mamy tutaj pewien zakres danych,
które mogą być na wejściu podane,
no na przykład więcej niż 10,
to dzielimy to na jakieś grupy,
na przykład na 3,
bierzemy tutaj z początku tej grupy,
bierzemy ze środka tej grupy,
bierzemy z końca tej grupy.
Jeżeli to jest maksymalne,
no to bierzemy ten maksymalny przykład,
bierzemy ten przykład minimalny.
Czyli takie typowe podejście,
minimalny, maksymalny,
początek grupy, koniec grupy, środek grupy.
To są takie typowe sytuacje,
które przy projektowaniu przypadków testowych
musimy uwzględnić.
I chcę to Państwu pokazać tutaj
na takim prostym przykładzie.
Mianowicie wspomniałam już Państwu
o takiej funkcji,
której zadaniem jest
znalezienie w wektorze liczb
pewnej wartości kluczowej,
czyli podajemy jakąś wartość,
podajemy wektor liczb
i teraz chcemy,
żeby ona zwróciła nam wartość fałd,
zwróciła wartość bulowską,
czyli na przykład prawda,
jeśli nie znaleziono,
prawda, jeśli znaleziono,
fałsz, jeśli nie znaleziono.
I w przypadku, kiedy znaleziono,
żeby nam podała, na której pozycji
w tym wektorze ta liczba się znajduje.
Czyli jeżeli tutaj mamy pewien wektor liczb,
i teraz my trafiamy w pewną liczbę,
no to dostaniemy wartość true,
ta liczba tutaj się znajduje,
na przykład liczba 7,
ale chcemy też wiedzieć, w którym ona,
na której pozycji była,
czyli na przykład to jest pozycja 1, 2, 3,
powiedzmy 4 pozycja, tak,
w 4 pozycji ta liczba 7 wystąpiła.
Teraz ta prosta procedurka jest
tutaj również wyspecyfikowana
w postaci pewnych warunków wstępnych,
pewnych warunków końców.
Ten warunek wstępny mówi,
że ta tablica ma co najmniej jeden element,
czyli, że ten pierwszy indeks
tablicy tej T
jest mniejszy, równy od ostatniego,
od ostatniego indeksu,
czyli co najmniej jeden element tablica ma.
Warunek post conditions,
no to jest właśnie taki,
że dostajemy wartość true,
że znaleziono,
i wtedy na tej dostajemy również
pozycję tego elementu,
jego indeks w postaci tego L,
czyli ten L element tej tablicy
ma wartość właśnie tego klucza,
który podaliśmy jako parametr.
To jest ta sytuacja, kiedy znaleziono.
Natomiast lub,
jeżeli ten element nie istnieje w tablicy,
no to dostajemy informację,
że jest not found,
czyli found będzie miał wartość false,
i tutaj mamy warunek,
że nie istnieje taki element tej tablicy,
przeglądamy wszystkie elementy
od najmniejszego do największego,
że na tej pozycji jest ten element z klucza,
czyli to nie znaleziono
i wiemy, że nie ma tego w tablicy.
Ale uwaga!
Co wtedy by zwracała ta wartość L,
ten indeks?
Nie jest tutaj to określone, prawda?
Czyli w specyfikacji tej funkcji,
tej procedury,
nie wyspecyfikowaliśmy,
co ma być zwracane wtedy,
kiedy ten element w tym wektorze
po prostu się nie znajduje.
Można by to jakoś dołączyć do tej specyfikacji,
tutaj akurat tego nie podano,
czyli powiedzmy, że nam jest wszystko jedno,
co wtedy ta wartość L będzie zwracała,
bo i tak nie będziemy z niej korzystać.
Teraz, proszę Państwa, tak,
powiedziałam Państwu,
że musimy te dane wejściowe
podzielić na pewne klasy równoważności
i musimy również rezultaty działania tej funkcji
też podzielić na pewne klasy równoważności.
Jeśli chodzi o te dane wejściowe,
czyli tą tablicę T,
to mówiłam Państwu,
że jeżeli jest to możliwe,
to powinniśmy uwzględnić tablicę pustą.
Tutaj nie dlatego,
że było powiedziane,
że co najmniej jeden element ta tablica zawiera,
ale na pewno musimy zbadać sytuację,
kiedy jest to tablica jednoelementowa
i kiedy jest to tablica,
czyli ta tablica wieloelementowa.
Teraz, jeśli chodzi o rezultat działania tej funkcji.
A więc, po pierwsze,
tutaj mamy dwie takie sytuacje.
Liczba znajduje się w tym wektorze?
Nie, nie znajduje się.
Więc mamy sytuację pierwszą,
nie ma tego klucza w tablicy
i sytuacja druga,
jest ten klucz w tablicy.
Ale tutaj mamy,
teraz musimy uwzględnić
różne podgrupy tej sytuacji,
kiedy ten klucz w tej tablicy się znajduje.
Mówiłam Państwu,
że dla danej klasy równoważności,
wtedy, kiedy ona może zawierać wiele elementów,
to powinniśmy zawsze wziąć
pierwszy element,
ostatni element
i wewnętrzny, środkowy element.
Wobec tego w tej sytuacji,
kiedy ten klucz znajduje się w tej tablicy,
to musimy tak przygotować dane wejściowe,
by był on pierwszym elementem,
ostatnim elementem
i jakimś elementem ze środka.
No i proszę popatrzeć teraz,
z tej prosta, taka prościuteńka funkcja,
która tylko ma znaleźć wartość klucza
w pewnym wektorze,
tutaj już przy tym projektowaniu funkcjonalnym testów,
mamy, jak Państwo widzicie,
wiele przypadków testowych,
które należy sprawdzić.
Popatrzmy na konkretne wartości,
według tej właśnie kombinacji podziałów na grupy.
Czyli mamy wektor jednoelementowy.
No i teraz, tu jest przykładowy ten wektor podany
i teraz tutaj musimy dla tego wektora
rozłożyć dwie sytuacje.
Wtedy, kiedy ten klucz jest
i wtedy, kiedy tego klucza nie ma.
A więc tutaj mamy przykładowe dane wejściowe,
tak, wektor i klucz
i oczekujemy wartości true,
bo ten klucz jest
i jeśli chodzi o ten indeks zwracany,
to l zwracany, to ono ma mieć wartość 1,
bo to jest tablica jednoelementowa.
Druga sytuacja, tutaj ze względu na tą klasę równoważności
wyników tej funkcji,
kiedy nie ma tego klucza w tej tablicy,
czyli zwracana wartość found będzie false,
natomiast specyfikacja funkcji nie mówi,
co ma być wtedy l zwracane,
to jest ta nieznana wartość,
tutaj zaznaczona jest w postaci znaku zapytania.
To był przykład tablicy jednoelementowej.
Teraz musimy rozważyć tablicę wieloelementową
i tutaj również ona musi mieć dwie,
jak gdyby, podgrupy.
Jedną, kiedy ten element nie istnieje w tej tablicy,
więc tutaj widzimy taki przykład.
Mamy przykładowy wektor liczb,
mamy przykładowy klucz,
nie ma takiego klucza w tym wektorze,
zwracana wartość found powinna być false.
Jeśli chodzi o indeks tego elementu,
specyfikacja nie mówi, jaki on ma być,
więc może być zupełnie dowolny.
I mamy tutaj, proszę Państwa,
sytuację, kiedy teraz mamy wartość taką,
bierzemy klucz taki, że jest w tej tabelce,
w tym wektorze,
ale przypomnę Państwu, że zawsze bierzemy,
w przypadku z początku grupy,
z końca grupy i ze środka.
No więc popatrzmy tutaj,
mamy sytuację, kiedy to jest pierwszy element,
mamy sytuację, kiedy to jest ostatni element,
40-50 ostatnim elementem,
siódma pozycja
i mamy teraz, wyszukujemy jakąś liczbę,
która jest gdzieś ze środka tej grupy,
23 jest na pozycji czwartej.
Więc zwracam Państwu uwagę,
tutaj na tą pracochłonność testowania, prawda,
dla tak prostej specyfikacji,
mamy tutaj aż dwa, cztery,
aż sześć przypadków testowych.
Czyli jeszcze raz,
dzielimy dane wejściowe na klasy o równoważności,
dzielimy wyniki możliwe też na klasy równoważności,
czyli nawet w tym przypadku znaleziono, nie znaleziono
i jeżeli mamy do czynienia z pewną grupą,
to musimy uwzględniać w tych przypadkach testowych
sytuację, kiedy mamy element na początku grupy,
na końcu grupy i w środku
i to widzimy tutaj w przypadku wyszukiwania tej liczby
w wektorze, który ma kilka elementów.
Czy do tego może mają Państwo jakieś pytania?
Czyli może podsumowując jeszcze,
to testowanie funkcjonalne polega na przygotowaniu testów
na bazie specyfikacji tego testowanego kodu.
Ten testowany kod może być kodem małym,
tak jak tutaj widzieliśmy taką prostą procedurę
wyszukiwania liczby w wektorze,
może to być cała aplikacja.
Wtedy, jeżeli jest to cała aplikacja,
to mamy specyfikację tego, co ta aplikacja robi,
czyli musimy te testy na podstawie tej specyfikacji,
wymagań funkcjonalnych przygotować.
No i trzeba się liczyć oczywiście z pracochłonnością
takich czynności.
Mówiłam Państwu również o efektywności
tego testowania.
Jest to duża efektywność,
czyli w jednostce czasu dużo błędów w ten sposób
jesteśmy w stanie wykryć.
Oczywiście to ja Państwu tutaj pokazałam tylko przykład,
żeby zwrócić uwagę mniej więcej na to,
jak się podchodzi do takiego przygotowania
testowania funkcjonalnego.
Natomiast jest to dziedzina też dosyć rozległa.
Są też książki całe na tym,
na ten temat napisane na przykład przez Pana Bezier'a.
Coś może mają Państwo jakieś pytania, uwagi do tego?
Jeśli nie, to proszę Państwa teraz
zajmijmy się testowaniem strukturalnym,
czyli testowaniem tak zwanych white box testing,
to się nazywa po angielsku,
testowanie białych skrzynek,
przezroczystych skrzynek, szklanych skrzynek,
równie to się mówi,
ale idea jest taka,
że my mamy dostęp do kodu,
czyli mamy tutaj tą testowaną jednostkę
i wiemy w jakim języku ona jest napisana,
mamy dostęp do tego kodu
i na podstawie znajomości tego kodu
możemy przygotowywać przypadki testowe,
przygotowywać testy.
Proszę Państwa, takich metod mamy bardzo, bardzo wiele.
Można je podzielić na takie dwie grupy.
Jedna grupa to są metody testowania,
w których chodzi o pokrycie tego kodu testami,
czyli chodzi na przykład o to,
ja za chwilę pokażę przykład jednej z metod,
że przechodzimy wszystkie linie,
chcemy mieć takie testy wykonane,
żeby co najmniej raz każda linia tego kodu została wykonana
lub jakieś inne warunki,
ale generalnie chodzi o pokrycie tego kodu.
Druga grupa metod,
bo tu wszędzie i tu jest wiele metod,
i tu jest wiele metod,
to są metody, które dotyczą pokrycia danych,
a dokładniej,
data flow testing to się nazywa,
czyli pokrycia pewnego przepływu danych w tym kodzie.
Te metody są rzadziej w praktyce stosowane,
no bo nie ukrywam, że one są trudniejsze.
Do obu tych metod, żeby z tego korzystać,
potrzebne są specjalne narzędzia,
które nam będą tutaj te testy,
jak gdyby sprawdzały,
czy to pokrycie kodu,
czy to pokrycie przepływu danych zostało spełnione
i w jakim stopniu, jakie warunki.
Czyli potrzebne nam są tutaj pewne dodatkowe narzędzia.
Dobra, może zacznę od takiego pokrycia,
pokrycia jednej z metod,
która dotyczy pokrycia kodu,
bo tutaj chodzi o to pokrycie kodu,
to też możemy sobie
określić, o jakiego typu pokrycie chodzi nam.
Czyli na przykład może być to powiedzmy line coverage,
czyli na przykład takie,
aby co najmniej raz każda instrukcja,
czy każda linia tego kodu była wykonana.
Mamy pewien zestaw testów,
mamy tutaj to coś,
mamy pewne podawane na wejściu.
I to narzędzie wykonuje kolejno te testy,
pierwszy, drugi, trzeci i tak dalej.
I sobie zaznacza,
które linie kodu zostały wykonane,
zostały pokryte przez te testy.
Te narzędzia pokazują nam na przykład
ten kod nie pokryty na czerwono,
a ten, który został pokryty na zielono,
czy na czarno.
Więc na przykład patrząc na ten kod,
co nie zostało jeszcze pokryte,
my możemy sobie konstruować,
przygotowywać kolejne testy tak,
żeby pokrycie tego kodu zwiększyć.
I dostajemy w takim narzędziu
zwykle informację o tym,
że na przykład 75% kodu zostało już pokryte
w tym testowanym kawałku,
czy 80% i jeszcze raz powtarzam,
widzimy, który kod nie został pokryty,
możemy odpowiednio przygotować te testy tak,
żeby wymusić wykonanie tego kodu.
Nie zawsze się da to doprowadzić
do stuprocentowego pokrycia kodu,
dlatego że często ten kod dotyczy
oprogramowania pewnych sytuacji wyjątkowych,
które nie zawsze jesteśmy w stanie wymusić.
Czyli to jest jedna z grup takich metod,
metody, które dotyczą
jakiejś pokrycie instrukcji, które tutaj są.
Druga grupa takich metod to może dotyczyć
pokrycia warunków,
czyli tutaj mamy pewne rozejścia warunkowe,
jeśli true to coś, jeśli false to coś innego
i będziemy chcieli, żeby oba te przejścia
zostały przynajmniej raz wykonane,
czyli żebyśmy sprawdzili,
czy tutaj ten warunek działa
i czy jedna droga i druga droga da się wykonać.
Więc czasem dążymy do tego,
żeby wszystkie warunki,
te rozejścia decyzyjne były pokryte.
Zwykle chodzi nam o to,
ponieważ znowu chodzi o to,
żeby jak najmniej wykonać,
a jednocześnie mieć pewną ufność do tego,
że to testowanie zostało solidnie wykonane,
no to zwykle wystarczy nam,
żeby co najmniej raz taki warunek był spełniony
i co najmniej raz był niespełniony.
Możemy żądać tutaj,
wykonania pewnych konkretnych ścieżek,
możemy tutaj jak gdyby wymuszać
wykonanie określonych bloków instrukcji
czy określonych funkcji.
Także tych metod jest tutaj bardzo, bardzo dużo.
Wspominałam o tym,
że potrzebujemy przy tym testowaniu,
potrzebujemy pewnych narzędzi,
potrzebujemy takich analizatorów,
które dla danego testu pokażą nam,
które instrukcje,
czy które rozejścia warunkowe były wykonane,
pokażą nam ten kod niepokryty
i dają nam informację sumaryczną o tym,
dla danego zbioru testów,
jakie jest sumaryczne pokrycie,
ile procent tego kodu zostało wykonane.
Znowu jeszcze raz wspominam po raz kolejny o tym,
że niemożliwe jest testowanie absolutnie powszechne,
testowanie absolutnie wszystkich ścieżek, prawda?
My możemy wymusić wykonanie pewnych ścieżek,
ale pewna kombinacja tych ścieżek
i tutaj przy wykonaniu tych różnych ścieżek
ten kod może nie wykazywać już błędów,
ale potem w trakcie pracy tego programu
jakaś pewna inna kombinacja tych ścieżek,
no nie testowana przez nas,
bo wszystkich nie jesteśmy w stanie
przetestować, może jednak wykonać pewien błąd,
także nie wykazać pewien błąd.
Także nie mamy tutaj gwarancji,
że ten testowany kod jest kodem bezbłędnym.
Mamy tutaj tylko informacje takie,
że dla takiego i takiego pokrycia kodu,
dla pokrycia takich, a nie innych ścieżek
już błędy nie zostały wykrywane,
nie są wykrywane.
Proszę Państwa, te analizatory kodu właśnie,
i również tutaj niektóre z tych narzędzi
nam troszkę jak gdyby pomagają
w przygotowaniu tych przypadków testowych,
one zazwyczaj działają w oparciu
o graf przepływu sterowania,
czyli wiedząc w jakim języku
mamy ten program napisany,
są takie narzędzia dla języka C,
dla języka C++,
no to one sobie tworzą taki graf przepływu sterowania,
tak?
W zależności od tego, jakie instrukcje
żeśmy w tym kodzie zamieścili
i potem przy wykonywaniu tych testów,
prawda, sobie znakują, że na przykład
tędy, tędy żeśmy przeszli, tak?
Widzimy i pokazują nam,
a, taka gałąź, czyli ten warunek decyzyjny,
tu jest na przykład prawda,
a tutaj jest fałsz,
to dlatego fałszu tutaj te ścieżki
nie zostały pokryte,
więc możemy wtedy zmienić parametry tego testu,
tak?
Żeby wymusić przejście tą inną ścieżką.
Ja chcę Państwu teraz pokazać
znowu jedną z możliwych metod.
Po raz kolejny podkreślam,
że to jest bardzo, bardzo szeroka dziedzina.
Ja chcę pokazać Państwu taką metodę,
która polega na testowaniu zbioru ścieżek mięśni,
zbioru ścieżek niezależnych.
Dlaczego?
Dlatego, że tutaj, jak Państwo za chwilę zobaczycie,
wykonanie takiego testowania tych ścieżek niezależnych,
no, powoduje, że mamy wszystkie warunki
sprawdzone dla prawdy i dla fałszu
i że co najmniej raz
każda instrukcja w programie została wykonana,
więc jest to dosyć, no, powiedzmy,
dużą ufność mamy do takiego zbioru testu.
Tutaj przy tworzeniu tych zbiorów,
tych ścieżek niezależnych,
no, zaczynamy od pewnej ścieżki
i dodajemy kolejne ścieżki do niej,
takie, żeby co najmniej jedna nowa krawędź
tego grafu przepływu sterowania została dodana.
Za chwileczkę Państwu pokażę na konkretnym przykładzie,
jak to działa.
No, teraz dla nas istotne jest,
ile mamy tych ścieżek wygenerować, prawda,
czy to, no, robią nam to znowu takie narzędzia,
ale powinniśmy wiedzieć, prawda,
czego to się spodziewać.
Otóż ta liczba tych ścieżek niezależnych
wynika ze złożoności cyklomatycznej
tego grafu przepływu sterowania.
Tą złożoność cyklomatyczną nazywa się inaczej
złożonością McCabe'a
i ta cyclomatic complexity to się oznacza,
literkami dużymi CC,
taka złożoność cyclomatic complexity
pewnego grafu G,
to jest to liczba krawędzi tego grafu
minus liczba węzłów plus 2.
To jest wzór na tą złożoność cyklomatyczną,
a inaczej to, jak gdyby przechodząc teraz
na język programowania,
to to jest po prostu liczba prostych warunków
w tym, jeżeli mamy program bez instrukcji GoTo,
w tym testowaniu,
że w tym testowanym fragmencie kodu plus 1.
I tak jak Państwu powiedziałam,
no wykonanie takiego zbioru ścieżek niezależnych
pozwoli nam na zbadanie wszystkich warunków
dla prawdy i dla fałszu
i co najmniej raz każda instrukcja
w programie zostanie wykonana.
A więc jest to dosyć dużą ufność mamy
do takiego zbioru testów.
I popatrzmy proszę Państwa tutaj na przykład.
Tak jak Państwu powiedziałam,
przy tych metodach pokrycia kodu
te narzędzia, te analizatory kodu
bazują na grafie przepływu sterowania.
Więc wyobraźmy sobie,
że tutaj mamy, testujemy pewien kod,
tutaj przy tym testowaniu strukturalnym
ten testowany kod,
no nie może być kodem zbyt dużym,
czyli nie jest to cała aplikacja,
ale jest to na przykład pewna funkcja,
pewna procedura czy metoda.
Małe fragmenty kodu w ten sposób są testowane.
Dlaczego? To za chwileczkę Państwo zobaczycie.
Wynika to z liczby testów, które tutaj są.
Więc wyobraźmy sobie, że to jest nasz węzeł startowy,
tutaj oznaczony jako 1
i to jest nasz węzeł końcowy, tak?
Czyli to jest koniec,
a to jest tutaj start,
jest w węźle pierwszym.
I tutaj takimi na przykład mamy tutaj
pewne rozejście warunkowe, tak?
Na przykład wyobraźmy sobie,
że to jest true, a tu jest false, tak?
Na przykład taką konwencję przyjmuję,
czyli powiedzmy if pewien warunek
tutaj w węźle jest zapisany,
jeżeli jest on prawdziwy, to idę tu,
w przypadku innym idę tu,
tu znowu widzimy jakieś rozejścia warunkowe,
true, false i tak dalej.
Czyli mamy graf przepływu sterowania,
dla pewnego kodu,
który takie narzędzie jest w stanie przygotować.
Tutaj jeżeli mamy pewną sekwencję instrukcji,
nie ma rozejść, to ta sekwencja tutaj,
te bloki instrukcji są właśnie
na przykład w tym bloku czwartym,
w bloku szóstym, ósmym, prawda,
czy dziewiątym, takimi blokami mamy to oznaczone.
I ścieżka to będzie, proszę Państwa,
właśnie startujemy w tym węźle,
startujemy w tym węźle początkowym,
w tym węźle oznaczonym jako S
i naszym celem będzie dojście do węzła końcowego,
czyli do tego węzła, tutaj w tym przypadku
ta trzynastka jest tym węzłem końcowym.
No więc przygotowuje nam takie narzędzie,
zwykle nam generuje te ścieżki,
ale popatrzmy jaka jest idea generacji tych ścieżek,
czyli zaczynam zawsze w węźle startowym,
kończę w węźle końcowym
i idę jeden, dwa, tak,
teraz pójdę tutaj, momencik,
ja wymarzę wszystkie znaki jakie mam tutaj,
będę na nowo tutaj teraz coś wprowadzać
i zaznaczam jak przejdę, tak, kropeczką,
tu już byłam, teraz jestem w bloku
tutaj tym dwójki i idę tutaj, tak,
wchodzę do bloku dwanaście, tak,
i przechodzę do bloku trzynaście,
czyli mam tutaj jeden, dwa, dwanaście, trzynaście,
mam taką najkrótszą ścieżkę pokazaną.
Teraz kolejną ścieżkę, moim celem jest
zbadanie wszystkich warunków dla prawdy i dla fałszu,
czyli jeżeli tu zbadałam ten warunek,
na przykład dla prawdy,
to teraz muszę zbadać ten warunek,
na przykład dla fałszu,
czyli idę jeden, dwa, teraz trzy, tak,
trzy znowu jest jak widzimy rozejściem warunkowym,
więc na przykład decyduję się
jak pójście tutaj w kierunku tego warunku true,
przechodzę do czwórki i znowu idę do trzynastki,
więc cztery, dwanaście, trzynaście.
Mam tutaj, widzicie Państwo,
że w stosunku ten zbiór ścieżek niezależnych
ścieżki muszą się różnić,
no przynajmniej jedną nową ścieżką,
nową krawędzią, widzimy, że tutaj zostały
dwie nowe krawędzie dodane, prawda,
trzy i cztery.
I teraz kolejną ścieżkę.
W trójce byłam na przykład dla prawdy,
poszłam do czwórki,
no to teraz idę w przeciwnym kierunku,
do piątki, tak, tutaj.
Piątka jest znowu rozejściem decyzyjnym,
powiedzmy, że zaczynam szóstka, tak,
jedenastka, wracam do dwójki
i teraz z dwójki już, żeby było szybciej,
idę dwanaście, trzynaście.
Dwójka, dwanaście, trzynaście,
czyli widzicie Państwo, znowu nowe krawędzie
tutaj doszły, doszła krawędź pięć, sześć, jedenaście.
Wracam do budowania kolejnych ścieżek niezależnych.
Warunek w piątce był sprawdzony dla trup,
no to teraz muszę go sprawdzić dla foc,
czyli muszę teraz pójść z piątki do siódemki.
Siódemka jest znowu węzłem decyzyjnym,
więc powiedzmy rozejściem decyzyjnym
idę do ósemki, tak,
idę do dziesiątki,
z dziesiątki idę do jedenastki
i wracam dwójka, dwanaście,
dwanaście, trzynaście
i kolejna ścieżka, kolejne węzły dodane.
No i został nam jeszcze tutaj z siódemki do dziesiątki,
widzimy, że te krawędzie siedem, dziewięć, dziewięć, dziesięć
są niepokryte, więc teraz dodaję, prawda,
te przejścia, dziewięć, dziesięć, tu, tak,
i proszę popatrzeć teraz, patrząc na ten graf,
widzimy, że każdy z tych warunków
był wykonany zarówno dla prawdy,
jak i dla fałszu
i widzimy, że no wszystkie,
przez wszystkie bloki instrukcji też
żeśmy przeszli,
czyli no będzie dosyć duża ufność
do tego testowanego kodu,
jeżeli on już nie będzie wykrywał błędów,
dlatego, że będziemy mieli właśnie
co najmniej raz wykonaną każdą instrukcję.
Proszę Państwa, tak, takie narzędzie,
taki analizator kodu, tak,
on nam może takie ścieżki wygenerować.
Tutaj są pewne konstrukcje programowe
i teraz naszym zadaniem będzie,
no tak dobranie, jeśli to jest pewna funkcja, prawda,
i ona ma jakieś tutaj parametry,
to będzie dobranie tak tych wartości parametrów,
żeby wymusić wykonanie określonej ścieżki.
I tutaj no potrzebny już jest człowiek,
potrzebna jest jego wiedza, jego umiejętności,
żeby to, prawda, wykonać.
Więc albo możemy właśnie działać w ten sposób,
że narzędzie generuje nam te ścieżki niezależne,
a my tutaj teraz wiedząc,
co jest w tych rozejściach decyzyjnych,
tak przygotowujemy te parametry wywołania,
żeby wymusić taką ścieżkę.
Inne podejście to jest podejście takie,
że no, prawda, nam tutaj wykonujemy jakiś test,
który żeśmy sobie przygotowywali,
on nam pokaże, które z tych węzłów zostały pokryte,
które z tych ścieżek zostały pokryte
i my będziemy próbować jeszcze dodać nowe przykłady testów,
żeby przez te niepokryte ścieżki,
czyli pokaże nam na przykład te pierwsze trzy, żeśmy przeszli,
tak, no to musimy dodać zbiory testów,
żeby przez kolejne ścieżki,
czwartą i piątą też przejść.
Czy mają Państwo do tego jakieś pytania?
To jest też, proszę Państwa,
dobry temat na zadanie na egzamin,
żebyście Państwo właśnie, nie wiem,
podali, wygenerowali taki zbiór ścieżek
niezależnych dla konkretnego grafu.
Czy są może jakieś pytania?
Do tego...
Nie słyszę, nie widzę,
więc zakładam, że wszyscy wiedzą, co tutaj się działo
i będą potrafili, będziecie Państwo potrafili
takie ścieżki niezależne utworzyć, wygenerować.
Właśnie, powiedziałam Państwu,
że wykonanie zbioru ścieżek niezależnych
daje nam wykonanie rozejść warunkowych
dla prawdy i dla fałszu
i co najmniej raz każda instrukcja będzie wykonana.
Niektóre z instrukcji będą wykonane wielokrotnie, prawda,
ale co najmniej raz na pewno.
O liczbie ścieżek niezależnych już mówiłam,
że jest to złożoność cyklomatyczna
tego grafu przepływu sterowania.
Liczba krawędzi minus liczba węzłów plus 2.
Mówiłam Państwu, inny wzór również,
przepraszam, bo tu nie poszłam w tą stronę, co trzeba,
że to jest liczba warunków prostych plus 1,
więc jak sobie tutaj popatrzymy,
gdzie mamy warunki proste, tak, ile mamy?
No to warunek mamy tu raz, dwa,
trzy, cztery, tak?
Cztery warunki mamy, cztery rozejścia decyzyjne mamy,
cztery warunki, cztery plus jeden
i widzicie Państwo, mam pięć ścieżek niezależnych,
bo jest to liczba tych rozejść prostych warunków,
rozejść prostych warunków decyzyjnych plus jeden.
Właśnie, tak jak Państwu mówiłam,
no potrzebny jest człowiek, żeby te przykłady testów przygotował
dla no ścieżek, które narzędzie nam może podpowiedzieć, jak jest
i no daje nam tutaj to, prawda, informację,
że każdy warunek był sprawdzony dla prawdy i dla fałszu
i każda instrukcja co najmniej raz wykonana,
ale wcale to nie znaczy, że ten program
już jest na pewno bezbłędny,
dlatego, że przy pewnej określonej kombinacji ścieżek
mogą się ujawnić błędy, których tutaj żeśmy nie wykryli.
Proszę Państwa, teraz chcę Państwu powiedzieć
o drugiej takiej grupie metod,
która się nazywa data flow testing
i to jest,
to są metody, znowu grupa metod,
które są oparte o pokrycie przepływu danych.
Czym my się tutaj interesujemy przy tym przepływie danych?
Mianowicie interesują nas miejsca,
w których pewna dana, no na przykład dana X,
jest definiowana, co znaczy definiowana,
na przykład ustawiana jest jej wartość, tak,
powiedzmy w I tej linii programu.
I interesują nas użycia tej danej
w jakimś innym, na przykład w J tej linii programu.
Czyli będą, interesują nas pary,
które się nazywa def use,
definicja użycia dla pewnej zmiennej
i podaje się to podając no właśnie numery linii,
w których ona jest zdefiniowana i w których jest używana.
Oczywiście dla danej zmiennej,
takich par definicja użycie,
może być bardzo, bardzo wiele.
Teraz też będziemy się no zajmować
takimi wykonaniami programu,
że między podstawieniem tej zmiennej w I tym węźle,
czy w I tej linii programu,
a użyciem tej zmiennej w J tym węźle,
nie występuje żadne inne podstawienie,
żadna inna definicja tej zmiennej.
Czyli to jest od momentu definicji
do pierwszego użycia tej zmiennej.
Wcześniej tutaj nie ma żadnych nowych definicji tej zmiennej.
Takie pary def use będą nas interesowały.
Znowu, wiedząc w jakim języku jest ten program napisany,
też taki analizator jest w stanie nam takie pary definicja użycia,
dla konkretnej zmiennej z naszego programu.
Na przykład dla zmiennej A, czy B, czy C może nam to podać.
Popatrzmy proszę Państwa na taki przykład prosty.
Mamy tutaj pewien bardzo prosty kod.
Jakaś funkcja, parametr A.
Tutaj mamy wprowadzoną wartość tej funkcji,
wprowadzoną wartość na zmienną B.
Bierzemy zmienną A,
używamy ją jako taki parametr tutaj cyklu
i tutaj odbywa się pewne podstawienie tej nowej,
ustawienie nowej wartości B.
I teraz popatrzmy, mamy tutaj podane numery linii,
bo tak często właśnie to się robi, te pary def use.
I popatrzmy, w linii zerowej,
w linii zerowej można powiedzieć,
że mamy pewną definicję zmiennej A.
I teraz ta zmienna A,
na przykład jest użyta w linii drugiej.
Więc proszę popatrzeć, linia zerowa,
zmienna A, użycie jest w linii drugiej.
Mamy taką parę, definicję użycia,
tutaj A para 0,2.
Ale możemy mieć też, proszę popatrzeć,
taką parę, na przykład ona jest tu zdefiniowana,
w linii zerowej,
A jest użyta, linię drugą żeśmy tutaj wykorzystali,
ale zmienna A jest użyta w linii trzeciej.
Wobec tego para 0,3,
to jest też para ze względu na zmienną A.
Zdefiniowana w zerowej, używana w linii trzeciej.
Ale popatrzmy teraz na zmienną B.
Ona jest zdefiniowana tutaj, bo jest podstawiona,
podstawiona z wejścia w linii pierwszej.
I teraz ta zmienna B jest użyta w linii trzeciej.
Jest użyta w linii trzeciej,
więc mam tutaj ten przejście i mam tą 1,3,
to jest dla zmiennej B.
Widzimy, że jest.
Ale teraz, gdyby tutaj dalej był ten kod,
to widzimy, że teraz tutaj mogą dojść nowe pary.
Że w linii trzeciej zmienna B jest zdefiniowana
i dalej będziemy gdzieś tam szukać kolejnego użycia tej zmiennej.
Czyli właśnie takie narzędzie na podstawie analizy naszego kodu
jest w stanie nam wykryć takie pary, definicję użycia,
ale tutaj znowu naszym zadaniem będzie wymuszenie takiego przejścia,
takiego użycia, tego przepływu tych danych.
Mamy tutaj, jeśli chodzi o to testowanie data flow testing,
tego pokrycia przepływu danych,
to mamy bardzo różnorodne kryteria testowania.
Czyli na przykład może nam chodzić o wykonanie wszystkich par definicję użycia.
No i teraz będziemy znowu, czy dla wszystkich zmiennych,
czy tylko dla pewnych wybranych.
No tutaj w tym naszym przykładzie, prawda,
takie pary dla wszystkich zmiennych,
no to są na przykład właśnie te, które tutaj zostały wykryte.
Czyli all deaf uses parts coverage, tak to się nazywa.
Może być również takie kryterium,
że dla każdej definicji, dla każdego przypisania wartości zmiennej
ma być wykonanie co najmniej jednej pary.
Czyli na przykład powiedzmy dla każdej definicji zmiennej A
wykonanie jednej pary,
i dla definicji B wykonanie też jednej pary.
Możemy również tutaj mieć jako kryterium,
możemy mieć wykonanie wszystkich par,
gdzie to użycie tej zmiennej jest w wyrażeniu warunkowym.
No to u nas to wyrażenie warunkowe, prawda,
jest tutaj w tej linii drugiej.
Wobec tego właśnie taka para 02 mogłaby być tutaj,
jak gdyby pokrycie tej pary mogłoby być,
w naszym jak gdyby zakresie zainteresowań.
Tych kryteriów jest bardzo, bardzo dużo.
Jest bardzo rozległa taka teoria dotycząca tych pokryć danych.
Wiadomo, które w których są,
bo to zostało udowadnione i jest opisane w literaturze przez badaczy.
Wiadomo, które pary w których się zawierają,
więc jak gdyby korzystają,
korzystając z tej wiedzy, z tej teorii,
można tutaj wybierać pewne kryteria takie testowania,
które dają nam znowu dosyć dużą ufność co do testowanego kodu,
a jednocześnie nie tak dużo tych testów wykonujemy.
Właśnie.
Narzędzie może te pary wybrać,
natomiast my będziemy musieli podać testy dla tych ścieżek.
Tu możemy wybierać, które kryteria pokrycia będziemy chcieli stosować
i musimy dla nich te testy przygotować.
Drugie podejście to jest takie, że podajemy pewne testy,
wykonujemy pewne testy,
i to narzędzie po prostu nam mówi,
które pary zostały pokryte, a które nie.
Proszę Państwa, no to jak widzicie jest troszkę trudniejsza metoda,
trudniej się jej nauczyć.
Też potrzebne są takie narzędzia,
które do języków programowania pozwalają nam to testowanie,
właśnie wspomagają nam to testowanie,
ale tutaj sama ta część teoretyczna jest znacznie trudniejsza,
niż przy tych metodach testowania, które poprzednio Państwu pokazałam.
Natomiast jest właśnie dosyć duża trudność stosowania tej metody,
stąd te metody w praktyce nie są zbyt często stosowane,
właśnie ze względu na ten poziom trudności i wiedzę,
którą tester stosujący tę metodę powinien posiadać.
Natomiast proszę Państwa,
no nawet ja kiedyś ileś lat temu napisałam taki artykuł,
można wykazać, że pewne typy błędów będą wykryte przy tym testowaniu właśnie,
a nie będą wykryte ani przy testowaniu funkcjonalnym,
testowaniu czarnych skrzynek,
ani przy testowaniu na przykład tą metodą ścieżek niezależnych.
Czyli są pewne typy błędów,
które no jak gdyby w tym typie testowania wyjdą,
będą możliwe do zaobserwowania,
a nie wychodzą one przy innych typach testowania.
Ale tak jak podkreślam, jest to metoda trudna,
w przemyśle rzadko stosowana,
no właśnie ze względu na wiedzę,
jaką tutaj testerzy powinni posiadać i której zazwyczaj nie mają.
Czy do tego co mówiłam mają Państwo jakieś pytania, uwagi?
Jeżeli nie, to teraz proszę Państwa ja mam pytanie,
czy przeciągnąć troszkę tą pierwszą część wykładu
i skończyć tą prezentację,
czy robimy przerwę teraz?
Jakie Państwo mają potrzeby?
Potrzeby i co wolicie?
Może przeciągnąć.
Jeszcze raz?
Bo nie słyszałam.
Może przeciągnąć.
Przeciągnąć.
Dobra. Czy pozostali Państwo się zgadzacie,
żeby dojść do końca?
To parę minut jeszcze mi zajmie,
ale chyba tego już nie ma dużo.
Tak.
Tak? Dobra.
To tak zrobimy, a potem przerwę zrobimy normalnej długości.
Proszę Państwa, teraz troszkę chcę powiedzieć,
to jest bardzo, bardzo rozległa dziedzina,
testowanie obiektowe.
I ja tutaj chcę jedynie zasygnalizować pewne rzeczy,
no pewne rzeczy już troszkę,
jak gdyby widzieliście Państwo z tego,
co dzisiaj opowiadałem na początku.
No testowanie czujemy, prawda,
że jest to taki proces niezwykle wymagający,
dużego wysiłku, dużych nakładów pracy.
No przy systemach obiektowych tym bardziej.
Bo właśnie przy testowaniu systemów obiektowych
musimy to testowanie prowadzić na różnych poziomach.
Czyli na przykład, jeśli chodzi o,
mamy, prawda, obiekt, mamy operacje,
które ten obiekt wykonuje.
Musimy testować te operacje.
W przypadku, jeśli chodzi o te operacje,
to można stosować testy funkcjonalne,
tak jak Państwu dzisiaj pokazywałam,
czyli właśnie te dane wejściowe,
rezultaty dzielić na grupy,
przygotowywać przypadki testowe.
Można stosować testowanie strukturalne
do testowania operacji.
Którąś z tych metod, które Państwu podałam,
zwykle stosuje się te metody pokrycia kodu,
bo one są łatwiejsze.
Ale bardzo dobry efekt daje nam również
testowanie data flow testing,
czyli pokrycie przepływu danych.
Po przetestowaniu operacji,
no mamy kwestię testowania obiektów.
Tutaj, prawda, nie tak dawno mówiliśmy
o diagramie maszyn stanowych dla klasy,
czyli o pewnym projekcie zachowania
tego obiektu w tej klasy.
I to zachowanie obiektów tej klasy
też trzeba przetestować właśnie,
jak gdyby te przejścia ze stanów.
Czyli to jest jak gdyby te pierwsze poziomy,
to jest najpierw testowanie operacji,
potem testowanie obiektu,
każdego z obiektów niezależnie tak,
żeby na przykład sprawdzać,
czy rzeczywiście te stany są dla niego osiągalne
i czy te przejścia pomiędzy stanami są właściwe.
Dalej możemy przejść do testowania
pewnych takich tzw. clusters obiektów,
czy pewnych zbiorów, gron tych obiektów,
które ze sobą współpracują.
One, prawda, te współpracujące obiekty,
to znowu mając projekt WML-u widzimy,
które to są, przeglądając na przykład
diagramy sekwencji czy diagramy komunikacji.
No i na samym końcu to jest testowanie
całego tego systemu obiektowego
pod względem wymagań funkcjonalnych i niefunkcjonalnych.
To już jest to testowanie tych czarnych skrzynek
całego systemu.
Czyli, jeszcze raz, testowanie w izolacji.
Zaczynamy zwykle z poszczególnych operacji.
Potem ciągi wykonań operacji dla danej klasy.
Jeżeli klasa ma atrybuty,
no to właśnie czy działają te operacje
ustawiania sięgania do wartości atrybutów.
Mamy różne,
typy operacji.
Mamy operacje, które pozwalają na dostęp do obiektu,
na modyfikację, na inicjalizację atrybutów.
Wszystkie te operacje, prawda, trzeba sprawdzić
i użycie obiektu we wszystkich możliwych stanach.
Na podstawie diagramu zmian stanów.
Czyli znowu widzimy tutaj ogromny nakład pracy,
który jest potrzebny.
Dalej, proszę Państwa, no wiemy, że w projekcie obiektowym, tak?
Mamy często klasy, które dziedziczą po innych klasach.
Mamy klasy zaprzyjaźnione ze sobą,
więc to też wszystko trzeba testować.
To już jest ten etap testowania tych takich klastrów,
czy grup obiektów, które ze sobą w jakiś sposób współpracują,
czy są zależne.
Czyli jeśli mamy hierarchię klas,
no to musimy te operacje odziedziczone przetestować.
Mamy funkcje wirtualne dla klasy bazowej i klas potomnych.
Przy dziedziczeniu wielopoziomowym te poszczególne poziomy
też trzeba przetestować.
No, jeszcze większy problem jest przy dziedziczeniu wielobazowym,
które w niektórych językach programowania jest dostępne.
Popatrzmy tutaj na prosty przykład.
Mamy klasę A, tak?
Po której dziedziczy klasa B?
Mamy tutaj jakieś operacje, które są właśnie w tych klasach.
No i teraz tutaj w tej klasie B,
bo to jest nasz, jak gdyby, punkt zainteresowania,
być może tu są jakieś atrybuty,
niektóre z nich mogą być dziedziczone,
więc trzeba sprawdzić na przykład,
czy te atrybuty z klasy A tutaj dostępne w klasie B, tak?
Trzeba jakoś, czy ich ustawianie jest możliwe,
czy sięganie do ich wartości jest możliwe.
Mamy tutaj metody tej klasy, operacje tej klasy,
więc mogą one podlegać testowaniu strukturalnemu czy funkcjonalnemu.
Teraz metoda A jest metodą odziedziczoną,
więc też trzeba ją przetestować,
ale w kontekście obiektów tej klasy B.
Metoda A2 w kontekście tej tutaj widzimy,
ona jest, prawda, przykryta swoją własną realizacją,
więc też trzeba sprawdzić, czy to, prawda,
czy to jest, no, właściwie działa.
No i teraz wiemy, że również być może
obiekty tej klasy B mogą być w różnych stanach,
więc też trzeba przetestować tę możliwość osiągania
poszczególnych stanów przejścia pomiędzy stanami w tej klasie.
Dalej, no, tak jak Państwu mówiłam,
zaczynamy te obiekty już przetestowane w izolacji
składać w pewne klastry, w pewne grupy
i tutaj bardzo nam się przydają właśnie diagramy sekwencji,
diagramy współpracy.
Diagramy sekwencji wręcz pokazują nam,
jaki fragment kodu, jak ten fragment kodu powinien być wykonany,
jak to przekazywanie tych komunikatów,
działa ze sobą czy nie.
No i również tutaj reakcje na pewne zdarzenia wejściowe,
które mogą mieć miejsce, też powinny być przetestowane.
Tutaj, proszę Państwa, te modele projektowe,
czyli model właśnie, diagramy sekwencji,
diagramy maszyn stanowych, to są modele,
które przy testowaniu systemu powinny i są wykorzystywane,
czyli mamy jakiś diagram sekwencji,
ale trzeba wykonać po prostu to, czy to rzeczywiście się wykonuje,
tak jak żeśmy to zaprojektowali.
Tutaj, proszę Państwa, takie troszkę przypomnienie pewnych symboli notacyjnych
i jednocześnie troszkę uporządkowanie pewnych rzeczy,
o których mówiłam dzisiaj czy mówiłam na poprzednim wykładzie.
Czyli, no zacznę może od tego, że musimy plan testów przygotować, prawda?
I co to jest plan testów?
To jest zbiór pewnych test case'ów.
A te test case'y, co to jest?
No to są pewne dane wejściowe, które musimy wykonać.
Z tym przypadkiem testowym wiążą się również pewne wyjścia,
które ten test realizuje.
Do wykonywania zbioru tych testów musimy się wspomagać jakimiś narzędziami,
i często mamy test, możliwość zapisania testu w postaci takiego skryptu,
czyli właśnie taki skrypt opisuje test, który ma być realizowany,
co podać na wyjściu, jaki jest oczekiwany rezultat, tak zwany orakr,
i wtedy możemy te testy automatycznie wykonywać, prawda?
Lub, no możemy również manualnie.
Tutaj zwracam uwagę, że również, no, możemy też wykonywać testy automatycznie, prawda?
No, możemy również manualnie. Tutaj zwracam uwagę, że również, no, możemy też wykonywać testy automatycznie, prawda?
No, mamy też testy wykonywane manualnie.
Mogą być nagrywane przez takie narzędzia typu Capture and Replay
i potem mogą być ponownie, nawet wielokrotnie wykonywane.
Właśnie wspomniałam dzisiaj, proszę Państwa, wielokrotnie,
że do testowania potrzebne nam są narzędzia
i mamy różne typy takich narzędzi.
Mamy właśnie narzędzia, które na takim niskim poziomie jednostkowym
nam pozwalają ten kod testować, na przykład JUnit.
I one są niezbędne do rozwoju, do produkcji oprogramowania.
Teraz z modeli mogą być generowane pewne skrypty testujące.
Wspominałam o tym, że jeżeli na przykład ręcznie testujemy pewną aplikację,
to przebieg tego, jak uszamy myszką, jak wybieramy pewne elementy z menu,
to może być przez takie narzędzie Capture and Replay, no Capture właśnie przechwycone.
Na tej podstawie to narzędzie przygotowuje taki skrypt i potem możemy te testy powtarzać.
Bo przypomnę Państwu,
że my te testy musimy wykonywać wielokrotnie.
Na poprzednim wykładzie mówiłam Państwu, że jak dodajemy,
mamy na przykład już jakiś fragment systemu przetestowany,
ale dochodzi nowy element do tego, to musimy wszystkie zbiory testów powtórzyć,
a nie tylko te testy, które związane są z tą nową, dodaną jednostką.
Stąd potrzebne są narzędzia do automatyzacji tego procesu testowania,
właśnie zawierające te bazy tych skryptów.
Więc to wręcz takie narzędzia.
Teraz, proszę Państwa, wspominałam na poprzednich zajęciach,
że są również takie testowania, tak zwane stress testing, prawda?
Czyli, że zwiększamy obciążenie tego testowanej jednostki
i sprawdzamy, jak ona się zachowuje przy znacznie zwiększonym obciążeniu,
więc ona zwykle działa w ten sposób, że po prostu wykonuje,
ma te testy na przykład przechwycone, czy nagrane, czy przygotowane przez testerów
i po prostu te testy zwielokrotnia, zwiększając obciążenie tej testowanej jednostki,
żeby zaobserwować, jak ona się zachowuje w przypadku istotnego zwiększenia obciążenia.
A więc, no...
Bardzo, bardzo są potrzebne te narzędzia w procesie testowania.
W Państwa szkole jest cały zbiór takich narzędzi,
który jest dostępny w tych właśnie takich, tak zwanego, bandu.
Ja w trakcie wykładu korzystałam z Rational Software Architecta
i, jak gdyby, do niego jest dołączony również
takie narzędzia testujące Functional Tester i jeszcze inne.
To by było, proszę Państwa, no, w pewnym skrócie, jeśli chodzi o kwestie testowania.
Jeszcze raz zwracam uwagę, że kwestia testowania jest kwestią...
No, niezwykle ważną i...
Zatrzymam już udostępnianie.
Zatrzymam również nagrywanie.
---------------------------------------------Dobra, proszę Państwa, jestem z powrotem i wracamy teraz do dalszej części wykładu, czy no zajęć.
Otóż, proszę Państwa, tak, ja mówiłam już kiedyś Państwu, że jest udostępniony w UBI taki plik, który się nazywa zadania. Pierwsze pytanie, czy mnie Państwo słyszycie? Ktoś jest obecny, potwierdzi?
Tak, słyszymy.
Super, dzięki. Otóż, proszę Państwa, ten plik zadania, w którego, no właśnie, takie różne przykładowe zadania są zgromadzone.
Więc w szczególności, na przykład, chcę Państwu pokazać teraz zadanie do tego materiału, którego przed chwileczką żeśmy się uczyli.
Zadanie to wygląda tak. Operacja EXECUTE, tutaj widzimy ma dwa parametry N i Y, posiada specyfikację w postaci diagramu czynności, czyli takiego diagramu x.
Zaproponować taki minimalny zestaw danych testowych, żeby pokryć wszystkie liniowo niezależne ścieżki dla danej operacji, określić te ścieżki.
Proszę popatrzeć.
Tutaj mamy właśnie ten diagram, czyli, no właśnie, widzimy, że EXECUTE ma dwa parametry N i Y, węzeł początkowy, węzeł końcowy, no i ścieżki niezależne, które mamy pokryć.
Ile tych ścieżek niezależnych tutaj powinno być?
Ile tu mamy rozejść decyzyjnych?
Dwa rozejścia, więc trzy ścieżki.
Dobra, dwa rozejścia, czyli trzy ścieżki. Czyli musimy wymusić tak tutaj, no, zbiorem danych, żeby pierwsza ścieżka, zaczynamy od START, OPEN COLLECTION, to potem idziemy tędy, do CLOSED COLLECTION i tutaj musi być parametr tam, prawda, X mniejsze, równe od zera.
Teraz druga ścieżka, to idziemy tędy, tędy, tędy.
Tak, tu mamy rozejście decyzyjne, znowu, tutaj mamy jakieś I, jakiś Y i wracamy i tak dalej.
Więc trzeba wyznaczyć te ścieżki, no i potem podać jeszcze jakieś tam wartości takie, żeby wywołania tych, wywołania tej funkcji EXECUTE z parametrami, czy pewne dodatkowe dane, żeby właśnie konkretna ścieżka była pokryta.
Tak.
Tak.
Tak.
Tak.
Tak.
Tak.
Tak.
Tak.
Tak.
Tak.
Tak.
Tak.
Tak.
Tak.
Tak.
Tak.
Tak.
Tak.
Tak.
Tak.
Tak.
Tak.
Tak.
Tak.
Tak.
Tak.
Tak.
Tak.
Tak.
Tak.
Tak.
Tak.
Tak.
Dobra, to to na razie schowam i teraz proszę Państwa przechodzę do kolejnych materiałów wykładowych.
Mianowicie chcę teraz troszkę opowiedzieć o miarach, które są w tym odcinku, które są w tym odcinku, które są w tym odcinku.
Chcemy powiedzieć, że między przeciwnikami podjęły ons 실� puck i Williams.
Nadใcym mówiłem, że delivering quality
wyrzuca w Messengerczku.
Systemy późno wybrane jeżeli, takie jakimś rozumiem, przy niektórych z面.
Weird sentence, gösterazzu.
Wciąż do tego ciągle myślałam.
ewoluowały w zmiar sprzętowych.
No tutaj troszkę jest inna specyfika,
dlatego że jeśli mamy błąd jakiś w sprzęcie,
no to on po prostu jest stały, tak?
Coś się zepsuło, poszedł jakiś układ scalony
i jak gdyby nie ma szans, żeby on nagle zaczął działać.
Natomiast w oprogramowaniu często mamy do czynienia
z błędami przemijającymi,
czyli nawet po pojawieniu się pewnych błędów
ten system często może dalej pracować.
I popatrzmy, jakie mamy te miary niezawodności.
Tutaj, proszę Państwa, podaję nazwy tych miar,
które są powszechnie stosowane w świecie
i one są skrótami z nazw angielskich.
Czyli mamy miarę, która się nazywa,
która się nazywa Probability of Failure on Demand.
Probability of Failure on Demand.
Pierwsze literki tych słów tworzą nam nazwę tej miary.
Probability of Failure on Demand.
Dosłownie tłumacząc to, jest to prawdopodobieństwo
błędu żądanej usługi, czyli chcemy czegoś od systemu,
a system nam odpowiada źle.
W jakiego typu systemach tę miarę się stosuje?
No na przykład w systemie, w którym mamy,
na przykład w systemach sterowania,
w systemach safety critical,
czyli generalnie w takich systemach,
w które pracują w długim okresie czasu.
Wiele, wiele godzin, wiele, wiele dni ciągle pracują.
Na przykład jeśli to POFOD ma wartość dwie tysięczne,
to znaczy, że na tysiąc żądanych usług
no co najwyżej dwie mogą dać.
Błęd, mogą być błędne.
Druga miara to jest Rate of Failure Occurrence.
Rate of Failure Occurrence.
Failure, a tu mamy occurrence, troszkę inaczej to się pisze,
ROCOF, jest to współczynnik pojawienia się błędu.
Rate to jest inaczej częstotliwość,
czyli można powiedzieć, że jest to częstotliwość
nieoczekiwanych zachowań systemu.
W jakiego typu systemach ten Rate of Failure Occurrence się stosuje?
No na przykład w systemach jest to miara niezawodności
systemów operacyjnych, systemów transakcyjnych.
Generalnie chodzi tu o takie systemy,
gdzie ten koszt startu systemu jest duży.
Czyli, że system ileś tam chwilę, nie wiem, parę sekund, prawda,
się inicjuje zanim będzie.
Będzie pracował.
I na przykład jeśli to ROCOF wynosi jedną setną,
to znaczy, że w stu jednostkach czasu działania
może się pojawić jeden błąd.
Jeśli chodzi o tą jednostkę czasu,
to za chwileczkę jeszcze o tym troszkę opowiem.
Natomiast tutaj mamy taką miarę bezpośrednio wziętą ze sprzętu.
Mean Time to Failure.
Mean Time to Failure.
Czyli średni czas pomiędzy obserwowalnymi błędami.
I tutaj jeżeli taki Mean Time to Failure wynosi na przykład 500,
tutaj proszę Państwa zwracam uwagę,
że to Mean Time to Failure jest odwrotnością
tego Rate of Failure Occurrence.
To znaczy, że na każde 500 jednostek czasu
może się pojawić jeden błąd.
Co najwyżej.
Czyli taki jest średni czas,
te 500 jednostek czasu pomiędzy pojawianiem się błędu.
To jest, proszę Państwa, miara,
którą stosuje się w systemach,
które mają długi czas realizacji pewnych żądań użytkownika,
tak to nazwijmy.
Czyli na przykład jakieś takie systemy,
które wspomagają projektowanie systemu typu CAD.
I to jest bezpośrednia miara przerzucona,
jak gdyby wzięta ze sprzętu.
I ostatnia już miara niezawodności stosowana w oprogramowaniu
to jest Availability, czyli dostępność.
I to jest, proszę Państwa, miara, którą stosuje się w systemach,
które pracują w ruchu ciągu, w systemach telekomunikacyjnych.
Availability, czyli dostępność.
Miara prawdopodobieństwa dostępności tego systemu.
I to jest, proszę Państwa, miara, którą stosuje się w systemach,
które pracują w ruchu ciągu, w systemach telekomunikacyjnych.
I to jest miara prawdopodobieństwa dostępności tego systemu.
I jeżeli myśmy, że to jest miara,
Jeżeli na przykład mamy to availability 997 tysięcznych, to to oznacza, że na tysiąc jednostek czasu ten system jest dostępny aż 997.
To jest bardzo wysoka miara niezawodności, dostępności.
Teraz proszę Państwa, tu przy niektórych miarach pojawiło się określenie jednostki czasu, prawda?
I co to jest? Jak to może być mierzone?
Otóż może być to taki zwykły zegar, jaki mamy na ścianie, na biurku, w telefonie, w komputerze, taki zegar.
Może być to wyrażane w cyklach procesora, natomiast w przypadku systemów, które mają bardzo zmienne obciążenie,
na przykład jakieś systemy rezerwacji, gdzie w ciągu dnia w pewnych godzinach, na przykład 8, 14,
jest bardzo duże obciążenie, a w nocy, na przykład, nie wiem, 12, 4 rano, czy 5 rano to obciążenie jest małe,
to tą jednostką czasu może być liczba transakcji, na przykład na, powiedzmy, ileś tam tysięcy transakcji.
No bo oczywiście, jeżeli system jest bardziej obciążony, no to jak gdyby mamy wtedy większe prawdopodobieństwo tych obserwowalnych błędów.
Może od razu, na razie jeszcze, jak gdyby przerwę to w tym miejscu.
I teraz, proszę Państwa, wrócę, jak mi się uda odnaleźć.
W tym pliku zadania mamy też zadanie dotyczące właśnie tych miar niezawodności.
I tutaj mamy pewne informacje.
Wynosi miara dostępności systemu, który pracuje 10 godzin na dobę.
Jeśli wiadomo, że średni czas naprawy błędu wynosi 15 minut.
Żądanych jest 100 usług dziennie w godzinach pracy, a probability of failure on demand to jest jedna tysięczna.
No i macie tutaj Państwo odpowiedź, więc to już jak gdyby zostawiam dla Was.
Do rozszyfrowania, skąd się ta odpowiedź wzięła.
Proszę Państwa, teraz, jeśli chodzi o te wymagania niezawodnościowe,
no właśnie, my przystępując do projektowania systemu, możemy mieć pewne wartości miar podane.
Prawda?
Że chcemy, aby probability...
...of failure on demand było takie, to a takie, albo żeby dostępność systemu była taka, to a taka.
Natomiast, no mamy potem gotowy system, no i dobrze by było jakoś sprawdzić, czy faktycznie ten system spełnia te wymagania niezawodnościowe, które zostały tutaj, prawda, na wejściu, jak gdyby podane jako wymagania niefunkcjonalne.
I do tego celu używa się testowania statystycznego.
Czyli, no mamy właśnie to, to nie jest testowanie, którego celem jest wykrycie błędów, tylko to jest właśnie testowanie, pomocą którego możemy policzyć wartości tych miar niezawodności.
Pierwsza rzecz, to my, proszę Państwa, musimy określić tak zwany profil działania systemu.
Czyli musimy...
...my musimy określić, w jaki sposób ten system może być używany.
No więc, albo można tutaj, jeżeli jest to na przykład system aktualnie, to można po prostu śledzić takie profile używania tego systemu.
Jeśli to jest kolejna wersja, to można się posługiwać takimi profilami użycia systemu z poprzedniej wersji.
Natomiast, no jest to większy problem, jeżeli to jest całkiem nowy system.
Wtedy my musimy przewidzieć, jak może działać, jak może wyglądać taki profil działania systemu i to już może być, proszę Państwa, no problem, bo potem się może okazać, że w rzeczywistości ten system będzie używany według innych profili niż te, które żeśmy przewidzieli.
Więc przygotowujemy, czy bierzemy, czy szukamy takich profili działania systemu.
Dalej musimy przygotować dane.
Także do tego profilu, prawda, będą dostosowane.
No, wykonujemy te testy.
Istotne jest, że musimy tych, to obciążenie tego systemu musimy mieć tutaj, no jakieś dosyć duże, więc znowu musimy mieć jakieś narzędzie, które będzie ten system zmuszało do pracy, czy będzie pewne żądania do niego kierowały.
I obserwujemy, prawda, jakie będą te czasy pracy pomiędzy zaobserwowanymi błędami.
Które być może wystąpią.
Po dosyć długiej obserwacji, po obserwacji wielu błędów, można te miary niezawodności policzyć.
Ja już wspomniałam o tym, że to wcale nie jest łatwe, bo pierwszy problem to jest ten profil działania systemu, który może być zupełnie nietrafiony.
Więc to już jest pewien problem.
No, te profile trzeba jakoś wygenerować, więc to też wymaga wysiłku.
No i jeżeli są to wysokie...
Wysokie parametry niezawodnościowe, to mamy tutaj do czynienia z tą statystyczną niepewnością, która po prostu tych błędów może być bardzo mało, więc to jest problem.
Wobec tego, proszę Państwa, jak można, no jak się zwykle postępuje?
Otóż można stosować modele wzrostu niezawodności, czyli prowadzić testowanie tak długo, aż osiągniemy pewien poziom niezawodności.
Czyli taki, który będzie dla danego systemu, dla danej aplikacji będzie akceptowalny.
Tutaj wspominałam przed przerwą o tych bardzo wysokich kosztach testowania systemu, wobec tego powinno być to testowanie zakończone, jak tylko będzie ta wersja systemu, powiedzmy, akceptowalna.
No i teraz, jakie modele wzrostu niezawodności mamy?
Otóż pierwszy to była funkcja jednakowego kroku.
Potem zobaczymy, za chwilę go Państwu pokażę, zobaczycie Państwo, to był pierwszy model proponowany, jakie są jego wady, więc zaproponowano potem drugi model, funkcję losowego kroku.
Zobaczymy, że też on ma wiele wad.
I w praktyce stosowane są takie modele ciągłe, które często są już cechą charakterystyczną.
W przypadku konkretnej firmy produkującej software, ideę tych modeli Państwu pokażę, a jak gdyby konkretne wartości, to już jest wykres prawa tajemnicy firmy.
Pierwszy model niezawodności, funkcja jednakowego kroku zaproponowana w 1972 roku.
Jak to wygląda?
Otóż panowie Jeliński i Moranda stwierdzili, że niezawodność zrasta.
O pewno.
O pewno.
To jest stałą wartość po wykryciu i poprawieniu każdego błędu.
No tutaj ten model zakłada, że naprawa błędu jest zawsze poprawna i że naprawienie jednego błędu nie powoduje wzrostu liczby błędów w systemie.
Wiemy, że to nie jest prawdą.
Wiemy, że często poprawiamy jeden błąd i ta poprawka powoduje powstawanie nowych błędów albo poprawienie pewnego błędu.
Odkrywa lawinę jakichś innych błędów, więc nie zawsze jest to prawdziwe.
Kolejny problem tutaj z tym modelem jest taki, że każdy błąd powoduje, wykrycie każdego błędu powoduje jednakowy wzrost niezawodności.
Czyli na przykład, jeżeli weźmiemy sobie częstotliwość pojawiania się błędów, no to wykrycie każdego błędu zmniejsza tę częstotliwość o pewną stałą wartość.
I to wiemy, że też jest nieprawdziwe, dlatego że jeżeli wykryjemy błąd, który jest błędem często występującym,
czy na przykład wielu użytkowników może w ten sposób działać i ten błąd się wtedy będzie ujawniał,
to wykrycie tego błędu powinno spowodować większy spadek tej częstotliwości pojawiania się błędów.
Więc tutaj widzimy, jakie są problemy z tym modelem niezawodności.
No to Littlewood i Verral zaraz po nich zaproponowali inny model.
Mianowicie taki, że ta funkcja jest, ten krok jest losowy, że może on być tutaj większy spadek tej częstotliwości pojawiania się błędów,
bo na przykład został wykryty jakiś typowy błąd, ale proszę popatrzeć, zakłada to również możliwość negatywnego wzrostu niezawodności,
czyli pogorszenia się tej częstotliwości, dlatego że poprawiając ten błąd wprowadziliśmy jakieś kolejne błędy do systemu.
To, proszę Państwa, były lata siedemdziesiąte, troszkę później pojawiły się, zaczęły się prace Musy i także innych
i oni zaproponowali modele ciągłe.
Mianowicie po prostu badali takie...
No krzywe, pokazujące jak się ta na przykład częstotliwość pojawiania błędów zmienia w czasie
i to na przykład właśnie jak ta niezawodność spada w czasie.
I to, proszę Państwa, wyszło im, że są takie krzywe wykładnicze, które mogą być bardziej płaskie lub mogą być bardziej strome.
No i teraz, prawda, tutaj chodzi o to, żeby właśnie...
Testuje się ten system, mierzy się tą niezawodność i jak się dojdzie do poziomu, który już asymptowalny, który jest wymagany w tym systemie,
to w tym momencie przerwać to, bo potem widzimy, że tutaj kolejne te spadki tej niezawodności są coraz to mniejsze,
aż, prawda, dochodzi tu do takiej asymptoty, więc jak gdyby nie ma sensu tutaj działać w tym czasie, bo będą to wtedy nieuzasadnione koszty, a rezultat będzie niewielki.
Jak ta krzywa wygląda? Czy ona jest taka właśnie bardziej płaska, czy jest bardziej stroma?
To to, czy tutaj jaki mamy ten poziom taki asymptotyczny, czy to jest tyle, czy wyżej,
to to są, proszę Państwa, często cechy charakterystyczne dla danej firmy i dla typu oprogramowania, które ta firma produkuje.
I to są, proszę Państwa, no pilnie chronione tajemnice firm software'owych,
No, pilnie chronione tajemnice firm software'owych,
które nie chcą tych danych, no, nikomu udostępniać, bardzo pilnie ich strzegą.
Ale generalnie te krzywe mają tego typu postać.
No i teraz, proszę Państwa, przechodzimy do, już jak gdyby tutaj w tym dziale,
do problemu, no, a jak wyprodukować oprogramowanie, właśnie oprogramowanie,
do problemu, no, a jak wyprodukować oprogramowanie,
właśnie o tak dużej niezawodności.
Wiemy, że w niektórych zastosowaniach, na przykład w systemach safety critical,
wiemy, że w niektórych zastosowaniach, na przykład w systemach safety critical,
ta niezawodność rzeczywiście powinna być bardzo, bardzo wysoka.
I teraz, jakie to mogą być strategie?
I teraz, jakie to mogą być strategie?
Otóż, proszę Państwa, tak.
Pierwsza rzecz to jest tak zwane fault avoidance.
Pierwsza rzecz to jest tak zwane fault avoidance.
I to jest, proszę Państwa, rzecz, którą zawsze powinniśmy stosować,
I to jest, proszę Państwa, rzecz, którą zawsze powinniśmy stosować,
nie przy tworzeniu oprogramowania.
nie przy tworzeniu oprogramowania.
Polega to na tym, że cały ten proces projektowania, implementacji, oprogramowania
ma być ukierunkowany na to unikanie błędów.
Na to, aby tych błędów było jak najmniej.
Druga technika to jest tak zwane fault tolerance.
Druga technika to jest tak zwane fault tolerance.
Otóż, pewne błędy pozostają w systemie,
Otóż, pewne błędy pozostają w systemie,
ale mimo wydycia tych błędów,
ale mimo wydycia tych błędów,
system powinien działać.
To nie zawsze jest potrzebne,
ale przy niektórych typach oprogramowania
rzeczywiście tak powinno być,
że system dostrzegł, że coś jest niedobrze,
że system dostrzegł, że coś jest niedobrze,
ale nie powinien stawać, tylko działać dalej.
ale nie powinien stawać, tylko działać dalej.
No i z tym niejako wiąże się detekcja błędów.
No i z tym niejako wiąże się detekcja błędów.
Pierwsza to jest detekcja błędów przed dostarczaniem systemu,
Pierwsza to jest detekcja błędów przed dostarczaniem systemu,
Mówiłam Państwu na poprzednim wykładzie i dzisiaj, a więc wszelkie techniki, żeby ten system zawierał jak najmniej błędów, czyli zarówno metody statyczne, code review, jak i metody dynamiczne, testowanie.
I to testowanie na różnych poziomach i różne typy testowania. Testowanie czarnych skrzynek, testowanie białych skrzynek, tak aby ten proces wykrywania błędów jak najwięcej tych błędów nam ujawnił.
No i zwykle, proszę Państwa, to unikanie błędów i ta detekcja błędów, czyli code review i testowanie wystarczają.
Do wyprodukowania systemu o jak gdyby żądanych parametrów błędów.
Teraz jeszcze troszeczkę o tym unikaniu błędów i detekcji. Tak jak mówiłam, zazwyczaj to wystarcza do uzyskania potrzebnego poziomu niezawodności.
Tutaj też jest istotne, że cały ten proces produkcji powinien być ukierunkowany na unikanie błędów, a nie tylko na ich detekcję.
Tutaj też wiemy, że kluczem do sukcesu jest specyfikacja poprawna, czyli specyfikacja, która odzwierciedla oczekiwania użytkownika, bo my właśnie do tej specyfikacji dostosowujemy na przykład, w oparciu o tę specyfikację, przygotowujemy to testowanie funkcjonalne.
Więc jeżeli będą...
Jeśli będą błędy w specyfikacji, no to niestety ich nie będziemy w stanie wykryć.
Teraz proszę Państwa, jakie czynniki sprzyjają takiemu bezusterkowemu oprogramowaniu?
No o precyzyjnej specyfikacji, to już Państwu mówiłam, że to jest klucz do sukcesu, że 30 typów błędów to są właśnie błędy wynikające z błędów.
W specyfikacji, więc wspominałam również, pokazałam Państwu taki przykład specyfikacji formalnej, z której w postaci z schematów, z której można wygenerować kod, ale albo można, prawda, potem napisany kod sprawdzić, czy się zachowuje tak, jak to w tej specyfikacji jest.
No i podejście do projektowania implementacji.
Takie podejście obiektowe, które właśnie bazuje na enkapsulacji, na ukrywaniu informacji, czyli takie podejście obiektowe, to są czynniki, które sprzyjają temu, aby to oprogramowanie zawierało niewiele błędów.
Tutaj też kwestia, no prawda, takiej kultury programistycznej, która starają się programiści pisać, no najlepiej tak, jak potrafią.
Języki programowania.
W których jest sprawdzanie typów, też ułatwiają wiele rzeczy, po prostu wiele rzeczy jest wykrywanych na etapie kompilacji kodu.
Tutaj, proszę Państwa, wymieniłam kilka konstrukcji programowych, które są źródłem wielu błędów.
No to nie znaczy, że należy z nich zrezygnować, bo one często nam są potrzebne, ale warto wiedzieć, że to są miejsca, w których często się błędy popełnia.
Mianowicie, użycie liczb zmienno-przeciętkowych jest często nieprecyzyjne.
Wszelkie rzeczy związane ze wskaźnikami, prawda, czyli struktury typu lista, stos, to jest też takie miejsce, gdzie często popełniamy błędy.
Przydział pamięci, dynamiczny przydział pamięci, prawda, zwalnianie tej pamięci, tutaj też często na tych wskazaniach też pracujemy niewłaściwie.
Tam to jest miejsce, które powiązuje.
Znaczy, w których wiele błędów popełniamy.
Współbieżność.
Jeżeli piszemy kod, który będzie współbieżnie wykonywany, to to jest bardzo trudna dziedzina.
Łatwo tutaj pewne błędy popełnić.
Wiele błędów popełniamy korzystając z rekursji.
Prawda, no sama idea rekursji powoduje, że kod jest krótki.
Ale, no, często też tutaj popełniamy błędy.
Oprogramowanie przerwań.
To jest też dosyć trudna dziedzina i też często tutaj są źródła błędów.
Także ja wymieniam te konstrukcje, które nam są potrzebne w programowaniu i często ich używamy,
ale po to, żebyśmy, jeśli mamy je w programie, żebyśmy na te miejsca zwrócili szczególną uwagę.
Czy przy testowaniu, czy poddali analizie, ten kod review, właśnie te miejsca, gdzie mamy na przykład jakieś prace na tych dynamicznych wskaźnikach, rekursja i tak dalej.
Natomiast czasem, proszę Państwa, musimy mieć system, który toleruje uszkodzenia.
Czyli system wykrył, że się pewien błąd...
...błąd pojawił, ale działa dalej.
I to jest, proszę Państwa, potrzebne w takich systemach, na przykład jak kontrola lotów, czy powiedzmy sterowanie rdzeniem elektrowni jądrowej,
czy jakaś linia produkcyjna w fabryce chemicznej.
Czyli w takich sytuacjach, kiedy zablokowanie tego systemu, przerwanie pracy tego systemu,
no może spowodować jakieś duże straty ludzkie, ekonomiczne, czy jakieś tragedie środowiskowe.
Więc wtedy tego typu systemy powinny, no właśnie, móc pracować dalej.
Być może w jakiejś zdegradowanej trochę wersji, ale pracować dalej tak, żeby ten system mógł jednak działać dalej.
Jak...
Jakie są aspekty tolerowania uszkodzeń?
Otóż...
No, pierwsza rzecz to system musi być świadomy, tak, że jakiś błąd wystąpi.
Czyli system musi potrafić wykryć, że pewna kombinacja dała lub może dać błąd.
Drugi aspekt to jest...
Powinien być ten rozmiar zniszczeń w jakiś sposób określony.
Czyli, no, wykrycie takich części systemu, na które ten błąd być może miał wpływ.
I te dwa pierwsze aspekty są jeszcze w miarę łatwe do realizacji.
Znacznie trudniejszy jest powrót z tego błędu, bo tak jak Państwu mówiłam w tych systemach fototolerant,
istotny jest, aby system działał dalej.
Mimo tego, że jest świadomy, że pewien błąd wystąpi.
Czyli kwestia tego fot-recovery.
I tutaj mamy dwie możliwości.
Pierwsza...
Znaczy, chodzi tutaj tak czy inaczej o to, aby system przeszedł do pewnego stanu,
nazwijmy go stanem takim bezpiecznym, żeby mógł dalej kontynuować pracę.
I możliwe to jest w takiej sytuacji,
kiedy system będzie w stanie poprawić ten błąd.
To się nazywa forward error recovery.
Czyli jak gdyby przewidzieć pewien poprawny taki stan
i do niego wejść i dalej w nim działać.
I to jest, proszę Państwa, bardzo trudne.
Natomiast troszkę łatwiejszy jest, czasem się w systemach stosuje takie backward error recovery.
Czyli takie...
cofnięcie się troszkę do tyłu, do stanu, kiedy wszystko jeszcze było okej
i być może pójście inną drogą, czy w inny sposób.
No właśnie, takie naprawienie błędu wiąże się z modyfikacją systemu
i nie zawsze jest to możliwe w trakcie normalnej pracy systemu.
Często to naprawa nie jest konieczna,
bo jak gdyby ten system...
jest w stanie dawać dalej.
Natomiast jeśli nie jest to błąd przemijający,
no to powinien być poprawiony
i powinna być zainstalowana nowa wersja systemu.
Dla systemów, które pracują w ruchu ciągłym,
ta podmiana na ten nowy system powinna być wykonywana dynamicznie
i to już jest bardzo trudna rzecz do wykonania,
aczkolwiek jest to możliwe.
Teraz, proszę Państwa, tak.
W sprzęcie, jeżeli chodzi nam o jakąś dużą niezawodność sprzętu,
no to stosuje się od wielu, wielu lat,
stosuje się podejście redundancyjne.
Czyli jeżeli mamy informację na przykład zapisaną na jednym dysku,
boimy się, że ten dysk może się uszkodzić,
no to spróbujmy zapisać tę informację nie na jednym,
tylko na przykład na dwóch, czy na trzech, czy na czterech dyskach.
I takie podejście redundacyjne w oprogramowaniu też się czasem stosuje.
Czyli przygotowuję...
Dla takiego, no, kluczowego fragmentu oprogramowania
przygotowuje się N wersji oprogramowania.
Różne zespoły dla tej specyfikacji produkują, przygotowują oprogramowanie.
Często dodatkowy wymóg jest taki, że te oprogramowanie przygotowane
przez te różne zespoły jest pisane w różnych językach programowania.
I te wersje wykonywane...
Wersje wykonywane są równolegle.
Wyjścia z tych wersji są porównywane w systemach głosujących.
No i na przykład mamy takie trzy wersje, prawda?
Jeśli dwie wersje są zgodne, trzecia nie,
no to jest to podejrzenie, że ta trzecia wersja, prawda, jest jakiś błąd.
To wejście niespójne jest odrzucane.
To, proszę Państwa, no, dobrze się sprawdza w sprzęcie.
Trochę gorzej się sprawdza w oprogramowaniu,
no to już okazało się przy okazji tworzenia oprogramowania
dla lotów kosmicznych, że po prostu był błąd w specyfikacji
i dla danej specyfikacji były przygotowane różne wersje,
trzy wersje oprogramowania, ale no ten błąd był powielony w każdej z nich
i po prostu te N wersji nie były w stanie tego błędu wykryć.
Więc no to nie zawsze się spełnia.
Czasem ta specyfikacja jest niejasna i wtedy, no nawet w podobny sposób
mogą być, aczkolwiek mylnie zinterpretowane przez na przykład dwa zespoły,
a wtedy te dwa wersje będą, dwie wersje będą zgodne,
mimo że one są nieprawidłowe.
Czasem stosuje się tak zwane bloki recovery block, takie bloki rezerwowe.
Takie.
Pewną część programu wkłada się takie testy sprawdzające poprawność
wykonania pewnego bloku i ewentualnie jeżeli ten kod wykryje błąd,
to jest możliwość powrotu i powtórzenia innego bloku kodu,
jeśli został wykryty taki błąd.
I wykonanie tych bloków rezerwowych.
Jest sekwencyjne.
Tutaj też stosuje się podejście takie, że stosuje się różne języki programowania
dla tych bloków rezerwowych, różne algorytmy.
Czyli na przykład mamy, powiedzmy, pracuje algorytm pierwszy,
test akceptacji nie przeszedł, mamy jakieś podejrzenia,
następuje, prawda, tutaj teraz cofnięcie się do tego bloku,
recovery block i tutaj użycie, jest to na przykład inny algorytm
w innym języku programowania, tak, pracuje to,
następuje znowu taki test akceptacji, jeśli on, prawda, przejdzie,
no to to wszystko działa dalej.
Jeżeli nie, no to jeszcze może być, powiedzmy, jakaś kolejna próba.
Czyli takie recovery block, to jest łatwiejsze do realizacji.
Proszę Państwa, no w aktualnie istniejących językach programowania,
mamy również możliwość oprogramowania sytuacji wyjątkowych, prawda,
tak zwane exception handling, czyli określenia kodu, który będzie wykonany wtedy,
kiedy pewna sytuacja wyjątkowa się pojawi.
I takie sytuacje wyjątkowe pozwalają na wykrywanie pewnych błędów wykonania,
na przykład badanie, czy wartość nie przekracza jakichś zakresów,
czy zachowane są relacje.
Jakie są relacje pomiędzy zmiennymi, czy nie jest dzielenie przez zero wykonane i tak dalej.
Teraz, proszę Państwa, chciałam jeszcze chwilę opowiedzieć Państwu
o tak zwanym defense programming, czyli programowaniu, no dosłownie tłumacząc,
takim defensywnym programowaniu obrony.
Na czym to polega?
Otóż, proszę Państwa, polega to na tym, że programista nie do końca ufa na przykład
tym danym, które do niego zostaną dostarczone, do tej części programu,
który on oprogramuje, czy do pewnych zależności, związków,
tylko stara się przygotować na różne niespodziewane sytuacje
i jak gdyby bronić ten swój kod w tych różnych językach.
W tych nieprzewidzianych sytuacjach.
A więc on włącza pewien kod redundacyjny, który sprawdza pewne zależności, wartości
i pozwala powrócić do stanu właściwego.
Wyobraźmy sobie, że naszym celem jesteśmy takim programistą
i że kazano nam napisać takie proste procedury współpracy ze stosem.
Procedury.
Procedurę push, która wkłada jakiś element na stos
i procedurę pop, która powoduje zdjęcie elementu ze stosu.
I proszę Państwa, no jeden z programistów po prostu napisze taki push,
włóż coś na stos, zdejmij z tego stosu, no i okej.
I teraz w przypadku, kiedy na przykład będzie niewłaściwe użycie tych,
przepraszam,
poszło nie w tą stronę, co trzeba.
Kiedy na przykład będzie sytuacja taka, że te jego procedury zostaną wywołane powiedzmy już,
a potem pop i pop i ten drugi pop już nie ma czego zdjąć z tego stosu, bo stos jest pusty.
No i...
I teraz problem, co wtedy zrobić, prawda?
Co się będzie działo?
Więc to jest takie podejście, no, programisty, który zakłada,
że wszyscy wiedzą jak tego użyć i jak to zrobić i już.
Ale lepsze jest podejście takie właśnie defensywne, obronne.
Kiedy ten programista w tej procedurze pisze jedną dodatkową funkcję, króciutką.
Taką funkcję na przykład is empty, czy ten stos jest pusty.
Takie dodatkowe sprawdzenie.
I teraz w tej funkcji pop, tak, na początku on się spyta, wywoła tą funkcję, czy ten stos jest pusty.
No, jak jest pusty, no to zgłosi na przykład jakąś sytuację wyjątkową lub coś tam, prawda, wygeneruje jakiś komunikat.
Czyli nie dopuści do takiej sytuacji, żeby była próba zdjęcia czegoś z pustego stosu.
Nie jest to duży koszt, prawda?
Nie jest to to raptem jest...
Jedna czy dwie instrukcje.
Natomiast daje to już, no, jak gdyby użycie potem takich funkcji już jest bardziej bezpieczne.
Bo nawet jeśli ktoś je w niewłaściwej kolejności wywoła, to ten program się przed tym obroni.
Czyli na tym właśnie polega to defense programming, to programowanie obronne.
Że programista stara się zabezpieczyć przed jakimś niewłaściwą kolejnością,
czy niewłaściwym zabezpieczeniem.
Z zakresem danych, na których ma ta jego procedura pracować.
I dodaje prosty kod, który sprawdza pewne zależności i sygnalizuje, jeśli coś jest niewłaściwe.
Także nie jest to duży nakład, nie ma tutaj dużych narzutów kodu.
Natomiast efekty użycia tego defense programming są bardzo dobre.
Czy może, nie wiem, macie Państwo do tego jakieś własne, nie wiem, spostrzeżenia?
Czy ktoś z Państwa, nie wiem, spotkał się z takim programowaniem defensywnym?
Stosuje takie metody w swoich programach?
Nie słychać, nie widać. Wszyscy śpią, tak? Albo kawę piją.
Dobra, proszę Państwa, to teraz zajmiemy się prewencją błędów.
No, wiemy już, wspominałam o tym dzisiaj.
Że stosowanie takich języków ze ścisłym typowaniem pewne sytuacje ułatwia.
Dlatego, że wiele błędów może być wykrytych statycznie przez kompilator.
Ale ważne też jest, byśmy w kod programu włączali takie asercje,
które będą sprawdzały stan zmiennych, systemowych zależności
między tymi zmiennymi i w przypadkach, kiedy te zależności są niespełnione,
żeby te błędy były sygnalizowane.
To znowu, jest to pewien kod dodatkowy, kod, który może troszkę będzie zwalniał
wykonanie potem gotowego programu, ale jednak to zabezpiecza przed pojawieniem się
jakichś dużych błędów systemu.
Zwalnia to wykonanie programu, zajmuje to dodatkową pamięć,
ale chroni system przed takimi poważnymi błędami.
Także warto to robić.
Jest, no, jak gdyby promuje się ten typ programowania właśnie takie,
żeby jednak te asercje sprawdzające pewne zależności dane były wkładane w kod.
Wpisany kod.
Ocena zniszczeń, czyli wystąpił błąd.
System jest świadomy tego, że ten błąd wystąpił,
no, ale teraz trzeba jakoś próbować ten obszar zniszczeń oszacować,
czy być może spróbować jakoś wrócić do takiej wersji,
no, w której tego błędu nie było.
No, w której tego błędu nie było.
Nie ma, tak, czy uniknąć ten błąd.
I z czego tutaj można korzystać?
Otóż, proszę Państwa, użycie sum kontrolnych.
Przypuszczam, że mieliście Państwo taki przedmiot,
na którym właśnie było coś na temat kodów z takimi sumami kontrolnymi.
Na podstawie tych sum kontrolnych można wręcz przywrócić,
po pierwsze zauważyć, że jest coś niedobrze
i przywrócić właściwą wartość.
Także te różnego rodzaju sumy kontrolne
pozwalają nam na przywrócenie właściwej wartości i wykrycie błędu.
Struktury dynamiczne, struktury listowe.
I tutaj, proszę Państwa, użycie tych,
czyli mam jakąś strukturę listową.
Mam tu gdzieś początek listy, tak,
i teraz wyobraźmy sobie, że mam taką listę, która ma tylko jeden link.
Ten link do przodu.
Tutaj już dalej nie ma i koniec, tak.
No teraz, jeżeli któryś z tych linków zostanie uszkodzony,
na przykład ten, prawda,
no to ginie mi ta dalsza część tej listy.
Natomiast, jeżeli ja do tego dodam teraz,
o, jest, nie ma problemu, okej.
Jeżeli ja teraz do tego dodam na przykład link,
w drugą stronę idący,
który wskazuje na ostatni element, tak, tak,
i teraz, a ten wskazuje na poprzedni,
a ten wskazuje na poprzedni,
a teraz tutaj mam, prawda, to przyblokowane.
No i teraz wyobraźmy sobie, że ten link ginie, tak.
No to ponieważ ja mam tą strukturę wstecz idącą,
to ja jestem w stanie znaleźć ten blok pamięci, prawda,
i te informacje odzyskać.
Także te linki redundancyjne bardzo są przydatne,
właśnie pozwalają nam, no, pewne dane, jak gdyby, odzyskać.
W systemach współbieżnych stosuje się zegary kontrolne,
które są resetowane po zakończeniu pewnego wykonania,
które startują wtedy, kiedy pewien proces się rozpoczyna,
no i jeżeli ten zegar nie jest, prawda, zresetowany po zakończeniu tej czynności,
no to, to można zauważyć, że, prawda, kontroler zauważy,
że coś tam idzie, idzie, prawda, nie zostało zresetowane,
a więc gdzieś nastąpił jakiś błąd,
na przykład, no, pewne dane nie zostały przesłane,
czy nie zostały odebrane, więc też można taką sytuację zauważyć.
I to, proszę Państwa, są w miarę łatwe,
w miarę łatwe rzeczy do realizacji.
Znacznie trudniej jest powrócić z błędu.
Przeprowadzić system do stanu bezpiecznego,
do takiego, w którym te rezultaty błędu będą zminimalizowane,
w którym system może kontynuować pracę,
być może w częściowo zdegradowanej formie,
jakiejś, na przykład, część mniej.
I tutaj mówiłam Państwu, że są dwa podejścia,
takie jedno to jest forward error recovery,
czyli staramy się przewidzieć,
jak będzie wyglądał właściwy stan takiego błędu,
poprawienie tego błędu.
Tutaj pewne mechanizmy pozwalają nam na taką,
właśnie poprawienie tego stanu błędnego.
Mówiłam o tych kodach korekcyjnych, prawda,
które nawet w przypadku wykrycia błędu,
pozwalają nam przywrócić wartość tą zmienioną.
Czy właśnie pokazałam przed chwileczką ten przykład
z wielokrotnymi linkami,
które pozwalają nam na znalezienie dostępu
do pewnego bloku pamięci,
do którego link tam jakoś gdzieś zginął.
Odtworzenie stanu systemu,
takie backward error recovery,
czyli przejście do zapisanego wcześniej,
zapisanego często na nośniku,
zewnętrznym stanu systemu
i start od tego stanu
jest zwykle łatwiejsze do wykonania.
Natomiast ten forward error recovery jest trudniejszy
i jest możliwy tylko wtedy,
kiedy mamy również w tym kodzie programu
mamy odpowiednie mechanizmy stosowane,
na przykład te, o których tu mówiłam,
kody korekcyjne z wielokrotnymi linkami,
odpowiednione linki.
I to by było tyle,
jeśli chodzi o ten materiał.
Czy do tego, co tutaj Państwu mówiłam,
mają Państwo jakieś pytania, uwagi, komentarze?
Nie słychać, nie widać.
Proszę Państwa, ja potrzebuję 5 minut przerwy,
żeby się przełączyć,
czyli uwaga, robimy 5 minut przerwy technicznej,
na to, żeby się przełączyć na
na to, żeby się przełączyć na
na to, żeby się przełączyć na
nową prezentację.
Muszę po prostu odszukać,
także chwila przerwy.
Blokuję nagrywanie.
---------------------------------------------I teraz udostępnię.
Dziękuję.
Dziękuję.
Dziękuję.
Dziękuję.
Dziękuję.
Dziękuję.
Dziękuję.
Dziękuję.
Dziękuję.
Dziękuję.
Dziękuję.
Dziękuję.
Generalnie jeżeli mamy tutaj koszt i mamy cenę, to jaka relacja pomiędzy tym powinna być?
Pan powiedział, że marża jest potrzebna, czyli co?
Cena powinna być większa od kosztu albo przynajmniej równa, żebyśmy wyszli na czysto, żebyśmy zarobili.
Generalnie taka relacja powinna być, ale zaraz o tym będę mówić, nie zawsze to jest prawdziwe.
Czyli...
Co możemy brać pod uwagę?
Mamy te koszty, tak? Policzone w jaki sposób?
W jaki sposób, to albo dzisiaj już Państwu pokażę, albo pokażę na następnym wykładzie.
A teraz my mamy, przystępując na przykład do przetargu, musimy podać pewną cenę.
Ile uważamy, że za ile jesteśmy...
Za ile nam się to opłaci zrobić, za ile chcemy to coś robić?
I tutaj przy ustalaniu tego, ile faktycznie ta cena jest,
I tutaj przy ustalaniu tego, ile faktycznie ta cena jest,
cena powinna wynosić, bierzemy pod uwagę różne czynniki.
Czyli na przykład pierwsza rzecz, to jest kwestia rynkowa.
Jeżeli jesteśmy taką młodą firmą, która dopiero zaczyna istnieć na rynku dostawców oprogramowania,
to nie możemy tej ceny podać takiej dużej, dużej, prawda, bo przegramy na przykład z firmami,
które podadzą tę cenę, być może też dużą, ale już mają pewne doświadczenia,
już są znane na tym rynku dostawców.
Po prostu przegramy z nimi, będą ich oferty wybierane.
Więc wtedy no właśnie ten nadmiar tej ceny, prawda, ta cena od tych kosztów powinna być,
no niewiele się różnić, być po prostu niska, żeby zaistnieć na rynku.
Druga rzecz, na którą musimy zwrócić uwagę, to proszę Państwa tak,
no jeszcze na razie niewiele, niewiele wiemy na ten temat, jak te koszty należy szacować.
Poza tym, że no muszą to, muszą uwzględniać to właśnie, prawda, te pensje pracowników,
koszty utrzymania firmy i jeszcze, i jeszcze.
Ale jak to policzyć, prawda, dla danego typu systemu, no to o tym troszkę później będę mówić.
Ale ogólnie można powiedzieć, te koszty są niepewne, tak.
Skoro te też, te koszty w tym szacowaniu są niepewne,
no to do tego, co dostaniemy, tak, co nam z tych szacunków wyjdzie,
powinniśmy dodać coś, dorzucić coś, no żeby znowu nie stracić, prawda, żeby wyjść na swoje.
Macie Państwo jakieś sugestie, na ile te szacowane koszty należałoby zwiększyć,
żeby, żeby nie stracić?
Jakieś pomysły?
Chodzi o konkretną wartość na przykład?
Tak, powiedzmy, nie, powiedzmy, wyszło nam, że, no wyszło nam, że szacujemy, że koszty produkcji oprogramowania będą k, tak.
A teraz mamy podać cenę, to na przykład jaką tą cenę powinniśmy podać, wiedząc, że te koszty nie do końca są dokładne.
Bo do końca się nie da tego dokładnie przewidzieć.
No pewnie 30, 50, 20, 30%.
Proszę Państwa, no jesteście optymistami.
Ja Państwu podam pewne dane statystyczne.
Otóż, proszę Państwa, 80% projektów przekracza szacowane koszty o 100%.
Czyli szacowało k, tak, a wyszło im 2k.
Wobec tego taką, takim dobrym współczynnikiem jest tutaj użycie dwójki.
Wyliczyliśmy k jako koszty.
Te dane statystyczne, że 80% projektów przekracza koszty o 100%, no to, żeby było bezpiecznie, to zróbmy to 2k.
No oczywiście nie zawsze tak możemy robić, prawda?
Bo, dlaczego, zaraz wymarzę teraz to, co tutaj robiłam.
Co pisałam, że właśnie nie mogę trafić dzisiaj we właściwe miejsce.
Mianowicie, czasem, proszę Państwa, dajemy cenę niższą, niż to by nam z tych szacunków wynikało.
Nawet po, nazwijmy to, kosztach własnych.
Ale zawieramy dodatkowe porozumienie z klientem.
Właśnie w kontrakcie umieszczamy.
Mamy taką dodatkową klauzulę, że na przykład pewien moduł tego oprogramowania, bo tak jak dodajemy oprogramowanie klientowi, no to klient jest, ma prawo własności do tego oprogramowania.
My nie możemy tego użyć ponownie.
Ale my się z tym klientem dogadujemy i mówimy, że na przykład jeden z podsystemów, czy jeden z modułów z tego systemu, któremu dostarczamy, to te prawa własności, jak gdyby zostają po naszej stronie.
Będziemy mogli tej części użyć, no, ponownie.
Wtedy dajemy mu niższą cenę na to oprogramowanie.
On może być zadowolony, prawda, z tego, że mniej zapłacił.
A my jesteśmy zadowoleni, bo mamy pewien fragment oprogramowania, który, prawda, liczymy, że ponownie użyjemy w kolejnych aplikacjach.
I wtedy w tych kolejnych aplikacjach, w kolejnych systemach, jak gdyby nadrobimy tą, no, tą, czy tą stratę.
Czy ten...
Brak zysku, który na tym kontrakcie mieliśmy.
Tak się czasem robi.
Inne podejście do określenia ceny, to jest, proszę Państwa, kwestia zmiennych wymagań.
Czyli na przykład tak.
Tutaj dostawca mówi, że cena wynosi tyle i tyle, tak.
Podaje tą cenę w pewnej kwocie.
Ale mówi, że...
Ale mówi tak.
Ale każda zmiana w wymaganiach, to zmiana w wymaganiach, to jest dodatkowo tyle to, a tyle.
Te zmiany w wymaganiach wiadomo, że zawsze się będą pojawiać, tak.
No bo tak jest.
I tutaj, jak gdyby, my możemy dać niską cenę.
Taką wyjściową.
Ale tutaj sobie, no, słono liczyć za każdą zmianę w wymaganiach.
I, proszę Państwa, do czego dochodzi czasem w...
Znaczy, są przypadki właśnie takie, że cena, powiedzmy, wyjściowa była X.
A ponieważ były zmiany w wymaganiach, to klient faktycznie zapłacił 10 razy tyle.
Ile tu było początkowo powiedziane.
No, przy długim projekcie, który trwał kilka lat.
No, czy to jest, proszę Państwa, no, dobre podejście do sprawy, czy złe, czy to jest...
To, to już jest kwestia, no, dyskusji.
Ale ja Państwu, po prostu, mówię, jak niektóre firmy postępują.
Że właśnie podają wyjściową cenę niską, ale dużo sobie liczą za każdą zmianę w wymaganiach.
I, jak gdyby, od razu się zmienia.
I, jak gdyby, od razu się liczą z tym, że te zmiany w wymaganiach, no, na pewno będą.
I dochodzi do sytuacji takich, że potem w efekcie klient płaci, tak jak są udokumentowane przypadki,
10 razy tyle, ile było w tej wersji wyjściowej.
Czy to jest etyczne, czy to jest nieetyczne, to to jest, jak gdyby, innego rodzaju dyskusja.
Ja Państwu mówię, że tak niektóre firmy postępują.
No i, proszę Państwa, kolejna, kolejny czynnik, który wpływa na tą cenę, jaką podajemy klientowi,
to jest kwestia kondycji finansowej firmy.
Mianowicie, no, jeżeli firma jest w kiepskiej kondycji, ale chce jednak walczyć, tak?
Chce się utrzymać w branży, no to, żeby złapać kontrakty, to będą pracować po kosztach własnych, prawda?
Czyli będą obniżać ten zysk.
Obniżać ten zysk po to, aby dostać jakiś kontrakt.
Proszę Państwa, no, tutaj mówiłam Państwu, że takim czynnikiem decydującym, jeśli chodzi o te koszty produkcji,
to jest, no, wysiłek tych programistów, testerów, projektantów, analityków zatrudnionych przy tym projekcie.
Więc, żebyśmy byli w stanie to oszacować, to musimy jakoś oszacować produktywność.
No i tutaj takie miary produktywności, to jest na przykład liczba linii kodu na miesiąc, tak?
Tak się oceniało, nawet chyba w niektórych firmach dalej się ocenia efektywność czy, jak gdyby, produktywność programistów.
Ile linii kodu on w ciągu miesiąca czy tygodnia zrobił, oczywiście to jest jakoś tam uzależnione od tego, w jakim języku programowaliśmy.
Czy to jest język niskiego poziomu, taki prawda, assemblerowy dla jakiegoś urządzenia, czy to są języki wysokiego poziomu,
bo wtedy ta produktywność zupełnie inaczej wygląda.
Co możemy powiedzieć o takiej miarze, miara lines of code?
No, mamy pewne problemy, prawda?
Po pierwsze, mamy sytuacje takie możliwe, że w jednej linii, na przykład, w tej linii,
w jednej linii może być
kilka instrukcji i pytanie
jest, jak liczyć, czy liczyć linię,
czy liczyć te instrukcje,
a po drugie, no w językach wysokiego
poziomu programowania, jedna
instrukcja może przechodzić
przez wiele linii kodu, więc
znowu jest problem, jak to liczyć.
Kolejny problem, który
tutaj mamy, to jest problem
komentarzy.
Czy liczyć te linie z komentarzem,
czy nie? Wiemy, że
komentarze są przydatne, prawda?
Ułatwiają nam zrozumienie tego
kodu, potem być może będą przydatne,
jeżeli będziemy chcieli ten kod
komentować. No i to jest
pewien dodatkowy wysiłek, który musi
programista zrobić, prawda, pisząc
taki komentarz. Więc, czy je liczyć
w tych liniach kodu, czy nie?
Widzicie Państwo, że jest tu bardzo
dużo różnych problemów
i nie ma jednej
dobrej odpowiedzi na to, jak to robić.
Generalnie wiadomo, że ta miara
lines of code lub
raczej kilo lines
of code, tak, no
nie jest miarą dobrą,
ale jednak jest ona
ciągle stosowana.
Wobec tego
wprowadzono inne podejście.
Mianowicie,
to w IBM-ie takie podejście
było w 79
roku. Albrecht zaproponował
tak zwane punkty funkcyjne.
Czyli, no, jak piszemy
dla
tych latach, koniec lat 70.,
lata 80., pisane były
pewne systemy, to pewne elementy
w tych systemach były, no,
nazwijmy to, podobne. Czyli
trzeba było jakoś oprogramować
współpracę z użytkownikiem,
trzeba było zapewnić
w jakiś sposób prezentację
wyników. Bardzo często
te systemy wymagały pewnych
plików wewnętrznych, żeby na przykład
coś posortować,
czy coś
wyszukać.
Więc miały pliki wewnętrzne,
musiały się dostosować do jakichś
interfejsów zewnętrznych.
I to były tak zwane
punkty funkcyjne. Za chwilę je
Państwu pokażę. Albrecht
zaproponował pięć typów takich
punktów funkcyjnych. Czyli
można powiedzieć, że
będziemy oceniać programistę
nie przez liczbę linii kodu,
które on napisał, ale przez
liczbę punktów funkcyjnych, które
on oprogramował. No i w zależności
od tego, w jakim języku
będzie to oprogramowywał, no to
jego wysiłek, prawda, będzie większy
lub mniejszy.
No to popatrzmy na te
punkty funkcyjne.
Jakie one są? Czyli po pierwsze
mogą być to
wejścia zewnętrzne, tak?
Po drugie będą
to wyjścia zewnętrzne.
External input,
external, czyli
no coś, co jest
prezentowane, pewne dane
prezentowane,
oprogramowane na zewnątrz.
Teraz również trzeba
oprogramować współpracę
z użytkownikiem.
To jest skrót od external
queries, czyli pewne
zapytania, pewne
od użytkownika, które idą
i to trzeba oprogramować.
Następnie
interfejsy zewnętrzne,
bo być może to nasze oprogramowanie
musi się komunikować
z innymi zewnętrznymi
systemami, to są
interfejsy zewnętrzne
i wreszcie, czyli na przykład
pliki zewnętrzne, z których
pewne dane są wprowadzane,
czy do których pewne dane są
zapisywane. I
pewne pliki wewnętrzne,
internal files, które
są używane po to, żeby
no te funkcje
danego systemu
zrealizować. Czyli
właśnie Albrecht zaproponował
pięć typów takich punktów
funkcyjnych. Wejścia
zewnętrzne, wyjścia,
interakcje użytkownika,
interfejsy i pliki wewnętrzne
używane przez system.
No, ale teraz
kolejna sprawa. Można powiedzieć tak,
że czasem na przykład
taki interfejs zewnętrzny,
czyli jakiś plik zewnętrzny,
z którym to oprogramowanie współpracuje,
jest łatwy do
oprogramowania. A czasem
na przykład on może mieć taką
złożoną strukturę, że trudno
to będzie zrealizować.
A nie na przykład z tymi
query, z tymi zapytaniami, interakcjami
użytkownika. Że czasem
taka interakcja użytkownika to może
być coś bardzo prostego, na przykład
wyprowadzenie tylko pewnej
danej, którą mamy w systemie.
Natomiast czasem
może być to wymagać
no jakichś złożonych
algorytmów, wyszukiwania,
obliczeń i tak dalej.
A więc znowu widzimy,
że te punkty funkcyjne
mogą mieć różny poziom
złożoności. Więc można
proszę Państwa, dla tych punktów
funkcyjnych, można określić
wagi, które będą określały
czy to jest
złożony punkt funkcyjny,
czy to jest
punkt jakiś
prosty.
Więc właśnie
mogą mieć one
różne wagi. Mniejszą
przy pewnych prostych,
wyższą przy pewnych złożonych.
No i teraz proszę Państwa,
może być również sytuacja
taka, że na przykład
powiedzmy te pliki używane
przez system, że na przykład
plik używa, system
używa powiedzmy czterech plików
wewnętrznych. Z tego
na przykład jeden jest
łatwy, tak.
Na przykład dwa
mają średnią skalę
złożoności
i dwa są trudne.
Wysoką skalę
złożoności mają.
Więc
można temu przypisać
pewne wagi
niskiej, prawda,
złożoności tego pliku. Na przykład waga
może być dwa. Tutaj
na przykład waga może być cztery.
A przy tym złożonym
na przykład waga może być
siedem. Wobec tego
można dla tych plików używanych
przez system, można to
zsumować, prawda. I powiedzieć
tak, ma jeden łatwy,
tak, czyli
jeden razy dwa.
Teraz ma dwa
takie, no,
średniej skali złożoności, gdzie tu
współczynnik określono jako cztery,
czyli
plus
dwa razy cztery
i dwa
o wysokiej skali złożoności
i do tego dodajemy dwa razy
siedem,
tak. To w sumie
nam to wyjdzie
dwa
i
, to jest dziesięć
i czternaście, wyjdzie nam
dwadzieścia cztery. Czyli
dostaję pewną liczbę,
która jak gdyby jest,
no, w jakiś sposób
charakteryzuje wysiłek
związany z
oprogramowaniem tych plików
używanych przez system.
I tak możemy, proszę Państwa,
robić dla kolejnych,
prawda, typów tych punktów
funkcyjnych. Wobec
tego możemy,
proszę Państwa, policzyć
tak zwane UF
an adjusted
function point, gdzie
właśnie sumujemy
liczbę elementów
danego typu
pomnożoną przez
współczynnik i
przechodzimy przez
wszystkie typy punktów
funkcyjnych.
Więc
możemy dostać
UFC, który w jakiś
sposób określa
złożoność tego
projektu. Nie do końca, ale
wiemy, że jeżeli to UFC
będzie większe, no to
będzie potrzebny większy wysiłek
do jego realizacji.
Właśnie jakoś
uwzględnia trudność realizacji
poszczególnych punktów
funkcyjnych. To UFC
możemy modyfikować jeszcze
współczynnikiem określającym
złożoność całego projektu.
Jeśli cały projekt jest złożony,
to jeszcze przemnóżmy to przez
jakąś liczbę większą od jedynki.
Jeżeli
na przykład korzystamy z jakichś
gotowych elementów, czyli
mamy jakieś moduły już
z poprzednich realizacji,
no to ten wysiłek
przy realizacji tego projektu
będzie mniejszy, czyli możemy wtedy
stosować jakiś współczynnik, który
jest mniejszy od jedności.
Na przykład pomnożyć to
przez 0,8, bo
mamy pewne ponownie użyte
elementy.
A jak jest
tutaj złożone, to przez
więcej niż
jeden.
Teraz następna sprawa.
Otóż te punkty
funkcyjne mogą być
realizowane, programowanie
będzie w równych językach
programowania. I
w zależności od tego, w jakim
to będzie języku realizowane,
to tych linii będzie mniej
lub więcej. Więc
stosuje się tak zwane
AFC, Average Number
of Lines of Code
dla języka programowania.
Na przykład
dla assemblera będzie to zwykle
kilkaset linii kodu.
Czyli powiedzmy
na punkt funkcyjny, na przykład
weźmy sobie 250 linii
kodu będzie
potrzebnych, żeby
taki punkt funkcyjny oprogramować.
Dla
języków
wyższego poziomu,
no to liczba tych linii kodu
będzie mniejsza, na przykład 40,
50. No i teraz
proszę Państwa, jak mam policzone
to UFC
i pomnożę
to UFC przez AFC,
to mam
proszę Państwa szacowaną
wielkość tej implementacji
w liniach kodu.
Bo to AFC
jest wyrażone w liniach kodu.
Więc mam
szacowaną wielkość
mam szacowaną
wielkość
tego realizowanego
projektu, co mi znacznie ułatwia
sprawę, prawda? Potem w jakichś
szacowanych dalej.
Czy to jest jasne?
To co tutaj Państwu mówiłam o tych
o tym liczeniu
tych punktów funkcyjnych,
linii kodu, współczynnikach.
Na pewno będziecie Państwo
mieli jakieś zadanie tego typu.
Więc jeśli coś jest niejasne,
to proponuję od razu mi tutaj
dać znać.
Wszystko jasne?
Tak.
Tak? Fajnie.
Dobra. Proszę Państwa,
popatrzmy teraz tak.
Na różne techniki szacowaną,
modelowania kosztów.
Otóż
pokażę Państwu,
ale już na następnym wykładzie,
metodę
algorytmicznego modelowania
kosztów,
która została przez
Barrego-Boema zaproponowana
na podstawie informacji
historycznych o wielu
projektach, no i
na podstawie przewidywanej
wielkości projektu, która na przykład może
być policzona z tych punktów
funkcyjnych.
Lub w jakiś inny sposób.
Mamy, proszę Państwa,
ekspertów, którzy tak,
jak to się mówi, no z palca
są w stanie, no oczywiście
nie całkiem z palca, tylko
znając specyfikację
danego projektu, są
w stanie oszacować,
jaki wysiłek, ile
na przykład osobomiesięcy
potrzeba do realizacji
tego projektu.
I w jakim czasie ten projekt
będziemy w stanie zrobić.
Teraz, proszę Państwa,
możemy, jeśli
realizujemy projekty
z podobnej dziedziny,
z tej samej dziedziny,
na przykład jesteśmy firmą,
która produkuje oprogramowanie
dla banków.
Zrobiliśmy dla takiego banku,
teraz robimy dla innego.
No to możemy, proszę Państwa,
szacować to poprzez analogię.
Czyli mamy dane
z projektów, które już
żeśmy zakończyli,
wiemy ile one zajęły
czasu, ile
czasu trwały,
jakie były ich koszty,
ile wysiłku, ile osobomiesięcy,
person per month potrzeba było,
żeby je zrealizować.
I teraz mamy aktualny projekt,
który, no na przykład
widzimy, że jest trochę trudniejszy
niż poprzedni, albo
trochę łatwiejszy. Możemy to
po prostu przez analogię zmniejszyć,
zwiększyć te wartości danych
i dosyć dobre efekty
takiego szacowania przez analogię
możemy mieć.
Proszę Państwa, działają również
prawa Parkinsona, które mówią,
że praca rozrasta się do końcu dostępnego
czasu, koszt określają
dostępne zasoby i czas.
No i to jest coś, co Wy stosujecie
często w swoich projektach semestralnych,
czasem
w pracach dyplomowych,
czy w jakichś tam
projektach.
No,
macie termin
oddania w dniu takim, to
a takim, no ile Wam się uda zrobić
do tego dnia, to tyle, prawda,
zrobicie i tyle pokazujecie.
Proszę Państwa, czasem możemy
jakoś się
mniej więcej orientować,
ile klient jest
nadany na projekt,
lub, no, jesteśmy jakoś
z tym projektem, z tym klientem
związani od wielu lat,
robimy dla niego
różne projekty
i teraz wiemy, że
czy on nam mówi, no, że mogę wydać
tyle i tyle i my jak gdyby
dostosowujemy ten projekt
do tego, co klient
może wydać na ten projekt.
No, czy to jest dobre podejście, czy
nie, no, to znowu jest to kwestia dyskusyjna,
ale właśnie w niektórych
sytuacjach się sprawdza, że
jak gdyby wielkość projektu jest dostosowana
do tego, co klient nam może
za niego zapłacić.
Proszę Państwa, od iluś lat
stosuje się również
szacowanie w oparciu
o use case'y.
To
są artykuły na ten temat,
można sobie
poszukać i znaleźć.
Ja przypomnę Państwu, że jak
projektujemy use case'y,
tak, diagram use case'y
i potem to opisujemy te use case'y
podając sekwencje
czynności, taki przebieg
podajemy normalny,
podajemy przebiegi alternatywy,
kiedy tutaj coś w tym głównym przebiegu
się nie uda, mamy
kilka takich przebiegów alternatywnych
podanych i na podstawie
właśnie analizy
tych use case'ów
jesteśmy w stanie też
oszacować
no, jak gdyby
pracochłonność potrzebną do realizacji
tego projektu i
tutaj te szacunki dosyć dobrze
się sprawdzają potem w
rzeczywistości, są zbieżne z tym,
co faktycznie w projekcie
wychodzi.
Także takie
mamy, jak gdyby, podejścia do
techniki szacowania kosztów.
I zostało parę minut dzisiaj,
ale na tym chciałabym
zakończyć.
Na następnych zajęciach
pokażę Państwu
algorytmiczne modelowanie
kosztów, mianowicie pokażę Państwu
model, który się nazywa
COCOMO
COCOMO 2
i zobaczymy jak tam
można szacować wysiłek
potrzebny do realizacji projektu,
czas trwania projektu
i tym podobne rzeczy.
Czy
do tego, co dzisiaj mówiłam
mają Państwo jakieś może pytania?
Teraz proszę Państwa tak, no za dwa tygodnie
mamy ostatni wykład,
potem mamy
9 i 23
lutego mamy egzaminy,
które będą się odbywały
w Innsperze, które ja przygotuję.
W trakcie egzaminu
ja będę dostępna tutaj
na spotkaniu Teamsowym,
także ewentualnie
coś tam będę mogła
reagować, czy
nie wiem, jakąś podpowiedź dla wszystkich
ewentualnie
udzielić.
Natomiast ja może
proszę Państwa uruchomię
w najbliższym czasie
no w cudzysłowie zadanie,
ale może nie tyle zadanie,
tylko będziecie Państwo mogli
nie wiem
załączyć jakiś plik, w którym
czy
jakieś pytania
do mnie możecie zapisać,
czy może
jakąś prośbę, nie wiem,
o to, co na tych ostatnich
zajęciach jeszcze, jeżeli zostanie
nam chwila czasu,
co byście Państwo chcieli, żebyśmy
żebym Wam, nie wiem,
coś tam jeszcze podpowiedziała, czy opowiedziała,
więc jeśli ktoś z Państwa będzie miał
takie prośby, no to
można będzie w tym takim
w cudzysłowie nie zadaniu, no tym razem
zadaniu dla mnie, prawda?
A potem ja to
przejrzę i ewentualnie
jakieś rzeczy takie, które będą
mi się wydawały, że są
potrzebne
nie tylko jednej osobie, czy mogą być
potrzebne, ale wielu z Państwa
to w miarę
pozostałego czasu,
na ostatnich zajęciach
za dwa tygodnie będę starała się Państwu
pokazać.
Dobrze, czy dzisiaj coś mają
Państwo jakieś pytania, uwagi
do tego,
co mówiłam?
Jeżeli nie, to dziękuję
dzisiaj Państwu za udział w zajęciach,
no i zapraszam za dwa tygodnie.
Do widzenia.
Do widzenia.
Do widzenia.
Do widzenia.
Do widzenia.
Do widzenia.
Do widzenia.
Do widzenia.
---------------------------------------------Wyłączę kamerę.
No i szybkie pytanie, czy słychać, czy widać? Mam nadzieję, że tak.
Dobrze słychać, widać wszystko.
Super, bardzo dziękuję. Dobra, proszę Państwa, na ostatnich zajęciach pokazywałam Państwu, zaczęłam opowiadać Państwu o technikach estymacji kosztów produkcji oprogramowania i wymieniłam, że takie są metody.
Po parę zdań powiedziałam chyba o sądzie ekspertów, estymacje przez analogii, prawo Parkinsona.
Cena do wygrania, use case. Tak, wydaje mi się, że o tym mówiłam. Czy to się zgadza? Nikt nie pamięta.
Dobra, proszę Państwa, dzisiaj będę chciała więcej czasu spędzić pokazując Państwu algorytmiczne modelowanie kosztów, no bo to jest coś, co prawda, konkretne rzeczy nam tutaj, jakieś liczby nam wychodzą, więc to takie jest do nas przemawiające.
I generalnie te metody algorytmiczne, bo celem naszym jest oszacowanie wysiłku, jaki jest potrzebny przy produkcji oprogramowania.
Przypomnę, że ten wysiłek zwyczajowo wyraża się person per month, w krótkich okresach w firmach można to robić, tam person per week czy month, więc można to troszkę, tą skalę, ale generalnie jeśli chodzi o cały projekt to person per month,
w osobomiesiącach. I te algorytmiczne modelowanie kosztów opiera się o taki wzór, który tutaj Państwu pokazałam, czyli, że właśnie ten wysiłek potrzebny do realizacji projektu, to jest, proszę popatrzeć, bardzo silnie zależy od tego, jak wielki projekt mamy do realizacji,
czyli to jest MP, to jest metryka produktu.
Zwyczajowo jest to wyrażane w kilo lines of code, tak zwane CLO, kilo lines of code, w szacowanej wielkości liczby linii kodu.
Ja na poprzednim wykładzie mówiłam Państwu o punktach funkcyjnych i mówiłam Państwu, że na podstawie tych punktów funkcyjnych można oszacować przewidywaną wielkość tego oprogramowania.
W przypadku oprogramowania, które jest pisane, jak to się mówi, from scratch, czyli kiedy wszystko sami pisze.
Więc proszę popatrzeć, to jest właśnie ta wielkość szacowana, wielkość tego kodu, który należy napisać.
Tutaj mamy wykładnik, ten wykładnik jest powyżej jedynki, ale on się zmienia w różnych metodach i za chwileczkę będę Państwu o tym opowiadać.
Przy jednej z metod po prostu go się wylicza.
Tutaj mamy jakąś stałą wartość, która często określa w jakiś sposób złożoność projektu.
Przy czym ta złożoność projektu tutaj zwykle jest wyrażana, że jest to projekt łatwy, średni lub duży.
I tutaj jest taki współczynnik M, który określa różne atrybuty tego oprogramowania, które realizujemy.
Te różne atrybuty wyraża się też w pewnych współczynnikach.
I te współczynniki mnoży się przez siebie dostając tutaj taki wypadkowy współczynnik.
Za chwilę pokażę jakieś przykłady, zobaczycie Państwo jak to działa.
No i teraz proszę Państwa, ponieważ my szacujemy, więc często te szacunki robią się właśnie szukając takiego najlepszego produktu.
No i teraz proszę Państwa, ponieważ my szacujemy, więc często te szacunki robi się właśnie szukając takiego najlepszego produktu.
No i teraz proszę Państwa, ponieważ my szacujemy, więc często te szacunki robi się właśnie szukając takiego najlepszego produktu.
kiedy wszystko nam idzie, prawda, znakomicie i wszystko się udaje, takiego najgorszego, kiedy tutaj mamy duże, spodziewamy się, czy mogą wystąpić pewne problemy, no i taki średnio oczekiwany, czyli takich estymacji zwykle robi się kilka.
To było, proszę Państwa, takie ogólne wyrażenie, które jest stosowane. Ja teraz chcę Państwu opowiedzieć o pewnym konkretnym modelu. Zacznę od takiego, jak Państwo widzicie, modelu starego z roku osiemdziesiątego pierwszego.
Dlaczego o tym mówię? Dlatego, że on jest bardzo prosty i jest włączany również w te modele, które współczesnie się używa.
Zaproponował go Barry Boer.
Barry Boer zaproponował go Barry Boer na podstawie danych zgromadzonych z paru tysięcy projektów realizowanych na terenie Stanów Zjednoczonych i Kanady.
I tam w bazie danych miał informacje właśnie o tym, jak duży był ten projekt, ile czasu trwała jego realizacja.
Barry Boer zaproponował właśnie na podstawie tych wartości, tych danych zgromadzonych w tej bazie danych,
takie trzy wyrażenia, które za chwileczkę Państwu pokażę.
Pierwsza rzecz, że on jak gdyby podzielił te projekty, które miał w tej bazie zgromadzone na trzy kategorie.
Na projekty proste, łatwe, na projekty średniej skali złożoności i na projekty trudne, bardzo złożone.
Przez prosty projekt on zakładał, że...
Są to projekty, których szacowana wielkość jest poniżej trzydziestu tych kilo lines of code.
I dla tych prostych projektów tutaj podał współczynnik 2 i 4 i wykładnik 1.0.5.
I to jest, jeszcze raz mówię, wartości uzyskane na podstawie, jak gdyby dopasowanie do tych danych,
które miał zgromadzone w tej bardzo dużej...
bazie danych.
Ten współczynnik M to jest właśnie ten współczynnik, który określa pewne dodatkowe własności tego oprogramowania,
które realizujemy i również warunków, w jakich to realizujemy i troszkę więcej za chwilę o nim powiem.
Dla projektów o średniej skali złożoności, czyli takich, które powiedzmy albo przekraczają to trzydzieści tysięcy linii kodu,
są bliskie albo nawet ciut mniejsze, ale na przykład projekt jest w nowej dziedzinie.
Zespół, który realizuje ten projekt nie ma doświadczenia w tej właśnie dziedzinie problemu.
No to proszę popatrzeć tutaj ten współczynnik pierwszy, ta stała tutaj jest większa, jest trzy.
I proszę popatrzeć, jest również większy wykładnik.
No bo przy średniej skali złożoności projektów to, prawda, musimy więcej wysiłku,
włożyć również więcej mamy takich tych wewnętrznych, jak gdyby czasu poświęconego na komunikację pomiędzy członkami zespołu,
który no też powoduje przedłużenie trwania tego projektu, czy zwiększony wysiłek.
I te średnie projekty to dla niego według, jak gdyby te dane dobierał na podstawie projektów,
których wielkość była poniżej stu.
I dla złożonych projektów, proszę popatrzeć, jeszcze większy jest ten współczynnik z przodu
i zwiększony jest również wykładnik do jeden i dwie dziesiąte.
Także w zależności od tego szacujemy na przykład używając punktów funkcyjnych wielkość tej aplikacji,
którą będziemy realizować i jak gdyby możemy tutaj trafić, wybrać odpowiedni,
odpowiedni poziom i odpowiedni wzór na ten wysiłek, person, permant potrzebny do realizacji tego naszego projektu.
O tym współczynniku M, który tutaj jest takim wypadkowym współczynniku uwzględniającym różne własności tego projektu
i warunki, w których jest realizowany, ja za chwileczkę jeszcze będę mówić.
No i proszę Państwa, znowu jeżeli mamy sytuację taką, że
powiedzmy, jak gdyby wypada, że powinniśmy ten wzór na proste projekty zastosować,
ale jest to nowa dziedzina, nie mamy doświadczenia w tej dziedzinie,
no to bezpieczniej jest przyjąć ten wzór o większych wartościach współczynników i wykładnika.
Bo tak jak Państwu mówiłam, no te szacowania początkowe są niedokładne.
Mówiłam Państwu, że prawda?
Za 80% projektów przekracza te dane o 100%, więc lepiej ten model wyższy zastosować.
Także zaczynamy właśnie od takiej wartości, gdzie to M jest równe 1,
szacujemy tylko liczbę tysięcy linii kodu,
kilo lines of code albo kilo delivered source instruction,
tak czy inaczej chodzi tutaj o linie kodu źródłowego,
które będą potrzebne do...
do realizacji tego, tutaj komentarze nie są uwzględniane.
I zaczynamy od takiego modelu podstawowego.
Natomiast teraz, proszę Państwa, przyglądamy się bliżej tym, no własnością tego projektu,
który realizujemy i również pewnym czynnikom, w jakich będziemy ten projekt realizować.
I co się tutaj bierze pod uwagę?
Mianowicie, no bierze się pod uwagę,
niezawodność tego oprogramowania, które realizujemy.
Czy jest to oprogramowanie, które ma jakieś specjalne własności,
musi mieć wysoką niezawodność tego oprogramowania,
bo jest, działa w jakiejś dziedzinie takiej, że to jest rzeczywiście niezbędne,
czy niekoniecznie.
Istotna jest również sprawa wielkości bazy danych, z jaką to oprogramowanie ma współpracować.
I jeśli te bazy danych są duże bardzo, to też będziemy tutaj używać współczynnika,
który no będzie podnosił ten szacowany wysiłek, no bo wiadomo, że wielkość naszej pracy będzie rosła.
Kolejne tutaj czynniki, które uwzględniamy, to są na przykład jakieś ograniczenia nałożone na powiedzmy wielkość pamięci,
jaką to produkowane przez nas oprogramowanie ma zajmować.
Czy są takie ograniczenia?
Jeżeli realizujemy jakieś oprogramowanie, które ma być wbudowane w jakiś czip i ten czip ma działać w jakimś tam urządzeniu,
no to często mamy takie ograniczenia pamięciowe, bo chodzi o zużycie energii, chodzi o wielkość,
więc wtedy też musimy się no troszkę więcej wysiłku włożyć, żeby właśnie te ograniczenia spełnić
i ten zwiększony wysiłek za chwilę będziemy uwzględniać.
Być może również chodzi o to, aby to oprogramowanie działało.
To nie działało w jakiś sposób no wyjątkowo szybki, więc te ograniczenia pamięci i czasu wykonania,
jeżeli mamy takie duże, to też no trzeba to będzie uwzględnić w tym zwiększonym wysiłku przy produkcji tego oprogramowania.
No i atrybuty personelu.
To jest właśnie to, o czym już wspomniałam i co już mówiłam przy tych modelach prostym, średnim czy złożonym,
jeżeli mamy zespół, który w danej dziedzinie ma niewielkie doświadczenie albo w ogóle nie ma doświadczenia
lub jeżeli mamy zespół, który jest nowy, słabo zintegrowany, słabo ze sobą współpracujący,
to będziemy musieli to uwzględnić, również zwiększając ten szacowany wysiłek.
Tutaj również bierzemy pod uwagę, w jakim stopniu korzystamy z narzędzi,
wspomagających proces produkcji.
Jeżeli zespół nas korzysta z jakichś takich środowisk, w których, prawda, możemy robić projekt,
takie środowisko typu na przykład Software Architect, gdzie robimy projekt WML-u,
potem część tego kodu jest automatycznie, szkielety kodu są automatycznie generowane,
no to to zmniejsza wysiłek programistyczny i należy to uwzględnić w tym szacowanym wysiłku.
Czyli w jakim stopniu korzystamy z takich narzędzi wspomagających to nasze projektowanie
i wykonywanie tego oprogramowania, czy korzystamy, czy umiemy korzystać z tych narzędzi.
Jeżeli tak, no to tutaj ten szacowany wysiłek będzie mniejszy i będziemy to uwzględniać.
I teraz, proszę Państwa, te właśnie czynniki, które tutaj wymieniłam, no szacujemy tutaj,
podając takie wartości z zakresu albo od 0,7 do 1,66, czyli jeżeli na przykład stosujemy,
zespół używa narzędzi takich, których, prawda, część kodu jest automatycznie generowana,
który pozwala na pracę zespołu nad projektem, to ich wysiłek będzie mniejszy
i wtedy, no należy ten szacowany wysiłek pomnożyć przez liczbę mniejszą od jedynki,
żeby to uwzględnić, na przykład, powiedzmy, przez liczbę 0,9, tak, jeżeli, powiedzmy, korzystamy z tego narzędzia.
A więc, bo wysiłek wynikowy będzie zmniejszony.
Jeżeli na przykład tutaj mamy personel, który jest personelem, no, słabo zintegrowanym,
te ścieżki komunikacyjne, ta współpraca i pomoc jest zintegrowana,
jest jeszcze może niezbyt dobrze jakoś tam rozwinięta,
no to trzeba tutaj to uwzględnić, bo będzie to zwiększało wysiłek potrzebny do wykonania tego oprogramowania.
Na przykład weźmy sobie, powiedzmy, 1,1 czy 1,2.
Teraz, jeżeli mamy znowu jakiś system, którym są istotne te ograniczenia pamięciowe,
na przykład, bo chodzi o pobiór, pobór, powiedzmy, energii
i ta pamięć nie może być zbyt duża, no to też musimy więcej wysiłku włożyć w wykonanie takiego
i zaprojektowanie takiego oprogramowania, więc też ten współczynnik będzie większy,
na przykład, powiedzmy, 1 i 2.
Wyobraźmy sobie, że mamy jakieś bardzo duże ograniczenia na pamięć
i również nie tylko, że ma to oprogramowanie zajmować mało pamięci,
ale ma bardzo szybko działać, więc też musimy to uwzględnić.
Wielkość bazy danych, znowu, jeżeli ta baza danych czy bazy danych,
z którymi to oprogramowanie współpracuje są jakieś bardzo duże,
to też trzeba wziąć współczynnik większy od jedynki, bo będzie większy nasz wysiłek.
Niezawodność oprogramowania, czy właśnie to nasze oprogramowanie ma jakieś takie szczególne cechy
i musimy stosować specjalistyczne techniki do tego, żeby tę zawodność, prawda, uzyskać,
to też współczynnik będzie powyżej jedynki.
Także, jeżeli wysiłek jest zmniejszony, na przykład przez użycie narzędzi,
albo na przykład mamy personel, mamy zespół, który jest dobrze zintegrowany,
który robił już projekty w tej dziedzinie, no to też tutaj na przykład 09,
taki współczynnik byśmy wtedy zastosowali.
Czyli w takim zakresie szacujemy te współczynniki i wymnażamy je wszystkie ze sobą.
Właśnie tutaj.
Atrybuty związane z produktem, takie widzieliście Państwo,
takie jak niezawodność, jak wielkość bazy danych, jak złożoność tego produktu.
Teraz atrybuty komputera, czy są ograniczenia czasu, pamięci,
stabilność platform sprzętowych, na których to oprogramowanie pracuje.
Jeżeli musimy takie ograniczenia, prawda, spełniać, jakieś w dodatku takie bardzo istotne,
no to trzeba ten wysiłek zwiększać.
Atrybuty personelu, o czym już mówiłam.
Czy mamy ludzi, którzy mają doświadczenie już w pracy zespołowej,
w pracy z narzędziem, w danej dziedzinie.
Jeżeli tak, no to ten wysiłek może być zmniejszony
i wtedy łatwiej im będzie współpracować.
Wtedy możemy tutaj zastosować współczynnik mniejszy od jedynki, na przykład 09.
Jeżeli zespół jest nowy, no to ten współczynnik,
powinien być większy od jedynki.
I to, o czym mówiłam, stosowanie tych narzędzi, prawda,
czyli na przykład narzędzi case'owych,
ale, proszę Państwa, również terminarz projektu.
Czy jesteśmy w takiej sytuacji komfortowej,
że możemy ten projekt realizować zgodnie z takim harmonogramem,
jaki żeśmy sobie opracowali i nam ten harmonogram odpowiada,
czy może mamy jakieś naciski, tak to nazwijmy, z zewnątrz,
że ten projekt musi być zakończony w krótszym czasie
i wtedy, no, potrzebny będzie zwiększony ten wysiłek,
wtedy też ten współczynnik musimy wziąć większy od jedynki.
Ja za chwilę pokażę, o właśnie, pokażę Państwu taki prosty przykład.
Wyobraźmy sobie, że korzystając z punktów funkcyjnych,
o, szacowaliśmy wielkość systemu na 128 Kilo Delivered Source Instruction.
To 128, moment.
Wybieramy tutaj odpowiedni wzór z tych, które tutaj Państwu pokazałam.
Tak, jeżeli to jest projekt złożony, no, wyszło nam, że 128 Kilo Delivered Source Instruction.
Więc zgodnie z tymi regułami, które Państwu podałam,
że jak powyżej 100, to zwykle tutaj bierzemy ten wyrażenie na projekt złożony.
Czyli tutaj wstawiamy 128, tak.
Podnosimy to do potęgi 1 i 2 dziesiąte, mnożymy przez 3 i 6 dziesiątych.
I z tego nam wychodzi, tutaj właśnie na razie zakładamy wartość tego współczynnika równą 1.
I z tego nam, proszę Państwa, wyszło...
1216 osobomiesięcy.
Możecie Państwo mniej sprawdzić, korzystając z kalkulatora.
I to jest model podstawowy.
I teraz, proszę Państwa, przyglądamy się właśnie różnym atrybutom tego produktu
i również, no, warunkom, w jakich ten projekt ma być realizowany.
A więc na przykład
mamy bardzo wysokie,
bardzo wysokie parametry niezawodnościowe tutaj narzucone, że on musi spełniać.
No to musimy tutaj zwiększyć ten wysiłek.
A może w dodatku, prawda, trzeba będzie jeszcze jakieś techniki programistyczne stosować,
które też ten wysiłek zwiększą.
Takie, o których wspominałam Państwu na poprzednich zajęciach.
To tutaj ten współczynnik, widzicie Państwo, ustawiłam na poziomie 1 i 4 dziesiąte.
Jest to projekt złożony, więc też współczynnik związany ze złożonością projektu,
jak widzicie Państwo, jest powyżej jedynki, 1 i 3 dziesiąte.
Są ograniczenia pamięci, czyli ma być to system wysoce niezawodny
i w dodatku na przykład ma zajmować niezbyt dużo pamięci,
czy wręcz powinien zajmować pamięć nie większą niż.
Więc być może też będziemy musieli tutaj trochę, no, różnych prób wykonać
i też bardzo dobrze przyjrzeć się temu oprogramowaniu tak,
żeby te ograniczenia pamięci spełniało, czyli mamy znowu zwiększony wysiłek.
W niewielkim stopniu korzystamy z narzędzi, więc ten współczynnik jest bliski jedynki.
I w dodatku, proszę Państwa, nie możemy tego realizować w takim harmonogramie,
jaki by nam pasował.
Są jakieś naciski zewnętrzne, prawda, odgórne, żebyśmy ten projekt zrealizowali
w przyspieszonym harmonogramie, a nie w takim, jaki, powiedzmy, nam by pasował.
Więc też być może tutaj będzie to się wiązało ze zwiększonym wysiłkiem.
Też, jak widzicie Państwo, jest to współczynnik powyżej jedynki.
Teraz, proszę Państwa, te wszystkie wartości mnożymy, czyli 1 i 4 dziesiąte
pomnożyć przez 1.
1 i 3 dziesiąte pomnożyć przez 1 i 2.
Pomnożyć przez 1 i 1.
Pomnożyć przez 1 i 23.
I to pomnożyć przez to 1216.
Przez to 1216.
To to, proszę Państwa, wyszło mi, że to jest, jak Państwo widzicie, prawie
3600 osobomiesięcy.
Czyli widzicie Państwo, jak bardzo pewne parametry tego oprogramowania, które realizujemy,
mogą wpływać na, i wpływają, prawda, na wysiłek potrzebny do realizacji tego projektu.
Tutaj, no, były bardzo one takie krytyczne, wysoka niezawodność, a w dodatku jeszcze ma być to szybko,
a w dodatku jeszcze ograniczenia pamięci,
więc, no, bardzo duży wysiłek będzie trzeba włożyć w realizację tego projektu.
Czyli widzicie Państwo, z tej wartości podstawowej, takiej określonej tylko na podstawie wielkości projektu szacowanej,
no, biorąc pod uwagę różne parametry samego produktu,
na przykład niezawodność, ograniczenia pamięci, złożoność,
jak i również warunków, w jakich ten projekt jest realizowany,
czyli na przykład zespół, harmonogram.
Widzicie Państwo, jak to bardzo wpływa na wielkość tego realizowanego projektu.
A teraz proszę popatrzeć na drugi przykład,
gdzie też mamy ten sam punkt startowy, z tym 128 kilo delivered source instruction,
ale nie mamy tutaj żadnych ograniczeń co do parametrów niezawodnościowych.
Nie będziemy musieli żadnych specjalistycznych zmian,
specjalistycznych technik stosować,
no, więc odpada nam pewien wysiłek.
Też w miarę prosty, szacujemy, że ten projekt jest prosty,
nie ma ograniczeń na pamięć.
W dużym stopniu korzystamy z takich narzędzi wspomagających projektowanie,
no i ta, szacujemy, że ta część tego automatycznie wygenerowanego kodu będzie, prawda, wysoka.
Pracujemy sobie tak, jak żeśmy sobie to,
określili jak nam jest wygodnie,
czyli tutaj ten harmonogram jest 1,
no to proszę Państwa, jak pomnożymy teraz te współczynniki przez siebie, tak,
0,75 razy 0,7 razy 0,9,
mamy jedynki, nic to nam nie zmienia,
to razy 1216 osobomiesięcy,
to wychodzi 575.
Tutaj, no, wyszliśmy z pewnego,
wspólnego punktu związanego z funkcjami, jakie ten projekt ma spełniać, prawda,
z pracowaniem z punktów funkcyjnych wielkości tego projektu,
natomiast będą to projekty zupełnie różne,
o zupełnie innych własnościach
i te różne własności tego produktu właśnie w tych współczynnikach uwzględniamy.
Czy to jest jasne, to co Państwu tutaj pokazałam, te przykłady?
Nie ma żadnych wątpliwości,
jak to, skąd się te liczby wzięły, dlaczego takie, a nie inne.
Proszę Państwa, no, chyba 9 lutego, ile dobrze pamiętam,
mamy pierwszy termin egzaminu
i takich zadań, jak to, które tutaj przed chwileczką pokazałam, należy się spodziewać,
no, bo łatwo jest mi takie zadanie, prawda, wymyśleć i wpisać
i automatycznie może być sprawdzane.
Będziecie Państwo musieli podać po prostu pewną konkretną liczbę, tak,
czy przy założonych współczynnikach, albo sami przyjąć jakieś współczynniki
i dla tych przyjętych współczynników policzyć coś.
Także proszę sobie zaznaczyć, że na pewno takie zadanie,
może nawet więcej niż jedno zadanie,
może nawet więcej niż jedno zadanie, może nawet więcej niż jedno zadanie,
ale jeszcze jedno z dzisiejszego wykładu pojawi się na egzaminie.
Dlatego jeśli coś,
macie Państwo jakieś wątpliwości, to...
Proszę Państwa, dwie minutki przerwy technicznej,
bo tutaj bratanek się magnificentnicze imię, obudził loro...
...na 3 minuty przerwę techniczną, dobrze?
Przepraszam Państwa, ale mamy sytuację,
Dzień dobry, ja na chwileczkę zatrzymam nagrywanie i transkrypcję.
---------------------------------------------Brat wyjechał, bratowa pracuje, a młody się rozchorował dzisiaj w nocy, więc bardzo Państwa przepraszam, ale trzeba było mu podać herbatkę i jak gdyby do łóżeczka z powrotem wstawić.
Także bardzo, bardzo przepraszam, ale będziemy dalej działać.
Dobra, czyli wracam do tematyki szacowania kosztów. Podkreślam, że na pewno z tego będą zadania jakieś na egzaminie, więc jeżeli macie Państwo jakiekolwiek tutaj wątpliwości i pytania, to proszę nie zwlekać i od razu tak.
Takie pytania zadawać, żeby nie było problemów.
Proszę Państwa, teraz ja mówiłam Państwu, że właśnie często firmy prowadzą takie bazy danych z informacjami o wcześniej zrealizowanych projektach.
I jeżeli takie bazy danych mają, to też mogą...
Mogą sobie policzyć taki współczynnik kalibracji, czyli mają szacowane koszty realizacji projektu, tego wysiłku potrzebnego do realizacji projektu, jego czasu trwania, bo za chwilę jeszcze pokażę Państwu, że również jest wzór na czas trwania projektu.
I jak się ten projekt, prawda, kolejny, jeżeli mają takie dane z wielu projektów, to mogą policzyć takie...
Współczynnik kalibracji z tych swoich projektów, jak im to wychodziło, prawda, i jakie były rzeczywiste koszty w stosunku do tych szacowanych, przez ile należy na przykład te szacowane koszty przemnożyć, żeby się zbliżyć do tej właściwej wartości, tej rzeczywistej wartości.
Więc właśnie takie współczynniki kalibracji firmy często mają na podstawie danych dotyczących projektów.
Projektów, prawda, tych wcześniej już zrealizowanych.
I, proszę Państwa, i takie dane bardzo pilnie są strzeżone, żeby, prawda, nikt nie miał do nich dostępu.
To jest sprawa indywidualna firmy.
Mówiłam Państwu, że można policzyć również czas trwania projektu.
I właśnie popatrzmy, mamy ten przez Barego Boema, znowu eksperymentalnie dobrane wzory do tutaj tych trzech typów.
Projektów, projektów prostych, średnich i złożonych.
To, co tutaj Państwo widzicie, to Person Permanent, to jest wysiłek potrzebny do realizacji projektu, ten policzony z tych odpowiednich wzorów, które przed chwilą Państwu pokazywałam.
Proszę popatrzeć, tutaj już współczynnik jest identyczny dla wszystkich trzech typów projektów.
Są różnice w wykładniku, prawda.
I teraz popatrzmy, jak to wygląda.
I teraz popatrzmy, jak to wygląda.
I teraz popatrzmy, jak to wygląda.
I teraz popatrzmy, jak to wygląda.
Na podstawie punktów funkcyjnych.
Policzyliśmy, że mamy trzydzieści dwa tysiące przewidywanych linii kodu.
Czyli trzydzieści dwa kilo delivery source instruction.
Jak to, teraz sobie na przykład, tu jest co prawda powyżej trzydziestu ja Państwu powiedziałam, że proste projekty to jest do trzydziestu.
jak to teraz sobie na przykład, tu jest co prawda powyżej trzydziestu ja Państwu powiedziałam, że proste projekty to jest do trzydziestu.
Ale na przykład, jeżeli my mamy doświadczenie w tej dziedzinie, jeżeli robiliśmy już w tej dziedzinie jakieś projekty, to możemy tutaj przyjąć, że jest to projekt prosty, mimo że ma powyżej 30 kilo DeliverSource Instruction.
Bierzemy wzór na projekt prosty, wstawiamy to 32 kilo, prawda, i wychodzi nam 91 osobomiesięcy jako wysiłek potrzebny do realizacji projektu.
Te 91 osobomiesięcy wstawiamy do tego wzoru na projekt prosty, czyli wstawiamy tutaj, no i wychodzi nam z tego, tutaj widzicie Państwo podstawienie do wzoru,
wychodzi nam z tego, że...
Ten projekt powinien trwać 14 miesięcy.
Teraz jeszcze kilka, może jeszcze trzy, czy do tego mają Państwo jakieś wątpliwości, pytania, coś?
Wszystko jasne? Skąd te wartości, gdzie się co podstawia?
Ta ostatnia wartość, ta...
Tak?
Ta M chyba, to co to było?
Tutaj nie uwzględnialiśmy M w ogóle, ale w konkretnym przypadku tak.
Czyli w konkretnym przypadku tutaj przyjęliśmy M równe 1.
Czyli w ogóle nie braliśmy pod uwagę, bo ja nic Państwu nie powiedziałam o tym, jakie są własności tego projektu.
Ale gdybyśmy teraz, prawda, mamy specyfikację tego projektu, tak?
Mamy...
Eee...
I teraz należałoby do momentu, żebym ja tutaj mogła się tutaj...
Należałoby tutaj wtedy jeszcze przemnożyć to przez M, prawda?
I to M sobie z boku policzyć, wziąć pod uwagę te współczynniki, które albo zwiększą, albo zmniejszą wysiłek.
Tutaj jest przyjęte M równe 1.
Po prostu...
W tym prostym przykładzie chciałam Państwu pokazać tylko, jak się liczy ten czas trwania projektu, prawda?
Mając pewną wyliczoną wartość wysiłku potrzebnego do jego realizacji.
To 2 i pół skąd się wziąło?
Tak, Barry Bohem tak doświadczalnie dobrał.
To są wzory dobrane doświadczalnie, na podstawie danych z tysięcy projektów.
Po prostu z takim wartością współczynnika mu się te dane zgodziły.
Na podstawie tam tysięcy projektów on, no, wymyślił te wzory i dobrał te współczynniki tak, żeby mu pasowały do tych danych z tysięcy projektów.
Także te wartości wynikają, no...
Tak.
Tak, no...
No nie do końca z sufitu, prawda?
Ale, no, on po prostu stwierdził, że to pasuje, taki współczynnik, do tych danych, które miał zebrane w tej osobie.
Tak.
Tak, no, on po prostu stwierdził, że to pasuje, taki współczynnik, do tych danych, które miał zebrane w tej ogromnej bazie danych.
Dobra, czy coś może jeszcze macie Państwo jakieś pytania?
Proszę Państwa, teraz jeszcze...
Wydaje mi się, że jest to pewnie dla Was oczywiste, że na przykład tutaj w tym poprzednim przykładzie wyszło 91 osobomiesięcy person per month, prawda?
Czas trwania projektu.
No więc, no powiedzmy, że jedna osoba przez 90 miesięcy...
No, powiedzmy, że jedna osoba przez 90 miesięcy...
przez 91 miesięcy, no może by ten projekt zrobiła, tylko pewnie to już nie byłby w żaden sposób oczekiwany projekt.
jeżeli 91 osób, prawda, posadzimy i każemy im pracować przez miesiąc,
wiadomo, że w ciągu miesiąca nic z tego nie wyjdzie.
Więc to jest oczywiście pewien wysiłek, szacowany dla tego projektu,
ale, no, co innego jest kwestia tego szacowanego wysiłku.
Prawda?
Tutaj ten czas realizacji wyszedł nam z tego wzoru 14 miesięcy, natomiast jeśli chodzi o wielkość zespołu, to wielkość zespołu, no nie potrzebujemy,
znaczy różna liczba osób jest potrzebna w różnych etapach realizacji tego projektu i tutaj do tego celu, żeby sobie jak gdyby to popatrzeć, jak ten liczebność zespołu się kształtuje,
to to są, proszę Państwa, tak zwane krzywy Raylighta, które pokazują, one mogą być takie bardziej strome albo takie bardziej proste, to zależy od typu projektu.
To zależy od firmy, od oprogramowania, które tam jest realizowane, ale jak wiecie Państwo, generalnie one się zaczynają tutaj pewną niewielką wartością,
bo na początku, jak projekt startuje, to ta liczba osób zatrudnionych przy tym projekcie, potrzebnych przy tym projekcie, bo zatrudnionych może być inaczej,
potrzebnych przy projekcie jest niewielka. To są osoby, które pracują przy specyfikacji wymagań, prawda?
Dopracowują te wymagania. Potem ta liczba osób troszkę rośnie, przy tym projekcie architektury ogólnej tego systemu też nie potrzeba nam zbyt wiele osób, tak?
Ale potem już jak zaczynamy robić projekty szczegółowe poszczególnych na przykład modułów, to już ta liczba osób rośnie, bo coraz więcej nam będzie potrzebna.
Potem etap kodowania też rośnie, testy jednostkowe i tutaj mamy właśnie to takie maksimum.
Na tym etapie, prawda, pisania kodu i wykonywania testów jednostkowych.
Jak już ten etap testowania jednostkowego się kończy, zaczynamy składać to oprogramowanie, integrować to oprogramowanie, też robiąc oczywiście testy,
to coraz mniej, prawda, tych osób nam jest potrzebnych do realizacji tego projektu.
I tutaj na końcu widzicie Państwo taką asymptotę.
No też już jak projekt jest zakończony, pracuje u klienta, ale my potrzebujemy tutaj w firmie, no właśnie jeszcze jakieś osoby, które będą ten projekt dostarczały,
które być może będą wykonywały poprawki w tym, poprawki błędów, które klient zauważył, więc ta liczba osób tutaj zatrudnionych też, jak Państwo widzicie,
jest tutaj, znaczy potrzebnych przy tym projekcie jest niewielka, to wystarczy, żeby to były na przykład dwie osoby firmy.
które się tym konkretnym produktem będą zajmowały.
Natomiast no krzywa, czy ona jest taka bardziej płaska, czy ona jest bardziej stroma, no to zależy od typu projektu, zależy od zespołu, od rodzaju oprogramowania, które jest w tej firmie realizowane.
I tutaj też, proszę Państwa, może być tak, że jak gdyby firma, jeśli produkuje oprogramowanie określonego typu, tak, na przykład, nie wiem, oprogramowanie dla banków,
to ona też może mieć taką swoją krzywą, która jest, no, dopasowana do tych poprzednich projektów, które były w tej firmie wykonywane.
I wtedy oczywiście bardzo łatwo to też określić, ile osób, kiedy nam będzie potrzebnych.
Proszę Państwa, ten model, który Państwu pokazałam, nazywał się COCOMB.
Nie powiedziałam jeszcze, skąd się bierze ten skrót, mianowicie ten skrót się bierze od Constructive Cost Model, czyli taki, no, konstrukcyjny, prawda, model modelowania kosztów.
Ten, który Państwu pokazałam i mówiłam, że powstał w osiemdziesiątym pierwszym roku, to jest pierwsze takie COCOMO było.
Często właśnie podajemy te daty.
Podajemy ten rok.
Rok osiemdziesiąt jeden.
Często tam ten model nazywa się COCOMO osiemdziesiąt jeden.
Natomiast, natomiast, mówiłam Państwu, że tutaj tam, prawda, było ten, szacowana wielkość tego projektu.
Ale ja Państwu mówiłam, że to dotyczy kodu, który jest pisany ręcznie, tak, jak to się mówi, from scratch, z niczego.
Natomiast, no, przy aktualnie tworzonym oprogramowaniu,
my często korzystamy z gotowych elementów, tak.
Mamy część kodu, który jest automatycznie wygenerowane, szkielety kodu, na przykład z takich narzędzi typu CASE.
Wobec tego, no, ten model osiemdziesiąt jeden po prostu się zdezaktualizował.
I został zaproponowany też w Berkeley University model, który się nazywa COCOMO dwa.
I zobaczyli Państwo, że ten...
bo COCOMO osiemdziesiąt jeden jest, jak gdyby, jednym z jego fragmentów.
Ale tutaj, w tym modelu COCOMO dwa, no, już uwzględniono fakt, że część oprogramowania może być automatycznie wygenerowana.
Że, że możemy być może ponownie używać jakichś fragmentów.
Że być może do tych ponownie użytych fragmentów,
że być może do tych ponownie użytych fragmentów,
że być może do tych ponownie użytych fragmentów,
że być może do tych ponownie użytych fragmentów, prawda, żeby je właściwie użyć, musimy pewien czas poświęcić na zrozumienie tego lub na jakąś drobną modyfikację.
Więc te tutaj aspekty, że możemy modyfikować, że możemy generować, używać pewien gotowy kod, wzięto pod uwagę w modelu COCOMO dwa.
I ten model COCOMO dwa proponuje nam aż trzy poziomy.
I ten model COCOMO dwa proponuje nam aż trzy poziomy.
To jest właśnie tego modelowania kosztów.
Poziom pierwszy, tak zwany wczesnego prototypowania.
Poziom pierwszy, tak zwany wczesnego prototypowania.
Drugi, wczesnego projektowania.
I poziom trzeci, tak zwany postarchitektoniczny.
I ja za chwileczkę pokażę Państwu na czym te modele polegają.
Natomiast zanim do tego przejdę, to jeszcze chcę Państwu tutaj parę zdań powiedzieć o tak zwanych punktach obiektowych.
Natomiast zanim do tego przejdę, to jeszcze chcę Państwu tutaj parę zdań powiedzieć o tak zwanych punktach obiektowych.
obiektowych, które też mogą być wykorzystywane do szacowania wielkości tego systemu, który realizujemy. Nie zawsze te punkty funkcyjne, o których mówiłam dwa tygodnie temu są właściwe.
Czasem łatwiej nam to szacować w oparciu o punkty obiektowe. One zostały zaproponowane przez Bankera w 1992 roku właśnie jako pewne alternatywne podejście do punktów funkcyjnych.
I teraz mimo, że one się nazywają obiektowe, to one proszę Państwa nie są związane, nie są to klasy projektu, czyli co to jest ten punkt obiektowy.
I tutaj mamy właśnie przykłady takich punktów obiektowych. Może nie przykłady, a rodzaje takich punktów obiektowych, które możemy uwzględniać przy realizacji,
przy szacowaniu wielkości realizowanego systemu. A więc popatrzmy. Liczba wyświetlanych ekranów, liczba tworzonych raportów, liczba modułów,
które trzeba napisać w tym systemie. No i proszę Państwa tak, na przykład te rzeczy jak liczba wyświetlanych ekranów, które to nasze oprogramowanie ma wyświetlać,
jak raporty, które ma tworzyć, to to możemy proszę Państwa policzyć na podstawie specyfikacji. Jak mamy napisaną specyfikację, czy dostępną specyfikację tego naszego systemu,
wiemy co on ma robić, prawda, no to będziemy mogli właśnie policzyć jakie różne ekrany ma wyświetlać, jakie różne raporty ma generować.
Więc możemy te liczby, no na podstawie tej specyfikacji projektu uzyskać. Liczba modułów, które należy opracować, to jest proszę Państwa, jeżeli mamy projekt architektury tego systemu,
czyli też na w miarę wtyczny.
Jeżeli mamy projekt architektury tego systemu, czyli na wczesnych etapach realizacji projektu, to z tego projektu architektury, prawda, wynika ile modułów przewidujemy, że trzeba będzie przygotować,
aby na przykład uzupełnić ten kod automatycznie wygenerowany. Oczywiście niektóre na przykład z tych ekranów będzie łatwo wyprodukować, bo wszystkie dane są w systemie i łatwo to będzie wyprowadzić.
Oczywiście niektóre na przykład z tych ekranów będzie łatwo wyprodukować, bo wszystkie dane są w systemie i łatwo to będzie wyprowadzić.
Inne mogą być bardziej złożone, więc możemy proszę Państwa tutaj dla tych ekranów uwzględniać również wagi.
Na przykład dla bardziej złożonych ekranów, które to oprogramowanie ma realizować, no to tych ekranów, powiedzmy, ma być, tę wagę możemy przyjąć dwa czy trzy.
Podobnie z raportami.
Niektóre z tych wyprowadzonych raportów, informacji, jest reklamda za taką w Mysterio.
informacji, zaprogramowania są bardzo proste, bo wszystkie dane są w systemie już
i tylko należy po prostu je przekazać do tego raportu, tak, włożyć, wypisać.
Ale niektóre na przykład będą wymagały, nie wiem, posortowania czegoś,
wyciągnięcia czegoś, więc tutaj również możemy korzystać, możemy i powinniśmy
korzystać z takich współczynników, no złożoności tych raportów,
czyli z takich wag. Czy to będą proste, to na przykład tutaj raport prosty ma wagę 2,
a trudne, raporty trudne mają wagę 8. No i znowu na przykład na podstawie
tego opisu tego, co oprogramowanie ma robić, powiedzmy, że wyszło nam,
że ma być 10 raportów, z tego na przykład 2 raporty są proste,
tak, czyli będzie 2 razy 4, 2 to daje nam 4, na przykład 3 są średnie,
to będzie 3 razy 5, 15, tak, i pozostałe są trudne, czyli te pozostałe 5 mnożymy
przez 8, no to nam wychodzi tutaj, prawda, 40, tak, i 15, 55 i te proste 4, 59,
jak gdyby wyszedł nam taka liczba z tych związanych z stworzonymi
raportami.
Podobnie tutaj to, co to oprogramowanie ma wyświetlać też,
ile tych różnych typów ekranów, postaci tych ekranów i też dzielimy je
na pewne kategorie, których stosujemy współczynniki.
Liczba modułów, prawda, czyli z tego, proszę Państwa, wyjdzie nam jakaś liczba,
jak już sobie to policzymy dla konkretnego systemu, no to wyjdzie nam jakaś liczba,
że wyjdzie nam, że to jest powiedzmy 50, tak, albo to jest 40,
no to to jest, tak, 50 punktów obiektowych.
I co z tymi, co z tą liczbą się robi?
Otóż, no, mówiłam Państwu, że one są pewną alternatywą dla punktów funkcyjnych.
Czasem łatwiej jest policzyć te punkty obiektowe, a nie funkcyjne,
ale też przekonywałam Państwa, że daje się je policzyć na wczesnych etapach
realizacji projektu. Większość z nich wynika ze specyfikacji,
te dotyczące modułów na bardzo, jak gdyby, taki, no, pierwszy projekt
architektoniczny systemu. Więc one też pozwalają nam wcześniej oszacować wysiłek
potrzebny do realizacji projektu. Tutaj można uwzględnić również
użycie gotowych komponentów. Tu jest liczba punktów obiektowych, tak,
pewien procent ponownie użytych komponentów czy elementów.
I to wstawiamy sobie do tego wzoru, tak, dzielimy przez produktywność.
Skąd się bierze tą produktywność? Otóż, proszę Państwa, do tej produktywności
mamy takie tabelki, które Uniwersytet Berkeley właśnie z tych swoich baz danych
o projektach ma na podstawie tych danych, w tej bazie danych.
I, no, oczywiście ta produktywność bardzo zależy po pierwsze od tego,
jakie jest doświadczenie i umiejętności programisty. Czy one są bardzo małe,
czy może one są duże, czy są przeciętne. Także bierzemy pod uwagę
doświadczenie umiejętności programistów. Teraz bierzemy pod uwagę również
case, które są używane w tym projekcie. Czy te możliwości tego narzędzia
są małe, czy są duże, czy są bardzo duże. I, proszę Państwa, z tego właśnie
te tabelki przez Uniwersytet Berkeley udostępniane dają nam produktywność
programisty, no, na przykład takie liczby, które tutaj Państwu pokazałam.
Także można, no, jak gdyby z tych punktów obiektowych,
też policzyć, też policzyć wysiłek potrzebny do realizacji tego projektu.
Czy to jest, czy to jest jasne?
Czyli jeszcze raz, to sobie policzymy, prawda, bierzemy te raporty,
bierzemy ekrany, czy te moduły, tak, dostajemy pewne,
pewną liczbę w zależności od tego, jakie wagi przypisujemy poszczególnym
typom tych punktów obiektowych. Uwzględniamy ponowne użycie gotowych
komponentów, tutaj jaki procent ponownie jest użyty, prawda, i korzystamy tutaj
z tej produktywności, która, jak widzicie Państwo, bardzo zależy od doświadczenia,
doświadczenia umiejętności programistów i również od,
zainteresowania narzędzi case'owych i, jakby, możliwości tego narzędzia case'owego,
które stosujemy.
Teraz, proszę Państwa, popatrzmy sobie na poziom wczesnego projektowania tego modelu
COCOMO 2. No to proszę popatrzeć, tutaj wzór na wysiłek jest 2,5, tak, razy,
1,5, 3,5, 4,5, 4,5, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 40, 41, 42, 43, 44, 45, 41, 42, 43, 44, 44, 45, 41, 44, 45, 46, 46, 47, 47, 48, 49, 49, 50, 51, 52, 51, 52, 52, 53, 52, 53, 52, 53, 54, 45, 45, 46, 47, 49, 52, 52, 53, 52, 53.
ręcznie przygotować. Tutaj mamy wykładnik S. Wartość tego wykładnika S
jest w zakresie od 1,1 do 1,24. Pamiętacie Państwo w tym wzorach Kokomo 81
ten wykładnik też miał taki zakres wartości, tam był od 1,05 do 1,2.
Ale tutaj proszę Państwa ten wykładnik nie jest stały. My ten wykładnik
będziemy liczyć i ja pokażę Państwu przykład w jaki sposób można ten wykładnik
policzyć, ale on w takim zakresie będzie się kształtował. I mamy to M,
które też to są te współczynniki dotyczące własności projektu,
i warunków w jakich jest on realizowany.
I tutaj w tym modelu wczesnego projektowania mamy, jak Państwo widzicie,
siedem takich współczynników, więc szacujemy wartości tych współczynników.
One też mogą być od 0,7 do 1,6 czy 1,4.
No właśnie biorąc pod uwagę,
czy to oprogramowanie ma spełniać jakieś wysokie wartości,
ma być wysoce, niezawodne, czy tutaj jeżeli stosujemy użycie wielokrotne
pewnych fragmentów kodu, no to wtedy zmniejsza to nasz wysiłek,
czyli wtedy ten współczynnik poniżej jedynki. Jeśli mamy trudności z platformą,
na przykład na której to oprogramowanie ma działać, no to też tutaj wtedy możemy
ten współczynnik dać powyżej jedynki.
Bierzemy pod uwagę możliwości personelu, czyli znowu na przykład,
jeżeli doświadczenie naszego personelu w tego typu projektach jest niewielkie,
to trzeba dać tutaj współczynnik powyżej jedynki, tutaj, prawda?
Jeżeli jest poniżej jedynki, czy pracujemy według takiego harmonogramu, jaki żeśmy sobie przygotowali,
czy ten harmonogram, jak gdyby naciski odgórne, no skracają nam ten harmonogram,
wtedy też tutaj należy wziąć współczynnik powyżej jedynki i jakieś dodatkowe udogodnienia pomocnicze.
No i teraz, proszę Państwa, to jest ta część, którą widzieliśmy przed chwileczką,
dotyczy tego kodu przygotowanego ręcznie, prawda? Czyli takiego, który trzeba napisać.
Ale my jeszcze tutaj korzystamy z kodu automatycznie wygenerowanego, często,
i dodajemy wysiłek związany z pewnym, właśnie z tym dostosowaniem tego kodu automatycznie wygenerowanego
do naszego systemu.
Widzicie Państwo, tutaj mamy podany wzór na to,
jak to policzyć.
Liczba automatycznie wygenerowanych linii, to nam narzędzia typu CASE podają.
Pewien odsetek tego kodu, który został wygenerowany automatycznie
i pewien poziom produktywności przy tworzeniu tego kodu.
Tutaj widzę, że gdzieś...
No i w ten sposób możemy policzyć znowu wysiłek potrzebny do...
realizacji projektu.
Kod, który piszemy i kod, który automatycznie został wygenerowany,
ale być może musimy troszkę też ten kod zrozumieć, prawda?
I dostosować.
I, proszę Państwa, poziom postarchitektoniczny,
to jest ten sam wzór, który przed chwilą Państwu pokazałam,
tyle, że mamy tutaj większą liczbę atrybutów.
Tutaj bierze się pod uwagę również te linie kodu,
które będą modyfikowane, żeby je dostosować do zmian.
Bierze się pod uwagę użycie wielokrotne.
To użycie wielokrotne, to jest też, proszę Państwa,
pewien wysiłek, prawda, związany z poszukiwaniem takich komponentów,
które możemy użyć.
To jest również wysiłek związany z...
ze zrozumieniem tych komponentów,
z dostosowaniem być może interfejsów,
z połączeniem ich, włączeniem ich do tego naszego kodu.
Także to też się bierze pod uwagę.
I tutaj pokazuję Państwu wzór na użycie tego wielokrotnego,
na wielkość kodu.
Właśnie.
Taka jak gdyby równoważna liczba wierszy tego nowego kodu
będzie potrzebna.
Kod używany wielokrotnie.
On być może będzie modyfikowany
w pewnym stopniu,
na ile projekt, na ile kod.
Praca związana z integracją tego kodu,
to jest ta IM.
I również zrozumienie.
No bo jak gdyby jeżeli ponownie używamy jakiś kod,
to musimy zrozumieć to coś, co wkładamy do naszego projektu.
Więc tutaj również ten koszt zrozumienia, prawda,
może być od 10 do 50,
w zależności od tego, czy to jest łatwo, czy trudno.
No i również tutaj ten AA,
to jest, który tutaj Państwo widzicie,
to jest początkowy koszt ustalenia,
czy może być użyte oprogramowanie wielokrotne.
I tu znowu przyjmuje się pewne wartości z zakresu od 0 do 8.
Także to też jak gdyby tutaj możemy policzyć
to użycie wielokrotne.
Teraz proszę Państwa, ja mówiłam Państwu, że,
że wykładnik, który mamy w tym wyrażeniu,
tam szacowana, prawda, wielkość tego kodu ręcznie pisanego
i wykładnik był S z zakresu od 1.1 do 1.24,
to się liczy.
I tutaj właśnie chcę Państwu pokazać
na podstawie czego ten wykładnik się liczy.
Otóż,
liczy się na podstawie takich pięciu cech.
I każda z tych cech,
każdy z tych elementów składowych
może mieć wartość od 0 do 5.
No, jeżeli,
gdyby spodziewamy się, że ta cecha będzie wpływała na,
wiemy, że będzie wpływała na wzrost wysiłku,
no to damy większą wartość, prawda,
czyli na przykład wartość 3, 4 czy 5.
No i jeżeli,
jeżeli to jak gdyby nie zwiększa wysiłku,
no to możemy dać wartość 0 albo wartość 1,
jak w niewielkim stopniu.
I popatrzmy, jakie tutaj są te pięć czynników,
które wpływa na nasz wykładnik
i które będą uwzględnione w wyliczeniu tego wykładnika.
A więc właśnie,
doświadczenie firmy z tego typu systemami, prawda?
Czy mamy jakieś doświadczenie, czy nie?
Na przykład, jeżeli mamy już,
jaki żeśmy robili,
ale no to powiedzmy 3,
taki poziom normalny.
I jeżeli robiliśmy bardzo wiele takich systemów,
no to na przykład może 1 wystarczy, czy 0.
Teraz elastyczność tworzenia,
udział klienta w trakcie realizacji naszego projektu.
Jeżeli ten udział klienta w trakcie realizacji projektu jest duży,
no to on będzie nam zmieniał w trakcie trwania projektu
na przykład pewne wymagania.
Będziemy musieli ten kod zmieniać, projekt zmieniać,
no to będzie większy wysiłek.
Więc wtedy na przykład trzeba wziąć tutaj jakąś wartość,
powiedzmy 4, czy nawet 5.
Jeżeli natomiast nie mamy tego udziału klienta
w trakcie realizacji tego projektu,
my po prostu ustaliliśmy, co oprogramowanie ma robić
i robimy to, damy mu potem gotowy produkt,
no to to nam tutaj, jak gdyby on nie utrudnia tej pracy,
więc możemy przyjąć wartość 0, czy wartość 1.
Teraz trzeci tutaj z tych elementów składowych,
wpładających na wielkość wykładnika, to jest,
kwestia analizy ryzyka.
No i proszę Państwa, jeżeli zrobiliśmy analizę ryzyka,
mamy jakieś przygotowane plany,
to na przykład możemy wziąć taką wartość tutaj powiedzmy średnią,
na przykład 3, czy 2.
Jeżeli natomiast nie mamy analizy ryzyka zrobionej,
to musimy uwzględnić to,
zwiększając tą część składową,
dlatego że wtedy, jeżeli w trakcie realizacji projektu
wystąpi coś niespodziewanego,
to my nie będziemy mieli przygotowanych planów reakcji na to
i to będzie jak gdyby bardzo wpływało na ten wysiłek
potrzebny do realizacji projektu.
Czwarta tutaj, czwarty ten element,
to jest kwestia zespołu, który pracuje przy tym projekcie.
Jeżeli zespół jest zintegrowany, dobrze ze sobą się komunikujący,
no to będą sobie wzajemnie, prawda, pomagać,
przekazywać informacje, więc tutaj możemy mieć wartość niższą,
na przykład 2, czy 1.
Jeżeli jest to zespół, który jest jakoś dobrany,
nie współpracowali ze sobą wcześniej, tak na szybko dobrany,
to nie jest zintegrowany, no to tutaj będą,
ta współpraca pomiędzy nimi będzie niewielka,
komunikacja będzie niewielka, będzie to zwiększało czas realizacji
tego projektu i wysiłek potrzebny, więc wtedy musimy wziąć jakąś
wartość większą, na przykład 4.
I piąty tutaj element, to jest, proszę Państwa, dojrzałość,
procesów w firmie.
Otóż firmy, można dla firmy ustalić tak zwany współczynnik dojrzałości,
który się nazywa Capability Maturity i ta wartość tego poziomu
dojrzałości firmy, to jest z zakresu od 1 do 5.
Przy czym tutaj,
ten poziom dojrzałości firmy odejmuje się od 5.
Mówiłam Państwu, że to najwyższy ten Capability Maturity level,
najwyższy to jest 5, więc jeżeli ta firma ma ten najwyższy poziom,
to to 5 odjąć 5, to tutaj ten składnik będzie wynosił 0.
Jeżeli firma jest na poziomie 3, to 3 odjęte od 5 da nam 2,
które tutaj uwzględniamy.
Teraz nie pamiętam, czy ja Państwu mówiłam o tym Capability Maturity model,
skąd to się wzięło.
To jest, proszę Państwa, rzecz, którą stosuje się od iluś lat.
Wzięła się ona Software Engineering Institute,
które był problem z...
W Stanach Zjednoczonych dużo oprogramowania robi się dla wojska
i są przetargi na dostawy tego oprogramowania.
I po prostu był problem, że jak gdyby trudno było określić
właśnie te firmy startujące w tych przetargach i prawda,
czasem przetarg wygrywała firma, która potem się okazało,
że nie jest w stanie tego zrobić albo robi to oprogramowanie bardzo kiepsko.
No i wtedy zaproponowano właśnie takie poziomy dojrzałości firmy,
które określa się na podstawie różnych sposobów działania tych firm,
firmy różnych praktyk, które się w tych firmach stosuje.
Dla każdego z tych poziomów jest opracowana lista praktyk,
które w firmie powinny być stosowane, jeżeli firma ma mieć właśnie ten poziom.
Tutaj dla ciekawości Państwu powiem, że firmy na poziomie 5,
czyli te takie niby z tym najwyższym poziomem dojrzałości...
Znaczy idea była taka, że im wyższy ten poziom dojrzałości firmy,
większa jest szansa na to, że ta firma zrobi dobre oprogramowanie
i zrobi je w przewidywanym czasie, co nie zawsze się sprawdza.
Otóż no właśnie taka ciekawostka, że firmy z tym poziomem 5,
największa liczba takich firm to jest, jak Państwo myślicie, w jakim kraju w świecie?
W Indiach.
Ktoś dobrze trafił, Indie właśnie. Właśnie w Indie.
Ten poziom 5 wiąże się właśnie z różnego rodzaju tych praktykami,
które trzeba stosować z różnym tam strojeniem, zbieraniem danych, dostosowaniem.
No i w Indiach się tym bawią.
To nie do końca oczywiście określa, bo może być tak,
że firma, która ma poziom dojrzałości na przykład 2,
jest w stanie to konkretne oprogramowanie bardzo dobrze zrealizować,
a firma na poziomie 5 zrobi to oprogramowanie,
ale niekoniecznie jego jakość będzie taka dobra.
Ale w każdym razie to jest jakiś ze sposobów oceny jakości firmy,
właśnie ten poziom dojrzałości z IMM.
I firmy to na podstawie właśnie tego, co się w nich dzieje,
jak wygląda ten przebieg produkcji,
czy zbierane są pewne wartości z procesu produkcji,
czy ten proces produkcji jest strojony tak, żeby te dane poprawić,
no to można je przypisać do jednego z tych pięciu poziomów.
No i teraz, proszę Państwa, popatrzmy co dalej, prawda?
Czyli tak, mamy te pięć składników takich,
które wpływają na wykłady.
Czyli wpływają na ten poziom dojrzałości, tak?
Każdy z nich może mieć wartość od 0 do 5.
Określamy ten poziom, dodajemy i co dalej?
Sumujemy je, dzielimy przez 100 to, co nam wyszło
i dodajemy do 1,01.
Chodzi o to, żeby w przypadku,
kiedy wszystkie mają 1,01,
wszystkie mają wartość 0,
żeby ten wykładnik był przynajmniej 1,01.
No i w ten sposób, proszę Państwa,
dostaniemy wartość tego wykładnika.
Proszę popatrzeć na taki prosty przykład.
No, wyobraźmy sobie, że firma po raz pierwszy realizuje
tego typu system, nie ma żadnych doświadczeń,
więc musimy wziąć tutaj maksymalną wartość tego współczynnika.
5, brak jest doświadczeń.
Nie mamy tutaj udziału klienta w trakcie realizacji tego projektu.
Wobec tego możemy tutaj przyjąć wartość, no, 1, taką niską, prawda?
Mamy dużą elastyczność w trakcie realizacji tego projektu.
Ale nasz zespół jest w miarę nowy,
więc tutaj też musimy wziąć taką wartość, no, ze środka, czyli 3,
bo będzie im trochę trudniej pracować.
I komunikować się i przekazywać sobie wiedzę i umiejętności.
Teraz nie prowadziliśmy analizy ryzyka,
czyli nie mamy przygotowanych jakichś planów takich, no, zapasowych
w przypadku, gdyby się coś nie udało, co mamy robić i jak działać.
Wobec tego bierzemy tutaj wartość tą 5, prawda?
Maksymalną, bo to brak tego, tej analizy ryzyka,
brak tych planów zapasowych, no, w przypadku, kiedy się coś wydarzy,
będzie wymagało bardzo, bardzo dużego wysiłku z naszej strony.
Jeśli zrobiliśmy tą analizę ryzyka wcześniej,
mamy przygotowane takie plany postępowania i działania w określonych sytuacjach,
no, po prostu jak gdyby stosujemy ten plan wtedy, kiedy to coś się wydarzy, prawda?
Już nie mamy dodatkowej pracy i wtedy, jeżeli ta analiza ryzyka została zrobiona,
no, wartość wtedy bierzemy mniejszą, na przykład 2 czy 3.
No i teraz, proszę Państwa, jest to firma na poziomie 2,
czyli bierzemy od 5, odejmujemy to 2, to nam wychodzi 3.
No i dodajemy teraz 5 plus 1 plus 3 plus 5 plus 3, to ile nam to wychodzi?
To wychodzi nam to 17.
I to 17 dzielimy teraz przez 100.
I dodajemy teraz 17 dzielimy teraz przez 100.
I dodajemy teraz 17 dzielimy teraz przez 100.
I to dodajemy do 1.01, czyli wykładnik uzyskujemy na poziomie 1.
Dokładnie 1 i 18 setnych.
I w trakcie egzaminu może się trafić jakieś zadanie z liczenia takiego wykładnika.
Więc jeśli są jakieś wątpliwości jak to się robi,
to może jest to dobry moment, żeby się o to spytać teraz.
te wszystkie
wartości tutaj
no z tych punktów
będziemy mieli podane na takim zadaniu
no nie wszystkie, no bo jakbym podała
wszystkie to wie pan, no dodać
je to byłoby trochę
za mało, czyli część z nich
na przykład może być podana
może być jakiś dodatkowy
opis podany i
wtedy no wasze zadanie
będzie, żeby któryś z tych współczynników
nie wiem, zwiększyć
zmniejszyć, albo przyjąć
jakiś, czyli na przykład
wyobraźmy sobie takie zadanie, że podaję
wam tutaj te dane, że w tej
firmie jest tak, siak, inaczej
że na przykład
zwykle
te wartości
tych współczynników są takie
ale na przykład może być informacja
o tym, ale
w tym projekcie mamy
zwiększone ryzyko
w stosunku do poprzednich
to co państwo byście zrobili
że w tym konkretnym projekcie
dla którego macie podać ten współczynnik
jest zwiększone ryzyko
w stosunku do
poprzednich projektów, a te dane
z poprzednich projektów macie podane
to co zrobicie wtedy
trzeba ten
współczynnik od analizy ryzyka
zmienić?
dokładnie, tak
i co z nim zrobić, jak jest większe ryzyko
to co z nim zrobić
no jak się pojawia jakaś sytuacja
prawda, taka
no nietypowa, związana z tym ryzykiem
no to musimy
prawda, działać, musimy
pewne czynności w tej sytuacji
robić takie, może nietypowe
więc
tak
, będzie
zwiększony
tutaj wysiłek
czyli musimy zwiększyć ten wykładnik
żeby zwiększyć ten wykładnik
to musimy zwiększyć
właśnie ten
no ten element
prawda, związany z ryzykiem
jak będzie powiedziane
zwyczajowo jest na takim
i na takim poziomie, ale w tym
projekcie ryzyko jest
mniejsze, no to
zmniejszycie, czyli na przykład
będzie podane
że zwykle jest tutaj
ten współczynnik ma wartość 3
ale w tym konkretnym projekcie
ryzyko jest mniejsze
to co zrobicie
zmniejszone
dobrze, zmniejszycie
zmniejszycie, weźmiecie
i wtedy trzeba będzie napisać
że na przykład przyjąłem 2
tak, albo przyjąłem 1
bo
no bo jest mniejsze
tak
ryzyko może mieć większą wartość niż 5?
nie, nie może mieć
nie może mieć
czyli jeżeli by była taka sytuacja
tak, że już jest 5
tak, a ja mówię
a w tej treści zadania macie
że no ale tutaj
ryzyko jest jeszcze większe niż zazwyczaj
więc tu już nie możecie
tym współczynnikiem manipulować
ale
moglibyście wtedy
na przykład tutaj jak gdyby
no ten zwiększony wysiłek
przerzucić na
na przykład na
jak gdyby na zespół, który
będzie musiał i na przykład zwiększyć
jakiś inny współczynnik
powiedzmy ten związany z
z doświadczeniami zespołu
tak, z jego umiejętnościami
dobra, także tego typu zadanie
też może się pojawić na egzaminie
lub
18 to jest
z wymnożenia tych
współczynników, tak
a co pan ma tutaj
jakie działanie pan ma tutaj
znaczy
wykładnik będzie miał wartość
1, znaczy
tak, jeszcze raz, wracam do poprzedniego
slajdu
sumujemy te 5 czynników
tak, wyszło nam 17
dzielimy przez 100
i dodajemy do 1,01
dlatego tu nam wyszło 17
podzielić przez 100
jest 17 setnych
dodajemy do 1,01
wychodzi 1,18
jasne
teraz?
tak, ok, dobra
wszyscy wiedzą co
i jak, tutaj pan
który tam mówił o tych współczynnikach
wyżej, niżej
proszę się wpisać w czacie
jeszcze pan dostanie plusy za dzisiejsze
zajęcia, ostatnia szansa
dostania jeszcze jakiś
plusów, które ja potem
przeliczę to na pewno
nie wiem czy dzisiaj
i jako takie te punkty
dodatkowe, startowe, one się tam pojawią
pewnie w UBI
na pewno będą uwzględnione
przy wyznaczaniu wartości
wyniku z egzaminu
dobra, czyli tutaj te rzeczy
związane z liczeniem
wysiłku, wszystko jasne
oczywiste
proszę państwa, mamy tutaj
17 atrybutów
ja już no
chcę tylko pokazać
jakie, widzicie państwo
17 jest bardzo dużo, czyli tutaj
można różne
aspekty tego systemu
i warunków w jakich
system jest tworzony uwzględnić
na przykład właśnie związane z
niezawodnością systemu, czy jest zwiększona
czy zmniejszona, to są proszę
państwa te współczynniki
takie, które wpływają na M
czyli mamy tutaj
17 wymnażamy
czy wszystkie 17
użyjemy, czy użyjemy tylko kilku
to już oczywiście zależy od konkretnego
projektu, zależy od nas
ale one przemnożone
przez siebie, tak, dają
nam wartość tego M, który
wpływa na wysiłek potrzebny
do realizacji projektu, tak
więc
wymagana niezawodność
złożoność
dokumentacja proszę popatrzeć też
czy ona jak gdyby jest
wymagana jakaś szczególna
dobrze zrobiona, czy niekoniecznie
i w tym przypadku
co dalej mamy
atrybuty komputera
na którym to ma działać
czyli ograniczenia na czas działania
ograniczenia pamięciowe
platforma tworzenia
i atrybuty personelu
doświadczenia ich
w tej dziedzinie
możliwości
tutaj
widzi państwo zarówno
analitycy jak i programiści
są brakującym tego
że oni nie zostali pod uwagę
również doświadczenia ich w stosowaniu
języków, w stosowaniu narzędzi
case'owych
no i samo przedsięwzięcie
czyli czy korzystamy
z takich narzędzi typu
case
czy mamy tutaj
musimy wykonać coś
w przyspieszonym
harmonogramie
czy może nie, więc jeżeli tak
no to powyżej jedynki ten
współczynnik, no i jeżeli
mamy tutaj powiedzmy ten projekt
rozproszony po różnych
ośrodkach to być może tutaj dojdą
takie narzuty związane
z komunikacją pomiędzy tymi
ośrodkami, więc trzeba będzie to
uwzględnić tutaj zwiększając
ten współczynnik site powyżej
jedynki, każdy z nich
z zakresu 0,7 do
1,6
maksymalnie
no i proszę państwa
to nam ten wzór
daje nam to person per month
po tym policzeniu wykładnika
proszę popatrzeć teraz
w tym modelu kokomo 2
mamy ponieważ
mamy już policzony
ten
wysiłek potrzebny do realizacji
w tym wysiłku mieliśmy policzony
wykładnik również
i proszę popatrzeć ten wykładnik
jest użyty tutaj również
w tym wzorze
jeżeli jest on
prawda
tutaj był policzony przy tym jeżeli
jesteśmy na poziomie wczesnego
prototypowania no to tutaj
przyjmujemy że on ma wartość 1
no i
znowu można tutaj uwzględnić
jeszcze ewentualnie skrócenie
czy wydłużenie harmonogramu
właśnie albo biorąc
tutaj ten współczynnik
powyżej dzielony
przez to żeby nam wyszło
powyżej jedynki czy poniżej jedynki
no i popatrzmy
na jakiś przykład
liczyliśmy współczynnik
prawda
przykładowy wyszło nam
osiemnaście setnych tutaj mam
no zmniejszony o jeden na przykład
siedemnaście setnych powiedzmy
na przykład dlatego że ryzyko
w tym projekcie jest
mniejsze niż
zazwyczaj i
wstawiając to do tego
wzoru który tam parę
wcześniej slajdów Państwu pokazałam wyszło
nam że
to jest 60
osobomiesięcy
to 60
wstawiamy proszę Państwa tutaj
ten wykładnik 1 i 17
setnych wstawiamy tutaj
to jest to nasze B
tak
i o właśnie i widzicie Państwo
i tutaj nam wyszło że
czas trwania tego projektu
no jest 13
miesięcy około 13
miesięcy
czy to jest jasne
czy do tego mają Państwo
może jakieś pytania uwagi
no to proszę Państwa
jak widzicie doszłam
do końca prezentacji
i jeszcze raz
czy są
jakieś pytania
uwagi do tego
tak
bardzo proszę
Panów którzy się
czy Pana który się odzywał w trakcie
o wpisanie
się na czacie żebym
była szansa dostania tych
punktów dodatkowych
i zwracam Państwa uwagę że
z tego wykładu który
przed chwileczką Państwu tutaj powiedziałam
na pewno będą zadania
na egzamin
i myślę że jest to
dobry moment żeby zrobić przerwę
ponieważ 5 minut
przerwy już wykorzystałam
wobec tego przerwa będzie trwała
10 minut
dobra wyłączam
nagrywanie
tak
wyłączam mikrofon
---------------------------------------------I teraz.
No i teraz proszę Państwa chcę powiedzieć troszkę o innym podejściu do projektowania systemów.
Dużo czasu poświęciłam w trakcie wykładu.
Podejściu obiektowemu.
Uczyliśmy się, poznawaliśmy Unified Modeling Language.
Standard światowy do modelowania i projektowania obiektowego.
Teraz chcę troszkę Państwu powiedzieć o analizie i projektowaniu strukturalnym.
Metody strukturalne proszę Państwa są to metody stare.
One powstały pod koniec lat sześćdziesiątych.
I polegają one na innym zupełnie.
Podejściu do właśnie tego projektowania systemu.
Mianowicie w tym projektowanym systemie szukamy takich elementów pasywnych,
które są związane z przechowywaniem w systemie danych.
No i te dane jakoś będą podlegały transformacjom, przetwarzaniu.
Czyli mamy pewne elementy aktywne w systemie, które właśnie będą te operacje,
gdzie na danych, wykonywane.
Takie jak gdyby dwie składowe wyróżniamy w tym projektowanym systemie.
No i będziemy proszę Państwa budować modele właśnie.
Będziemy modelować dane, które są przechowywane w tym systemie.
Ten model danych będziemy tworzyć, czyli tą pasywną część.
No będziemy również projektować, modelować tą część aktywną, czyli te funkcje.
I te dwa modele.
I te dwa modele są, ukazana jest ich współpraca w tak zwany data flow model.
Data flow diagram.
Model przepływu danych.
Będziemy tutaj te dane integrować w tym data flow diagram.
Przy czym te dane jeszcze też będziemy projektować szczegółowo, innymi mechanizmami.
Antity-relationship diagram.
Jeśli chodzi o strukturę, budowę, taką architekturę,
tego oprogramowania, to do tego celu wykorzystywane są drzewa struktur.
Proszę Państwa, dlaczego ja no co prawda chwileczkę i na ostatnim wykładzie,
ale dlaczego wspominam te metody strukturalne?
Dlatego, że one w niektórych zastosowaniach są nadal aktualne.
No po pierwsze mamy często nadal sporo systemów działa i trzeba je modyfikować.
I trzeba je adoptować, tych systemów starych, które były zrobione właśnie w oparciu o te metody.
Tak zwane legacy systems.
Na przykład w bankach często takie systemy działają, czy w niektórych firmach również.
Więc trzeba troszkę wiedzieć, żeby być w stanie tam jakieś poprawki w tych systemach zrobić.
Ale jeszcze ciągle przy projektowaniu relacyjnych baz danych,
też stosuje się te modele.
Czy w przypadku, kiedy system realizuje dosyć złożone funkcje, ale na prostych danych.
Czyli na przykład w systemach sterujących, w systemach sterowania.
Szczególnie wtedy, kiedy ma ten system działać bardzo szybko.
No to właśnie to podejście nadal się sprawdza.
Mówiłam Państwu, że to są metody stare, że one jakby wywodzą się z lat 60.
Ale tutaj proszę popatrzeć na parę.
Nazwisk, które właśnie w tych metodach mają znaczenie.
I tutaj widzicie Państwo, że to jest połowa lat 70.
Niklas, Wirth, Meyers, Konstantin i Jordan.
Oni tutaj bardzo dużo w tych metodach strukturalnych zrobili.
No i teraz jak takie metody działają.
Jakie narzędzia tu są stosowane.
Mówiłam Państwu, że mamy ten diagram przepływu danych.
Data flow diagram, ten skrót.
No to trzeba znać, bo to jest taki bardzo podstawowy.
I to jest proszę Państwa model, w którym projektujemy funkcje, które ten system ma realizować.
I to zwykle podchodzimy do tego w taki sposób hierarchiczny.
Czyli często będziemy mieli całą strukturę, całą hierarchię takich diagramów data flow diagram.
W którym będziemy no od funkcji takich bardzo ogólnych schodzić do funkcji szczegółowych, które ten system realizuje.
Mówiłam Państwu, że dane trzeba, że często w tych systemach pracujemy na danych i te dane trzeba zamodelować.
Do tego celu używamy diagramów związków ANSI entity relationship diagram.
Który pokazuje związki pomiędzy danami.
Sieć przejść.
State transition diagram.
Charakterystyka czasowa.
To są proszę Państwa diagramy zmian stanów, które modelują zachowanie w czasie tego systemu lub jego części.
I architektura systemu, struktura systemu za pomocą drzew, struktur.
No i teraz zacznę od tego data flow diagram.
Proszę Państwa.
Ja.
Czasu poświęciłam na pokazanie Państwu unified modeling language standardu modelowania obiektowego.
Nie ma takich standardów jeśli chodzi o metody strukturalne.
Wobec tego są bardzo różne notacje i bardzo różne jakby wskazania jak przygotować taki diagram przepływu danych.
Różne symbole graficzne są tutaj używane.
Ja pokażę Państwu takie, które są najczęściej stosowane, ale to nie znaczy, że powiedzmy w Waszej firmie czy pracując w ten sposób w tych metodach strukturalnych przy jakimś systemie, że będziecie stosowali właśnie dokładnie takich.
Mówiłam Państwu, że w tych diagramach przepływu danych mamy pewne miejsca, w których dane są przetwarzane.
To są tak zwane procesy.
Czyli.
Pokazujemy tutaj.
Pokazujemy tutaj pewne funkcje transformacji tych danych.
I zwykle te procesy zaznacza się na przykład kółeczkami, czy takimi eliksami, czy bąbelkami.
No i będziemy tą funkcję, która na tych danych jakieś tam operacje wykonuje nazywać.
No tak, żeby nam się to kojarzyło z tą realizowaną funkcją.
Przepływy danych to są, proszę Państwa, strzałeczki.
I one będą pokazywały, w którą stronę te dane przepływają.
Czasem na tych przepływach, ale nie zawsze.
Czasem będziemy jawnie te dane pisać, jak one się nazywają, które to dane przepływają.
No i bardzo ważnym elementem są miejsca przechowywania tych danych.
Czyli tak zwane data store, magazyny danych.
I proszę Państwa, taki chyba najczęściej stosowany model to są linie równoległe.
Jako magazyn przechowywania danych, jako data store.
Czasem prostokąty mogą być stosowane również.
I to jest po prostu zbiór danych, które ten system przechowuje.
Mamy również w tych data flow diagram.
Mamy takie terminatory.
Mamy takie interakcje.
Mamy interakcje z zewnętrznym.
Jak gdyby z tym, co jest na zewnątrz tego systemu.
Zwykle to są kółka.
Właśnie to są takie obiekty, z którymi ten system się komunikuje.
Na przykład inne systemy, czy użytkownicy.
Czyli ktoś coś, co do tego systemu dostarcza, odbiera pewne dane.
Jaki jest odpowiednik tego w metodach obiektowych?
W WML-u?
Czego to jest odpowiednik w WML-u?
Ktoś pamięta?
Pamiętacie Państwo określenie actor w WML-u?
To jest właśnie taki terminator, taka interakcja.
I w tych wcześniejszych metodach data flow było to nazwane terminatorem, interakcją.
Przedstawiane zazwyczaj kółeczkami.
Pokazuję Państwu taki prosty przykład data flow diagram.
Można by powiedzieć, że to jest taki data flow diagram, który na przykład sobie ponumerujemy jako zerowy.
Który pokazuje podstawowe funkcje systemu wysyłkowej sprzedaży książek.
I taki system ma takie podstawowe funkcje jak przyjmij zamówienie, pobierz należność.
Wyślij książkę.
Te funkcje sobie, czyli określają możliwości tego systemu na takim bardzo ogólnym poziomie, dlatego ja to nazwałam zero.
Poziom zerowy.
Można to nazwać system wysyłkowej sprzedaży książek, diagram zerowy.
No i teraz, proszę Państwa, te nasze terminatorzy.
Czyli te interakcje z tym systemem.
To są klienci.
Tutaj w tej notacji, ja tu, proszę Państwa, korzystam z książki Koda Jordona.
Która jest przetłumaczona na język polski.
To jest stamtąd wzięty ten obrazek.
To jest właśnie ten terminator klienci.
To jest również terminator klienci.
I magazyn książek.
Dlaczego ja ten terminator klienci tutaj narysowałam dwa razy?
Znaczy, no nie ja, a Kod z Jordanem.
Jak Państwo myślicie? Ktoś ma jakiś pomysł?
No dlatego, że gdybym go tu nie narysowała, to ta strzałka, że faktury idą do klienta, stąd by szła tutaj.
Byłoby dużo przecinających się linii, tak?
Ponownie, podobnie płatności, prawda?
By szły tutaj, tak?
Stąd tutaj.
Więc też...
Więc po to, żeby nie było...
Bo unikamy przecinania się linii.
Chodzi o to, aby ten diagram przepływu danych, który pokazuje te przepływy danych, żeby był łatwy do zrozumienia, łatwy do opanowania.
Tutaj, proszę Państwa, jako data store jest zastosowana notacja taka, że jest to prostokąt za okrąglonymi brzegami.
To jest bardzo często też stosowana notacja.
Czyli mamy tutaj magazyny danych zamówienia klienci.
Faktury, tak?
To są wszystko magazyny danych.
Informacje o zamówieniach, o klientach i faktury.
No i mamy strzałki, które pokazują, prawda?
Tutaj przepływy danych.
Czasem są te dane na tych strzałkach pokazane, czasem nie.
Czyli z tego terminatora jest interakcja klient, tak?
A mamy tutaj funkcję systemu przyjmij zamówienie od klienta.
Być może mu to zamówienie cofamy, więc widzimy tutaj, że z tego procesu przyjmij zamówienie, bo takie centra przetwarzania nazywamy procesami, tak?
Być może będzie przekazywana informacja o tym, że zamówienia są wadliwe.
Szczegóły zamówień wkładamy do magazynu zamówienia, tak?
Informacje z tego magazynu będą wykorzystywane przez proces wyślij książkę.
Tutaj zarówno terminator magazyn.
Tak?
Też będzie w tym uczestniczył.
I będziemy tutaj wykorzystywać informacje z magazynu klienci, gdzie te dane, prawda?
Któremu klientowi tą książkę trzeba wysłać są zapisane.
Tutaj widzimy szczegóły wysyłki, prawda?
Z klientów są przesyłane do tego procesu trzeciego wyślij książkę.
Szczegóły zamówienia, tak?
No do tego procesu też informacje o klientach może do tego procesu przyjmij zamówienie.
Informacje o procesie zamówienia.
O płatnościach wchodzą do magazynu faktury.
Proces pobierz należność korzysta z danych, które w tym magazynie faktury są zapisane.
Tutaj akurat widzimy te informacje, że są to nazwisko, szczegóły faktury, tak?
Ta faktura do klientów jest odsyłana, prawda?
Wtedy klient płaci.
No i ten proces wyślij książkę do klienta, tą książkę, prawda?
Czy książki wysyła.
Stąd tutaj widzimy ten przepływ danych.
Proszę Państwa, data flow diagram, który tutaj widzicie i który taka, takie jest podejście do tego, prawda?
To są miejsca, w których dane są przechowywane, magazyny danych.
To są przepływy danych, które oznaczamy strzałkami i czasem na tych przepływach danych, jakie dane przechodzą, czasem je pokazujemy.
Możemy, jeżeli to nam nie zaciemni tego obrazu.
Natomiast nie wynika z tego modelu, w jakiej kolejności te procesy będą wykonane.
W modelu data flow diagram powiedziane jest, mówi się, że proces może się wykonać wtedy, kiedy wszystkie potrzebne dane do niego dotrą.
Wtedy się może wykonać, tak?
Czyli pobierz należność, to dotarło, to dotarło.
Wtedy może się wykonać, tak?
I wysłać informację gdzieś dalej.
Czyli nie mamy tutaj, nie mamy tutaj kolejności na tych diagramach data flow diagram.
No, że pewna kolejność jest sensowna i istotna, to to będziemy musieli zapewnić w innych modelach.
Na przykład w modelach state transition diagram.
Czasem niektórzy pokazują przepływ informacji sterujących na takich diagramach.
Wtedy te informacje sterujące są, są wtedy zaznaczane takimi liniami przerywanymi.
Ale nie jest to zalecane.
Czyli nie zaleca się umieszczania informacji sterujących na diagramach przepływu danych.
Proszę Państwa, tak jak Państwu mówiłam, to jest taki diagram ogólny.
Pokazuje ogólne funkcje tego systemu wysyłkowej sprzedaży książek.
To jest za mało, żeby można było ten system realizować.
My musimy ten projekt, musimy uszczegółowić.
Jak to się robi? No robi się to w ten sposób, że ten proces, tak?
Który tu na przykład był pierwszy, drugi czy trzeci.
Że tworzymy diagram przepływu danych, który modeluje ten proces na niższym poziomie szczegółowości.
Czyli na przykład ten proces.
Czyli piszemy, potem te diagramy nazywają się diagram data flow diagram.
Na przykład będzie miał numer jeden, tak jak ten proces.
I on się nazywa przyjmij zamówienie.
I teraz ten, cały ten diagram będzie, do niego będą musiały być takie wejścia, jakie są do tego procesu.
Jeden przyjmij, czyli na przykład ja tu spróbuję narysować jakiś taki malutki.
Tak.
Że na przykład tą funkcję przyjmuj zamówienie.
Ja teraz tutaj dzielę na takie trzy funkcje niższego poziomu.
Jeden, jeden, jeden, dwa.
I na przykład jeden, trzy.
Tak.
Powiedzmy sprawdź te dane, zapisz te dane.
I teraz na przykład tutaj do niego sprawdź dane.
Powiedzmy wchodzą informacje od klienta.
A szczegóły zamówienia.
Tutaj musimy mieć też uwzględnić te magazyny danych, z którymi współpracuje ten proces.
Czyli on pracuje z zamówienia klienci i faktury.
Musimy też je tutaj uwzględnić.
Na przykład faktury, tak.
I klienci jeszcze też gdzieś tam.
Na przykład tutaj.
Szkoła mi się niedobrze rysuje.
I te przepływy muszą być zachowane.
Czyli na przykład stąd, prawda.
Tutaj powiedzmy dane wychodzą z tego.
A tutaj do faktury na przykład z tego.
A tu być może, że on będzie jeszcze korzystał ze swoich wewnętrznych magazynów danych,
które na potrzeby realizacji tej funkcji będzie musiał przygotować i trzymać w nich jakieś informacje.
Czyli mamy w ten sposób, tworzy nam się tak zresztą na przykład,
mamy w ten sposób, tworzy nam się taki model, taka struktura.
Być może, że te procesy, jak duża, jak głęboka ta struktura.
Ile poziomów takich diagramów.
Ta funkcja tutaj na przykład pierwsza, sprawdź to zamówienie, tak.
Ona tutaj może jeszcze jest zbyt mało dokładna.
Więc będziemy rysować diagram 1 i 1, który będzie tą funkcję modelował.
I tam te funkcje tego niższego poziomu, prawda, będą miały już numerację 1, 1, 1.
1, 1, 2, tak.
I ile ich tam będzie.
Jak dużo takich zagnieżdzionych diagramów, data flow diagram robimy, no to zależy od nas.
Chodzi o to, żeby zejść do poziomu funkcji takiej już, tej pojedynczej funkcji, pojedynczego procesu,
który da się,
jeszcze w inny sposób zamodelować, ale już na takim niskim poziomie, no takiego bardzo szczegółowej funkcji.
No prawie na tym poziomie, żeby się dało kod napisać, czy jeszcze jakiś model zrobić i od razu pisać kod.
No ale widzicie Państwo, że jeżeli, prawda, takie podejście będziemy stosować,
to dla takiego prostego systemu, jak ten, który tu widzimy z trzema funkcjami,
na tym najwyższym poziomie, to możemy mieć całe drzewo takich diagramów.
Data flow diagram, więc zwykle do trzeciego poziomu się schodzi, głębiej już nie, bo po prostu wtedy tych diagramów byłoby bardzo dużo
i byłoby nam się ciężko w tym wszystkim zorientować.
Czy do tego, co tutaj mówiłam, mają Państwo może jakieś pytania, uwagi, komentarze?
No właśnie, proszę Państwa, tutaj na tych diagramach pokazywaliśmy centra transformacji danych.
Nazywaliśmy tą funkcję przetwarzania trzech transformacji danych.
No nie było tu żadnych założeń dotyczących tego, w jaki sposób je należy realizować.
Tak jak mówiłam Państwu, zwykle one tworzą taką,
takie struktury hierarchiczne, żeby na pewnym poziomie dojść do już takiej dosyć szczegółowej funkcji
i wtedy tą funkcję szczegółową będziemy specyfikować innymi metodami,
które za chwileczkę Państwu pokażę na najniższym poziomie.
Ale widzieliście Państwo, że tutaj w tym data flow diagram, który tutaj miałam,
na przykład były tutaj, może ja wymarzę tutaj te swoje bazgroły,
na przykład były tutaj, może ja wymarzę tutaj te swoje bazgroły,
były tutaj na tych przepływach pokazane dane, które trzeba dokładnie opisać jakoś.
Więc potrzebne nam są tekstowe narzędzia, które będą opisywać te dane.
To się nazywa słownik danych, w których będziemy określać, jaką one mają mieć postać,
na przykład jak wygląda nazwisko klienta, tak?
Czy...
No i jeszcze będziemy na tym najniższym poziomie, czyli na przykład jeżeli,
powiedzmy, zdecydujemy się na trzeci poziom, no to każdą z tych funkcji trzeciego poziomu,
tak? Każdą i tutaj tych funkcji trzeciego poziomu, powiedzmy też na przykład 2, tak?
Aż do, nie wiem, na przykład 4, tak? Wszystkie te funkcje najniższych poziomów
będzie trzeba wyspecyfikować.
I pokażę Państwu, jakimi metodami.
No właśnie, tutaj widzimy taki przykładowy słownik, czyli widzimy to, co tam było nazwane nazwiskiem,
jak to ma wyglądać. Ma być nazwisko w postaci ciągu dozwolonych znaków.
Przedtem może być tytuł, ewentualnie imię, inicjał, tak? Tutaj mamy pokazane, jakie mogą być tytuły.
Widzimy, że imię to są dozwolone znaki.
A dozwolone znaki to są litery małe, duże, ewentualnie kreseczka czy apostrof.
To oczywiście już w konkretnym systemie, no my się decydujemy, jak to ma wyglądać.
Mówiłam Państwu, tworzymy taką hierarchię tych diagramów przepływu danych,
no a na najniższym poziomie musimy te procesy już wyspecyfikować w taki sposób,
żeby można było dla nich napisać kod.
W określonym języku uprogramowania.
Albo może, żeby taki kod się dało wygenerować.
Bo do takich narzędzi case'owych też mamy case'y do tych narzędzi strukturalnych, metod strukturalnych.
I tutaj, proszę Państwa, w jaki sposób możemy opisać ten proces, tą funkcję na tym najniższym poziomie,
czyli na przykład tutaj powiedzmy na tym trzecim poziomie, który w tym naszym przykładowym systemie,
był, prawda, no te funkcje mają, te procesy mają określone identyfikatory.
Na przykład ten jest 2 i 1, powiedzmy 3, tak.
Czyli na pierwszym poziomie miał on numer 2.
Na drugim poziomie ten drugi był rozpisany jakimiś podfunkcjami.
Tutaj pokazujemy funkcję pierwszą.
I na trzecim poziomie, no widzimy, że co najmniej trzy procesy tej pierwszej funkcji
były zidentyfikowane.
Więc po pierwsze możemy po prostu to opisać językiem naturalnym.
No ponieważ język naturalny jest taki mało precyzyjny,
więc za chwilę Państwu pokażę jakiś przykład, w którym zobaczymy, że często ten język naturalny jest
no uzupełniany takimi konstrukcjami, no pseudoprogramowymi,
które powodują, że ten, specyfikacja tego procesu jest bardziej precyzyjna.
Możemy po prostu podać pewne warunki początkowe i końcowe, które mają być spełnione dla tego procesu,
czyli za pomocą warunków początkowych i końcowych.
Możemy działanie tego procesu pokazać w postaci tablic decyzyjnych,
czy możemy algorytm działania tego procesu pokazać w diagramach przepływu sterowania,
jego pewną odmianą, taką łatwiejszą do pokazania,
jego pewną odmianą, taką łatwiejszą do pokazania,
jego pewną odmianą, taką łatwiejszą do pokazania,
na komputerze są diagramy Nasi-Schneidermana,
lub mamy inne, możemy stosować grafy, tabelki,
do pokazania tego procesu na najniższym poziomie,
czyli jak widzicie Państwo, wiele narzędzi.
No i tutaj właśnie pokazuję Państwu taki przykład specyfikacji procesu
w języku naturalnym, ale tak jak mówiłam Państwu, często ten język naturalny
uzupełniamy takimi konstrukcjami z języków programowania,
typu na przykład do, taka pętla do while,
lub tutaj mamy jakieś nawiasy, begin, end,
czy jakieś czynności twórz, dołóż.
No więc na przykład proces, tutaj mamy jego identyfikator,
który się nazywa wprowadź zamówienie,
który się nazywa wprowadź zamówienie,
tak długo, jak istnieje więcej pozycji zamówienia
w poprawnych szczegółach zamówienia,
to twórz rekord pozycji zamówienia z następnej w poprawnych szczegółach, itd.
Mówimy, co tutaj ma być robione, dołącz taki rekord do jakiegoś magazynu,
no i to wykonuj, prawda, tak jak tutaj Państwo widzicie,
wykonuj to w pętli do i end do.
Czyli właśnie czasem dodajemy takie konstrukcje,
twórz rekord, dołącz rekord.
Tutaj pojawiają się nazwy magazynów danych,
z którymi ten proces będzie współpracował.
Możemy, proszę Państwa, ten proces,
no na przykład ten, powiedzmy też on ma numer 114, tak,
wyspecyfikować za pomocą warunków początkowych i końcowych.
Czyli wyobraźmy sobie, że do tego procesu wpływają,
tutaj trzy dane, a wychodzi z niego jedna dana.
No i teraz, proszę Państwa, po pierwsze musimy określić
w tych warunkach początkowych, czy, bo ja mówiłam Państwu,
że proces się wykona wtedy, kiedy wszystkie dane potrzebne mu
do wykonania się będzie miał dostępne.
Ale może na przykład jest tak, że to x jest konieczne, tak, jest niezbędne,
ale to yz, powiedzmy, że nie musi być.
Albo może, że wystarczy, żeby jedna z nich była dostępna, tak.
No i określamy warunkiem końcowym to q, jak to q powstanie.
Może na przykład to q jest, powiedzmy, sumą tych wejść,
albo jakąś tam inną funkcją.
Czyli warunki początkowe, jakie dane muszą być gotowe
i w jaki sposób ten wynik jest produkowany.
Dziękuję.
W tych warunkach początkowych opisujemy związki pomiędzy wejściami
do tego procesu, tak jak Państwu pokazywałam,
lub jakie muszą być spełnione wewnątrz tych wejść.
Na przykład tu w tym poprzednim procesie, prawda,
że są trzy dane wejściowe, ale że dwie są niezbędne,
a trzecia, no może być, ale na przykład nie musi, tak.
Możemy tutaj opisywać również,
związki pomiędzy tymi wejściami, a magazynami danych,
takie dodatkowe, że na przykład istnieje zamówienie klienta
z numerem klienta, który pasuje do tego konkretnego klienta
w innym magazynie danych.
Można tutaj podawać związki pomiędzy różnymi magazynami danych,
wewnątrz tego samego magazynu.
Na przykład, że istnieje zamówienie,
w magazynie zamówienia,
czyli mamy tutaj magazyn, tak,
i w tym zamówieniu numer konta klienta
pasuje do numeru konta klienta w magazynie klientów,
czyli pomiędzy różnymi magazynami danych.
No i teraz, proszę Państwa, jak tutaj widzimy,
że prawda, coś pasuje, coś nie pasuje,
to możemy się domyśleć,
że tych warunków początkowych może być wiele.
I zaczynamy od przygotowania takich warunków,
kiedy wszystko idzie idealnie,
tak, wszystko jest, wszystko jest dostępne,
ale musimy również przygotować, opisać takie sytuacje,
w których coś pójdzie nie tak, albo czegoś nie ma,
albo jakieś warunki są niespełnione,
czyli takie alternatywne też będziemy musieli opisać.
Jeśli chodzi o warunki końcowe,
no to musimy opisać na przykład,
w jaki sposób ten wynik jest produkowany przez system,
opisać, jakie związki pomiędzy wartościami wynikowymi,
a wartościami wejściowymi mają zachodzić,
na przykład, że coś jest sumą, tak,
albo, nie wiem, że to jest iloczyn,
lub że to jest jakaś inna funkcja.
Możemy w warunkach końcowych,
podawać związki pomiędzy wartościami wynikowymi,
a wartościami w jednym, czy w kilku magazynach.
Na przykład, że saldo w magazynie, magazyn zostanie zwiększone, tak,
albo zostanie zmniejszone o coś, tak.
Możemy tutaj opisywać zmiany w magazynach danych,
czyli na przykład, że dochodzi jakaś nowa pozycja,
lub usuwamy pozycję, lub ją zmieniamy.
I tak, jak już wspomniałam,
zaczynamy od warunków normalnych,
takich, kiedy wszystko jest spełnione, wszystko działa.
Natomiast, również opisujemy sytuacje,
kiedy coś poszło nie tak,
albo musimy przewidzieć pewne sytuacje nieprawidłowe,
pewne sytuacje błędne.
No, bo jeśli tego nie zrobimy,
to potem te decyzje, prawda, będą leżały na problemie.
No, to powstanie problem,
to wtedy mamy problem z programiściem.
Inna metoda to są na przykład tablice decyzyjne,
które opisują, co proces ma wyprodukować.
Stosujemy je wtedy zwykle,
kiedy proces zależy od wielu zmiennych,
i w dodatku te zmienne mogą przyjmować różne wartości,
i w dodatku na przykład nie wszystkie z tych danych wejściowych są dostępne.
który ma na konkretnym przypadku podpowiedzieć, jaki lek ma być zastosowany
i tu mamy parametry tego chorego takie, że czy jego wiek jest większy niż 21,
czy ma więcej niż 21 lat, czy to jest mężczyzna, czy kobieta i ile waży,
czy jego waga jest większa niż 70 kg.
Mamy tutaj pokazane w tym moim przypadku pięć różnych sytuacji.
I w tej sytuacji pierwszej powiedzmy poprawnym lekiem, który powinien być stosowany
tym właściwym, czy najlepiej dostosowanym jest pierwszy,
a na przykład w sytuacji piątej powiedzmy lek piąty,
a w tej sytuacji piątej powiedzmy w ogóle jak gdyby nie przewidujemy tutaj
dawkowania jakiegokolwiek leku.
Czyli takie tablice decyzyjne wtedy, kiedy mamy wiele zmiennych,
kiedy te zmienne mogą być określone lub nie,
to mówimy co ten proces i no i wtedy, kiedy ten proces ma wyprodukować
jakąś jedną konkretną wartość, to te tablice decyzyjne bardzo dobrze się sprawdzają.
Myślę, że takie symbole notacyjne to Państwo dobrze znacie,
czyli rozejście warunkowe.
Tak, mam tutaj jakieś.
Warunek, zwykle go wpisuję, no i pokazuję co ma być zrobione,
jeśli ten warunek jest true, co ma być zrobione, jeśli ten warunek jest false.
I tu mam jakieś czynności, które ten proces robi.
Jeśli proces ma wykonywać jakieś czynności sekwencyjne,
no to je pokazuję na przykład w takich blokach C1, C2 i tak dalej.
No i takie diagramy przepływu sterowania, pewnie Państwo żeście wielokrotnie narysowali.
Z nich, proszę Państwa, wynika, bo my w nich opisujemy algorytm, jak ten proces ma działać.
No i teraz, jeśli mamy tutaj określony warunek, jeśli wiemy co tu ma być, co tu ma być,
no to z tego po prostu mamy gotowy kod, który może być realizowany.
Ponieważ taka forma, jak tutaj Państwo widzicie,
no jest troszkę trudniej rysować na ekranie,
na komputera, więc nasz i Schneiderman wymyślili taką postać,
że mamy, jak gdyby ekran to jest taki prostokąt,
czyli jak gdyby to, co ten proces ma robić jest takim prostokątem.
I jeśli ten proces wykonuje zdania sekwencyjne,
to dzielimy ten prostokąt na tyle zdań sekwencyjnych,
tu być może jakieś kolejne, które ma być zrobione.
Ale na przykład, jeśli mamy pewien warunek,
tutaj pokazujemy,
że na przykład x ma być mniejsze od 15, powiedzmy, tak.
Jeśli warunek jest prawdziwy, to wykonaj to.
Jeśli warunek jest nieprawdziwy, to wykonaj coś innego.
Widzicie Państwo, tutaj każda ta czynność, to jest też taki prostokąt,
w którym znowu możemy sobie wyobrazić, że jest tutaj jakiś kolejny warunek, tak.
I na przykład są jakieś procesy podane, czy tutaj mam jakiś inny warunek,
tu mam znowu true,
tu mam false, tak.
Mogę mieć, tu było rozejście warunkowe,
mogę mieć cykle.
Rób do, until, tak, dopóki pewien warunek jest spełniony.
No i tu w tym prostokącie na przykład pokazuję sekwencję czynności,
które ma robić.
A jeśli to jest rozejście warunkowe,
no to pokazuję to rozejście warunkowe, tak, na jakieś części.
Tu są dwie czynności,
a tu jest na przykład jedna czynność, tak.
Tu jest true, tu jest false,
a tu jest jakimiś kropeczkami oznaczony jakiś warunek.
Widzicie Państwo, że z takich diagramów Nancy Schneiderman'a, tak,
jeżeli wiemy, w jakim języku ma być ta realizacja,
na przykład realizacja ma być w C,
no to możemy automatycznie wygenerować ten kod.
A to się łatwo rysuje, łatwo się pokazuje na ekranie komputera.
Można również działanie procesu na najniższym poziomie
pokazać w postaci takiego grafu, tak jak tutaj Państwo widzicie,
że na przykład składka ubezpieczeniowa, powiedzmy, jest zaużależniona od wieku
i tutaj mamy pokazane, jak ona rośnie czy jak się utrzymuje.
Czyli na przykład wykresami, grafami możemy pokazywać,
jak ma się zachowywać proces.
Czy do tego, co mówiłam,
tutaj mają Państwo zauważyć, że jest to proces, który ma się zachowywać,
to Państwo może jakieś pytania?
No to teraz, proszę Państwa, popatrzmy na diagram związków NCI,
bo my musimy również te dane, które są w magazynach danych zaprojektować,
zamodelować.
No i do tego celu właśnie służą
diagramy związków NCI, nazywa się to Entity-Relationship Diagrams.
Tutaj właśnie to Entity, ta NCI, prawda, musi być w jakiś sposób
pokazane, jej związki z innymi NCI, jej zależności z innymi NCI.
Można powiedzieć, że to są właśnie te NCI, to są pewne typy obiektów,
że może być to zbiór,
może być to kolekcja obiektów,
które mają znaczenie dla tego budowalnego systemu,
mogą być jednoznacznie zidentyfikowane,
mogą być, mieć, opisane atrybutami
i zazwyczaj te typy obiektów
oznacza się prostokątami, bo jeszcze raz powtarzam Państwu, że nie ma tutaj
jednej metody,
nie ma tutaj zunifikowanej metody,
nie doszło tutaj do standardu.
Związki pomiędzy typami obiektów,
pomiędzy tymi NCIami, w większości przypadków przedstawiane są za pomocą oronów.
No więc popatrzmy, mamy tutaj NCI takie jak klient, bo zazwyczaj NCI to jest prostokąt,
zamówienie, faktura i książka.
I pokazane związki, pomiędzy klientem a fakturą otrzymuje, tak, klient otrzymuje fakturę.
Klient i zamówienie składa,
klient składa, klient otrzymuje, klient otrzymuje, klient otrzymuje fakturę.
Składa zamówienie.
Pomiędzy zamówienie a książka, zamówienie określa książkę.
To jest jedna z notacji, która może być stosowana
w diagramach związków NCI.
Mogą być oczywiście, proszę Państwa,
sytuacje, kiedy pomiędzy
tymi obiektami, tymi NCIami mamy więcej niż jeden związek, na przykład
pomiędzy lekarzem i pacjentem
może być związek leczy
i może być związek płaci.
Możemy kierunek takiego związku również pokazać, czyli na przykład lekarz leczy pacjenta, tak, a pacjent płaci lekarzowi.
I tak dalej.
Jakieś proszę Państwa skojarzenia z modelem,
z modelowaniem UML-u, WML-u mają Państwo na przykład dla
czegoś takiego bo oczywiście te dane w UML-u też modelujemy za pomocą
jakiegoś
Diagramu? Gdybyśmy chcieli dane w naszym projekcie zamodelować, korzystając z WML-a, to jaki diagram byśmy wykorzystali?
Dobra, jest. Klasy, dokładnie klasy.
Tyle tych obiektów, prawda, pacjent płaci, lekarz leczy, więc możemy oczywiście to samo robić i obecnie korzystamy z WML-a, a nie z tych metod strukturalnych, ale tak jak mówiłam, trochę tych starych systemów jeszcze ciągle jest.
Można być sytuacja taka, jak tutaj Państwo widzicie, że mamy związek pomiędzy trzema NC-ami, agent, nabywca, sprzedawca.
Ten związek nazywa się negocjujem.
Wiemy, że w WML-u też mamy możliwości związku pomiędzy trzema klasami.
Teraz tutaj też w niektórych notacjach można za pomocą strzałeczek pokazać kierunek.
Możemy pokazać, że jest wiele NC-towar, na przykład tutaj używając albo literkę N, albo zwielokratniając tą strzałeczkę znowu w zależności z jakiego narzędzia,
jakiego narzędzia korzystamy.
Z jakiej notacji to albo ten zapis jest dostępny.
Jak to robimy w WML-u?
Jak mamy wiele, to po jednej stronie, to pamiętacie Państwo?
Wiele, co tutaj mam naanalować.
Albo mogę podać konkretną liczbę, tak jak tutaj.
Jak jest tylko powiedziane, że wiele, no to na przykład strzałeczkę, gwiazdeczkę, dowolnie wiele.
A jak chcę powiedzieć, że co najmniej jedna jest obowiązkowa, no to na przykład od 1 do gwiazdka.
Możemy również tutaj w tych modelach przechowywać o związku pewne informacje i będzie to nazywało wskaźnik asocjowanych typów obiektów.
Popatrzcie Państwo.
Mamy tutaj klient, tak, na przykład kupuje towar, ta relacja się nazywa, powiedzmy, kupuje,
ale o tym zakupie chcemy przechowywać pewne informacje, więc mamy tutaj taki asocjowany z tą relacją właśnie typ obiektów
i w nim, w tej ENCY przechowujemy informacje, na przykład o tym, kiedy ten towar został kupiony.
Równoważny model WML-u jakby wyglądał?
Ktoś ma sugestie?
Mam klasę klient, mam klasę towar, tak, no na przykład kupuje to się nazywa, więc mam asocjacje, klient kupuje towar
i chcę o tym zakupie przechowywać informacje, to w WML-u miałabym tutaj asocjowaną klasę, która tutaj, jak gdyby,
przechowuje informacje o tym, kiedy, kiedy tutaj ten związek pomiędzy tykami i tu to, ta klasa by się nazywała też, na przykład zakup.
Czyli widzicie Państwo, jaka jest tutaj, no, jest odpowiednik pomiędzy tymi modelami.
Teraz w tych ENCY-ach, również niektóre z tych ENCY są bardziej ogólne, niektóre są bardziej specjalizowane,
czyli mówimy o takich ENCY-ach nadtypach i podtypach, na przykład pracownik jest takim nadtypem,
i mam pewne specjalne typy pracowników, jak pracownik na godziny, czy na etat zatrudniony.
ENCY-a może mieć pewne własności, pewne atrybuty, na przykład takim atrybutem pracownika może być jego nazwisko, adres, staż, powiedzmy, funkcja, jaką pełni, czy na jakiej jest zatrudniony.
I te atrybuty tego nadtypu będą dziedziczone, czy może raczej tutaj powiedzmy rola, jaką on pełni, tak.
I te atrybuty będą też w tym, w tej ENCY, która jest podtypem, ale ta ENCY-a będąca podtypem, tak, może mieć pewne swoje dodatkowe,
swoje dodatkowe.
specjalistyczne atrybuty,
na przykład ten na etat
zatrudniony, jaką ma pensję,
jaki procent premii może mieć.
Jak to by wyglądało
w WML-u? Jakaś sugestia
z Państwa strony?
Czyli mam tego
pracownika ogólnego,
mam pracownika
tutaj zatrudnionego na godziny.
Generalizacja. Bardzo dobrze.
Generalizacja, super.
I pracownik
zatrudniony na etat.
I tutaj używam
relacji generalizacji.
Do tego i do tego.
Teraz, proszę Państwa, inny model,
który tutaj możemy stosować,
to jest
State Transition Diagram.
Ponieważ
potrzebujemy zwykle w systemach
zamodelować również pewne
zachowanie tego systemu
lub tutaj, prawda,
zachowanie pewnych procesów.
Robi się to
dla tych procesów, no właśnie,
które mają dobrze
zdefiniowane działanie
i zachowanie, czyli dla tych procesów
na najniższym poziomie w hierarchii
diagramu DFD
i nie dla wszystkich procesów.
Bo tam już tych procesów
na niższego poziomu może być
kilkadziesiąt, czy nawet więcej.
Więc modelujemy,
robimy zachowanie, no właśnie,
takich procesów niektórych tylko,
których zachowanie się
bardzo może zmieniać i których zachowanie
jest bardzo istotne.
I pokazujemy to na
State Transition Diagram.
Diagram zmian stanów.
Tutaj, jeszcze raz
powtarzam, nie ma tutaj
standardu.
Więc tu te stany
mogą być różnie oznaczane.
Czy kółeczkami, czy prostokętami,
prawda, to różnie może być.
Zwyczaj,
znowu stan początkowy
to jest kropeczka
czarna, która tutaj
dochodzi. A jeszcze
możemy mieć na przykład stan
końcowy, którym powiedzmy też może być
ta kropeczka, tutaj tylko
podwójna.
Więc
State Transition Diagram. Stany,
w jakich ten
proces może się znajdować.
Pewne zdarzenia,
które powodują zmianę stanów
i być może pewne czynności,
które ten proces ma wykonać wtedy,
kiedy to zdarzenie ma miejsca.
Czyli jak mam zdarzenie start,
to na przykład ma się włączyć
napełnianie pralki, tak, i jest w stanie
napełnianie. Jak mam zdarzenie,
że pralka jest pełna,
to przechodzimy do stanu pranie
i tutaj, prawda, wykonywana
jest ta czynność. Jak mam zdarzenie
stop, no to
wracam i tak dalej. Czyli
mamy diagram zmian stanów,
który modelujemy
zachowanie procesów,
tych, których zachowanie
jest bardzo istotne, których zachowanie
się zmienia, modelowanie
procesów najniższego
poziomu.
Jakieś pytania do tego?
Może?
No i proszę Państwa,
musimy też, prawda,
zaprojektować architekturę tego
systemu, który realizujemy,
projektujemy za pomocą
tych metod strukturalnych.
Zwykle się to robi w postaci
takich struktur
drzewiastych
i jak on jest,
więc też często pokazujemy, prawda,
takie drzewo, gdzie poszczególne,
jak gdyby, poziomy
tego drzewa to odpowiadają modułom,
potem pod programą,
czy procedurą wewnątrz tego
procesu, wewnątrz tego
modułu, właśnie
jak gdyby pokazujemy, co jest wywoływane,
jakie funkcje, jakie moduły,
czy jakie funkcje są wywoływane.
I tutaj mamy jakiś przykład takiej
struktury, czyli mam jakiś
moduł główny, tak, którego
wywoływane są moduły
ABCD.
Mamy
tutaj jeszcze jakieś funkcje,
pobierz znak, który,
czy wypisz znak,
które są, prawda, wywoływane
w tych modułach,
ten wypisz znak C i D.
Tutaj z kolei
w module A,
w module B, jak widzimy,
wykonywana jest funkcja pobierz znak.
Pokazujemy strukturę,
takie drzewo, czyli to jest taki
moduł główny, wewnątrz niego
mamy wywoływania jakichś takich
modułów.
Można czasem pokazać
tutaj przepływ sterowania,
ale to też wtedy, jeżeli dodatkowymi
strzałeczkami, takimi liniami
przerwanymi, ale
to oczywiście by zaciemniało ten
obraz, więc ta struktura
sterowania wynika z tego,
co tam w tych diagramach zmian
stanów zrobimy. Można czasem
pokazywać, że coś jest zwracane,
że coś jest przekazywane,
tak jak tutaj Państwo widzicie,
te przekazywane są
tutaj, nie wiem, jakieś parametry,
jakieś dane w postaci
P i Q, tak, a tutaj
jest przekazywany znak, tak,
a tutaj coś jest tam znowu pobierane.
Więc
tak wygląda ten
diagram struktury i w ten sposób
projektujemy to
oprogramowanie, strukturę
takiego oprogramowania
strukturalnego.
Jakieś pytania,
uwagi do tego?
Proszę Państwa,
te
diagramy
i to modelowanie
w momencie
zatrzymam
udostępnianie
tego
jeszcze raz
podsumowując, prawda, to
powiedziałam Państwu
to bardzo szybko i
krótko, no bo
są to metody stare.
Może się zdarzyć,
że
może się zdarzyć, że one
jeszcze będą
Państwu potrzebne, bo tak jak
powiedziałam, sporo systemów, legacy system
było w ten sposób projektowanych
i jest i działa
i czasem musimy coś poprawić
w tych systemach, więc
dobrze by było, żebyśmy
to
przynajmniej troszkę
się w tym orientowali, umieli
zrozumieć to.
Pokazałam również Państwu
takie
odpowiedniości tego
do modelu UML-owego,
tak żebyście Państwo
czuli, że
ten UML
wywodzi się z tych
metod strukturalnych, bo taka
była kolejność.
No i żebyście Państwo,
prawda, wiedzieli, że jest
jak gdyby pewna możliwość przejścia
pomiędzy tymi modelami
i
pewna
możliwość przejścia pomiędzy
tymi modelami, prawda, i że
różne modele służą do
wyrażania
tych samych rzeczy.
Na tym powiedzmy,
że się skończyła
ta podstawowa,
jedna z tych modelów, która jest w tym modelu.
Jak gdyby
jeszcze
momencik, jeszcze sprawdzę.
Jeszcze szybciutko,
króciutko Państwu
powiem, bo użyłam dzisiaj,
tego określenia
CMM
i
przy okazji
wyliczania, prawda, tam na przykład
tego wykładnika,
więc
zobaczcie Państwo,
jak to wygląda z tym
CMM-em. Co to jest?
To jest króciutko
już.
...
,
skąd się wziął
ten model
właśnie
capability maturity model.
No, tak jak
Państwu mówiłam, chodziło o to, żeby
określając te poziomy dojrzałości
firmy, w jakiś sposób
mieć, no, większe
lub mniejsze zaufanie, co do
tego, czy pewna firma
startująca w przetargu, prawda,
dostarczy, dobrze zrobi to oprogramowanie,
czy mniej.
Natomiast,
oczywiście, jeżeli
mamy proces produkcji
właściwie realizowany, jeżeli
tam
zbieramy pewne informacje z tego
procesu produkcji, to możemy
jak gdyby być świadomi tego, że
pewne sytuacje,
no,
że się coś źle dzieje
w tym procesie produkcji, możemy to
monitorować, prawda, i możemy wtedy
coś zmieniać, więc
taka jest idea tego,
żeby ten proces produkcji,
udoskonalać.
Natomiast, żeby
móc go udoskonalać,
no, to trzeba, prawda, rozumieć
to, co się w tym procesie dzieje,
jakoś
mierzyć, zbierać informacje
o tym, co się w tym dzieje,
próbować to, próbować to
zmieniać,
modernizować,
dostosowywać.
Ja już to Państwu pokazywałam, na pewno
ten slajd, że jakość
tego produktu, który my
realizujemy,
zależy od kilku czynników.
Zależy
od jakości samego
procesu produkcji,
zależy od technologii,
którą stosujemy przy produkcji
tego oprogramowania,
zależy od tego, jaki mamy
czas, jakie koszty,
prawda, jaki harmonogram
realizacji tego projektu,
no, ale przede wszystkim zależy od ludzi,
którzy w tym
procesie produkcji, prawda, uczestniczą,
którzy ten projekt realizują.
Ale to, co w efekcie
dostajemy, to jest wypadkową tych
różnych czynników.
No i właśnie chodziło o to,
żeby ten proces produkcji
udoskonalać.
Mówiłam Państwu, że jest pięć
takich procesów,
pięć poziomów,
więc właśnie popatrzmy,
jak one wyglądają.
Poziom pierwszy
chodzi tutaj o analizę
samego procesu produkcji,
czyli badamy istniejący
proces produkcji,
staramy się zbudować
jakiś model tego procesu
produkcji,
może mierzyć pewne
wartości
w tym procesie produkcji,
czyli taką analizę ilości
tutaj robić.
Poziom drugi, troszkę bardziej
zaawansowany, to jest
szukanie wąskich gardeł
w tym procesie produkcji,
na przykład dotyczącym
kosztów czy czasu.
Poziom trzeci
to jest wprowadzanie zmian,
na przykład
zastosowanie nowych procedur
czy nowych narzędzi,
czy integracja ich.
Teraz musimy również
szkolić
naszych pracowników,
bo bez tego
jak gdyby te zmiany
nie będą przez nich
realizowane.
No i możemy,
gdyby zwykle
jest tak, że po wprowadzeniu
te zmiany od razu nie przynoszą
efektów,
często powstają pewne nowe problemy
i dopiero po usunięciu tych nowych
problemów widać, że te zmiany
rzeczywiście
przyniosły jakieś efekty,
na przykład skróciły czas
czy obniżyły koszty, a więc
strojenie.
Wspomniałam Państwu, że
właśnie w Software Engineering Institute
w Carnegie Mellon University
zaproponowano
taki model dojrzałości
procesów
i ten poziom dojrzałości
firmy właśnie jest wykorzystywany
w modelu COCOMO 2
do obliczania wykładnika.
I mówiłam Państwu,
że jak gdyby idea się
wzięła stąd, że
w wielu przetargach, szczególnie na
oprogramowanie wojskowe,
firmy, które nie miały
odpowiedniego
poziomu dojrzałości
i potem nie były w stanie
tego oprogramowania
zrealizować.
No i mamy właśnie pięć
poziomów,
które się wiążą
z tymi pięcioma
elementami, o których wspomniałam wcześniej.
Pięć.
Czyli tak, mamy proces
początkowy, nazywa się to
.
I tutaj na tym, jeżeli firma
jest na poziomie tym pierwszym,
początkowym, no to czasem pewne projekty
jej się udają, czasem pewne projekty
jej się nie udają.
Zależy, to nawet może być tak,
że powiedzmy w jednym
oddziale tej firmy to się
coś tam udaje lepiej, a w innym gorzej.
Poziom drugi .
To już jest tutaj
no trochę lepiej, jak gdyby
firma ma pewne ustalone
.
Czynności,
akcji, pewien ustalony proces
produkcji i powtarza
to. Ale tutaj
jeszcze też tak może być, że w jednym oddziale
wszystko super i ekstra, a
w innym mniej. Poziom trzeci
zdefiniowany, poziom czwarty
mierzalny i poziom piąty
to jest już ten
udoskonalony .
I teraz, proszę Państwa,
no właśnie, poziom pierwszy .
Nie ma tutaj
pewnych procedur kierowania planów
produkcji. Nie ma
mechanizmów, które zapewniają
ich spójne użycie. I tak jak mówiłam,
że może się zdarzyć, że
wyjdzie super, ale
jak gdyby może się okazać,
że na przykład znacznie
zostanie przekroczony koszt,
planowane koszty, przekroczone terminy.
Czyli tutaj wszystko jest na tym poziomie
pierwszym nieprzewidywalne.
Poziom drugi . Tutaj
już ta firma stosuje pewne
procedury zarządzania,
zapewniania jakości.
I przy
projektach tych samych typów
udaje jej się to dobrze robić, ale nie ma
formalnego modelu procesu.
Często zależy to
od miejsca, od kierownika
projektu, że jeden
w jednym miejscu mamy powiedzmy
kierownika, który potrafi
to zrobić i wtedy tam działa wszystko
super i ekstra, a
w innym projekty się
przedłużają, koszty ich rosną
bardzo. Poziom trzeci
poziom zdefiniowany
firma zdefiniowała
proces, ma
prowadzi bazę
w której
pewne ilościowe parametry
są zapisywane i one
mogą
być taką bazą do
ulepszania tego procesu produkcji.
Stosowane są formalne
procedury
zapewniające,
że ten proces jest stosowany.
Poziom czwarty
tutaj proszę Państwa zbieramy
różne dane ilościowe,
metryki tego procesu produkcji,
metryki produktu
i one są danymi
wejściowymi do
ulepszania tego procesu
i właśnie poziom piąty
ten z ulepszaniem
mamy określone mechanizmy
ciągłego poprawiania tego procesu
produkcji, to ulepszanie
jest planowane, jest wyceniane
i jest to integralna
część procesu.
Teraz
momencik.
Dobra.
Teraz proszę Państwa popatrzcie na to
jakie praktyki
są stosowane
na poszczególnych poziomach.
Na tym pierwszym initial
jak leci,
nie ma żadnych tam.
Natomiast jeżeli
firma jest na poziomie drugim
to zarządza wymaganiami,
prowadzi
plany tych projektów, śledzi
ten projekt, zarządza
programami, zapewnia
jakość oprogramowania, zarządza
konfiguracją oprogramowania.
Czyli tutaj już pewne mechanizmy są
wprowadzone.
No prawda
istotne jest zarządzanie
konfiguracją, śledzenie
przebiegu projektu, robienie
planów, harmonogramów.
Poziom trzeci
zdefiniowany, tutaj
jest proces, jest jak gdyby
w organizacji, ale
definiowany jest proces.
Miejmy pracowników,
zarządzamy
oprogramowaniem,
jest prowadzona koordynacja
grup, jest wprowadzone
recenzowanie szczegółowe.
Pamiętacie Państwo, mówiłam, że na przykład
wymagania powinny być recenzowane,
że często stosuje się
recenzowanie kodu po to, żeby
była lepsza jakość tego kodu.
Więc tutaj te praktyki są
wykonywane.
Poziom mierzalny i doskonalony
w mierzeniu, mierzymy
proces, mierzymy jakość
i na poziomie
piątym, jeżeli mamy, to
staramy się unikać defektów,
zarządzanie zmianami technologicznymi
i zmianami
procesów.
Także to, żebyście Państwo
mniej więcej wiedzieli, o co
chodzi
w tych poziomach
pięć,
tych poziomach CMM
od 1 do 5.
Tak jak Państwo
mówiłam,
firma
może
określić ten swój
poziom na podstawie
po prostu
odpowiedzi na
pytania w takich
testach,
czy wykonywane
są te
czynności. Ja tutaj Państwu ogólnie
te czynności w poszczególnych
poziomach czy praktyki w poszczególnych
poziomach pokazałam. No i teraz,
przeprowadzając takie ankiety
wśród pracowników,
możemy potem
określić, analizując wyniki
tych ankiet, na którym poziomie
dojrzałości ta firma
jest. Tak jak już mówiliśmy, w Indiach
jest najwięcej firm
na poziomie piątym,
no ale
to wcale nie znaczy, że
to oprogramowanie przygotowane
przez taką firmę na poziomie
piątym jest oprogramowaniem
lepszym od takiego,
które powiedzmy firma będąca na poziomie
trzecim zrobi, bo
to z tym różnie bywa. Natomiast
daje nam to troszkę większy
poziom ufności co do tego, że
w ogóle ten projekt zostanie zakończony.
Im wyższy poziom, tym mamy powiedzmy
ten poziom ufności wyżej.
Taka była idea
stworzenia tego capability
maturity model.
Czy do tego może mają Państwo
jakieś komentarze?
Może ktoś z Państwa
może
się przyznać na jakim poziomie
CMM jest
jego firma, czy firma, w której pracuje?
Znaczy może być tak,
że na przykład jakiś
działczy zespół w firmie jest
na jednym poziomie, a inny
na innym?
Bo często w korporacjach jest mnóstwo tych
projektów i to nie jest wszystko
zunifikowane chyba.
Znaczy wie Pan, tutaj jak gdyby
poziom całej firmy
pewnie byłby określony jako
ten najniższy mimo wszystko
z tych, które są.
Natomiast rzeczywiście może być tak, że
mamy tam ileś komórek w firmie
i jedne są bardziej
lepiej zorganizowane, mają
jak gdyby
pewne mechanizmy
stosują, które właśnie
pozwalają na śledzenie, na mierzenie,
na znajdowanie wąskich gardeł,
a inne działają tak na zasadzie
prawda ad hoc.
No to w efekcie będzie to zależało
od tego po prostu jak
kierownik
to prowadzi. Ale całą firmę
no to pewnie
najniższy poziom będzie określał mimo wszystko.
Okej.
Nie, znaczy to pewnie chodzi też
szczególnie przede wszystkim o firmy, które
wytwarzają oprogramowanie. Dokładnie.
To tylko chodzi
o takie firmy,
które tworzą oprogramowanie.
Tak.
No i tak jak Państwu mówiłam,
idea była taka, żeby w tym procesie
kiedy zgłaszają się
różne firmy, mamy przetarg, żeby
no jak gdyby większą siłę
przebicia miały te, znaczy
żeby wybór, prawda,
raczej wybierać te firmy z wyższych poziomów,
stąd tak no firmy
stosowały te różne metody,
żeby mieć ten poziom
wyżej. Ale jeszcze raz powtarzam,
że no nie zawsze tak to jest,
że to oprogramowanie, przygotowanie,
przygotowane przez firmę z poziomu piątego
jest takie super ekstra, że może być
tak, że ten z poziomu niższego, ale
no coś niecoś o firmie jednak
nam to mówi. Te poziomy dotyczą
wyłącznie firm produkujących
oprogramowanie.
I tak jak widzieliście, te poziomy
są, prawda, wykorzystywane
na przykład w
no w tym modelu
Kokomo 2
do wyznaczenia wartości
współczynnika,
wykładnika.
Tak, tak.
Ja chciałem jeszcze takie pytanie jeszcze.
Tak.
Czy można by było
jakoś jeszcze takie powtórzyć
taki przykład
z diagramem
sekwencji, takie przykładowe zadanie?
Jak najbardziej.
Mamy, proszę Państwa, jeszcze sporo czasu,
24 minuty do końca,
więc
materiał już
tutaj, prawda, szybciutko przeleciałam
właśnie po to
między innymi, żeby nam trochę takiego czasu
zostało i żebyśmy
mogli tutaj teraz
jakieś
no jakieś
własne
teraz, no żebym, jak gdyby moglibyśmy
przećwiczyć takie rzeczy, które są
Państwu potrzebne,
no i które się mogą
przydać, prawda, przed
tym, tego dziewiątego, bo chyba
dziewiątego mamy egzamin, o ile dobrze pamiętam.
Dobrze pamiętam?
I tutaj jeden z Panów
zasugerował, żeby
zrobić z diagramem
sekwencji coś, tak?
Czy chodzi
Panu o to zadanie
takie, jaka jest odpowiedniość,
żeby, no, diagram
sekwencji powiedzieć, co ma być na diagramie
klas? Takie zadanie? O to Panu chodziło?
Tak, tak, tak.
I właśnie
też Pani pokazywała taki program,
który rysuje się
do diagramu klas, no to
czy mogłaby Pani jakoś też tak
pokazać mniej więcej
jak to się tam rysuje,
bo tam to jest takie trochę
złożone, ten program.
Tak, tak, ten program jest złożony
rzeczywiście,
znaczy ten program byłby mi przydatny teraz,
żeby na przykład jakiś
przykład robić, prawda, to byśmy wtedy
coś mogli.
Momencik, pierwsza rzecz, ja zobaczę, czy mi
się uda połączyć z Aleksandrem, bo to jest,
jak gdyby, pierwszy punkt,
bo to też nie zawsze się
udaje.
...
Na razie mam problem,
żeby się połączyć z Aleksandrem,
więc może spróbujmy na razie to zrobić
no w cudzysłowie
na sucho.
Chyba, że komuś z Państwa się uda
i wtedy ja będę podpowiadać, ktoś
udostępni swój ekran i ja będę
podpowiadać, to możemy tak zrobić.
Ja mam jakoś dzisiaj
chyba z tym problem.
Natomiast możemy...
Tak?
Jaki to jest program?
To się program nazywa
Rational Software
Architect.
Ten, który ja używałam. Być może, że w szkole
macie coś innego również.
A na egzaminie nie będzie trzeba konkretnie
z tego korzystać?
Proszę Państwa, z programu absolutnie
nie będzie trzeba korzystać. Nie,
będziecie Państwo rysować te diagramy,
nie wiem,
będziecie te diagramy
rysować po prostu,
no,
pomocą pudełeczek, prostokącików,
jeżeli rysować, albo odręcznie
i potem takie rysunki, czyli
nie, absolutnie nie
wymagam od Państwa stosowania tego programu.
Program jest złożony.
W czasach, jak prowadziłam laboratorium z inżynierii
oprogramowania, to dwie godziny
na pierwszych zajęciach,
dwie, trzy godziny, to były w zasadzie
czasem nawet cztery, to były takie
zajęcia, taki tutorial z tego, jak się
z tego narzędzia korzysta
i jak to się
działa. Więc może
zrobimy po prostu tak,
że spróbujemy, zaraz, czy ja mam
tutaj, gdzie ja mam
jakieś przykłady?
...
Może ktoś z Państwa, kto robił
tą pracę domową taką, z tym
diagramem sekwencji i klasami,
ma szybko,
jak gdyby, dostępny
ten
...
ten plik
...
Ja spróbuję, Maciek, spróbuję
znaleźć to szybko.
... mogłym ewentualnie innym
narzędziem CASE, którego używaliśmy
na specjalizacji, na laboratorium
inżynierii.
...
To nie w tym
rationalu, tylko w innym.
Okej, bo są różne, jest jeszcze jakiś
modeler i jest
cała masa jest takich narzędzi.
...
Proszę Państwa, jeszcze raz powtarzam.
Narzędzia tutaj nie będziemy,
myślę, że szkoda czasu na pokazywanie
narzędzie, bo ono Wam nie będzie potrzebne
do egzaminu, bo
jeżeli będzie, popatrzmy na jakieś
przykładowe zadania, prawda?
Momencik, gdzie ja tutaj mam jakieś zadania?
...
...
Jak na złość nie
mogę ich znaleźć.
Już momencik, wchodzimy.
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
...
To nie to.
Dobra.
Proszę Państwa, znalazłam tutaj jakieś
i to może jeszcze
następne.
Dobra.
Dobra.
Dobra.
Dobra.
Proszę Państwa, znalazłam tutaj, jak widzicie,
pana Bartłomieja zadanie,
które zostało wysoko ocenione.
Więc
powtórzmy sobie, dlaczego
pan Bartek
dostał za to maksymalną
liczbę punktów i dla tych osób,
które nie dostały albo nie robiły
tego zadania, żeby tutaj pewne rzeczy
przypomnieć.
Tego typu zadanie pewnie też się pojawi
na egzaminie. W każdym razie jest duże
prawdopodobieństwo.
Mianowicie, narysuj fragment
diagramu klasy, relacje,
operacje wynikające z podanego
poniżej diagramu
segmentu.
Sekwencji.
Uzasadnij swoje rozwiązanie.
I mam tutaj diagram
sekwencji, w którym widzimy, że
jest tutaj jakiś obiekt
klasy X, jakiś obiekt
klasy Y, jakiś obiekt
klasy P. Tak? Tutaj mamy
czas, tak gdyby
tym prostokątem
czas aktywności tego obiektu,
tych obiektów pokazany
i komunikaty.
I teraz
przypomnimy sobie,
również znaczenie tych komunikatów.
Pamiętamy, że to jest
oś czasu, że czas biegnie
w kierunku dołu, tak? Czyli
tutaj czas rośnie. Tu jest
początkowy czas, tutaj jest późniejszy
czas. Pierwszy komunikat,
tak? To jest
od obiektu klasy Y
do obiektu
klasy X, on się nazywa A.
I jest to komunikat
asynchroniczny. Co znaczy,
że te obiekty mogą
pracować równolegle, tak?
Dalej. I teraz
co oznacza wysłanie takiego
komunikatu? To jest wysłanie
komunikatu, to jest
wykonanie,
ten komunikat jest operacją
w klasie,
w obiekcie klasy
odbierającej. Czyli to
znaczy, że w klasie X,
tutaj mam klasę X
i tutaj wystarczy, jak Państwo narysujecie
nawet odręcznie
prostokąt,
jest operacja
A, tak? Bo tak ten komunikat
się króciutko nazywał A.
Ona jest poprzedzona plusem.
Dlaczego? Dlatego, że
żeby obiekt klasy Y
mógł tą operację
wykonać, to musi być to operacja
publiczna. Operacje publiczne
są poprzedzone plusem.
Zwracam uwagę Państwa również
na umiejscowienie tych operacji,
prawda? Nie w tym pierwszym
prostokącie, bo co jest
w tym pierwszym prostokącie?
Tu jest nazwa klasy,
tutaj są atrybuty,
trzecia część tego
prostokąta to są operacje.
I to musicie Państwo
wiedzieć, czy mieć ściągawkę
na egzaminie z tego, żeby
nie wkładać mi tych operacji
tutaj zaraz po nazwie klasy,
bo ja się będę czepiać wtedy
i będę punkty, oczywiście
będzie pewnie zero punktów, bo powiem, bo
to są operacje, a nie
atrybuty. Tutaj
musimy wpisać,
jeżeli to atrybuty, o tych atrybutach
nic nie wiemy. Czyli istotne
jest umiejscowienie tych
operacji. Nazwa komunikatu
to jest operacja w klasie
odbierającej, czyli
w klasie X musi być A,
tak, mamy, i musi
być D, bo tu jeszcze mamy kolejny
komunikat wysłany do obiektu klasy
X. Teraz popatrzmy
na kolejny komunikat
B, który jest wysyłany
do klasy P, czyli w
klasie P mamy operację,
operację B, też poprzedzoną
plusem, bo musi
się ona, musi być ona
dostępna, musi być
ona dostępna.
I mamy jeszcze
komunikat C,
wysyłany do obiektu klasy
Y, czyli w Y musi być
operacja publiczna
C, taka
nazwa. Czyli pierwsza rzecz
to, żeśmy tutaj zanalizowali,
gdzie mają być operacje, w której
klasie, jak one się
nazywają i przypominam
Państwu, że muszą być to operacje
publiczne, żeby te
inne obiekty mogły je wykonać.
I to jest jak gdyby pierwszy
element, który trzeba w tym zadaniu
wykonać. Umiejscowienie operacji.
Druga rzecz, którą tu
trzeba zrobić, tak,
operacje. Druga
rzecz to są relacje.
Klasy już żeśmy zrobili, bo
jeżeli tu jest obiekt danej
klasy, tak, no to te klasy
muszą być pokazane. Zwracam
uwagę, obiekt klasy
to jest
dwukropek P, to znaczy,
że to jest jakiś obiekt,
nie podana nazwa, ale klasy
P. A nazwę
klas bez dwukropków, a więc
P, a nie dwukropek P. Y,
X. Czyli
mamy klasę X,
Y, P. Mamy umieszczone
operacje i teraz
jeszcze musimy wykombinować,
jakie muszą być relacje
pomiędzy tymi klasami.
I teraz przy tutaj
no właśnie
wymyślaniu, ustalaniu tych relacji,
to musimy wziąć pod uwagę,
już brać pod uwagę, jakie są
typy komunikatów. Czy komunikat
jest synchroniczny, czy
komunikat jest asynchroniczny.
I ile tych komunikatów
jest, jak one, prawda, tam
do siebie są wysyłane.
Tutaj w tym przykładzie mam
jeden komunikat synchroniczny.
Co znaczy
synchroniczny? To znaczy, że wysyłany
jest komunikat
i że
ten obiekt wysyłający
stoi, nie robi się
dalej, czeka, aż ta
operacja się zakończy i być
może czeka na jakiś wynik,
jaki ta operacja
dostarczy.
Więc tutaj
przy takiej czarnej
strzałce, która oznacza komunikat
asynchroniczny,
pomiędzy tymi klasami
musi być komunikacja
dwukierunkowa, bo te
rezultaty wykonania tej operacji
muszą być zwracane.
Jak pokazać, że to jest
dwukierunkowa relacja?
No to przypomnę, że to jest linia
nieskierowana w UML-u.
Czyli pomiędzy Y i P
mamy, tak jak tutaj Państwo widzicie,
asocjację dwukierunkową,
czyli linia ciągła
nieskierowana.
Teraz
analizujemy dalej.
Na przykład analizujemy
Y i X.
Tu mam komunikat, który idzie w jedną
stronę, tak? I ta strzałka
pokazuje
kierunek
wysyłania tego, a więc
jest to kierowane w kierunku
od Y do P.
I teraz patrzymy, czy tutaj
w dalszym przebiegu tych operacji,
czy nie ma jakiegoś komunikatu zwrotnego.
Być może
gdzieś dalej. Nie ma, tak?
Z tego między Y a X
rysujemy asocjację
skierowaną, asocjację
jednokierunkową.
Zachowujemy ten kierunek, jaki był
tutaj. Prawda? Zachowany jest
ten kierunek, jaki był tutaj.
Teraz została
jeszcze nam do zanalizowania,
czy jest jakaś relacja
pomiędzy X i pomiędzy P.
No więc patrzmy.
Tutaj jest komunikat asynchroniczny
z X do P.
Tak? Więc wyglądało,
jakby, że z X do P idzie tu
skierowany w tą stronę.
Ale widzimy, że
od P do X też idzie komunikat
asynchroniczny.
Czyli widzimy, że między X
i P, tak? Tu idzie w tą stronę,
tu idzie w tą stronę,
czyli widzimy, że jest
komunikacja
dwukierunkowa.
Dlatego tu jest
narysowana, pan Bartek narysował
asocjację
dwukierunkową, czyli
linia ciągła nieskierowana.
Czy to jest jasne teraz?
Tak, tak. Jeszcze szukam,
czego mogę spytać.
Jeżeli macie państwo jakiś
przykład własny,
tak? Ja zatrzymam
udostępnianie.
To możemy spróbować
teraz na czyimś przykładzie to zrobić,
na przykład.
Możemy spróbować...
Szukam...
A, bo tutaj było
dużo przykładów jakichś...
Zaraz spróbuję...
No jeśli
ktoś z państwa ma tam
jakieś coś do
spytania się czy pokazania, to proszę
szybko szukać, jeszcze mamy trochę
czasu.
Albo może ktoś, nie wiem, pamięta jakąś pracę domową, którą, bo ja tutaj, prawda, w Teamsach mam te wasze prace domowe, więc jeśli ktoś pamięta, że, nie wiem, tam na przykład dostał za mało punktów, a nie wie dlaczego tak mało dostał, to jak się przyzna, jak się nazywa, to możemy to odszukać i próbować wyjaśnić.
O, właśnie, bo ja
mam, miałem takie zadanie, właśnie sobie przypomniałem,
takiego innego typu, z tymi zamkami jakimiś tam...
Okej, chyba ten taki
diagram klas, tak?
Tak, tak, i ja właśnie
wtedy zamiast
zamiast prostokątów jako klasę dawałem, no to chyba owale dałem i tam pani mi wyzerowała całkowicie.
Tak jest, proszę państwa.
To dobrze, że pan poruszył ten temat.
UML
dziesiątki razy, setki razy.
Powtarzam, jest standardem.
Symbole graficzne mają określone
znaczenie.
Owal, czy takie jajo, to jest
use case.
Prostokąt to jest klasa.
Proszę państwa, są, czy w internecie,
czy w książkach, są
takie ściągawki z symbolami graficznymi.
Zróbcie sobie, nie wiem,
ksero tego, wydrukujcie sobie
taką stronę, czy odręcznie
sobie zróbcie taką ściągaweczkę
z tymi, żebyście w trakcie egzaminu,
kiedy dochodzą jeszcze jakieś emocje,
żebyście
no, spojrzeli na tą ściągawkę
z tymi symbolami graficznymi,
prawda, i użyli właściwego
elementu graficznego.
Bo to jest ogromna
różnica, czy to jest use case,
czy to jest klasa.
Więc tu pan dostał zero punktów,
a jeśli pan taki błąd zrobi na egzaminie,
to może pan dostać ujemne punkty.
Właśnie, a propos egzaminu, proszę państwa,
dam no część zadań,
większość zadań pewnie będzie
automatycznie oceniana,
ale jakieś mogą być właśnie tak jak to,
tego typu zadania, prawda,
takie, że ja będę potem to ręcznie sprawdzać
i trzeba będzie
no tam włożyć to swoje
rozwiązanie albo
to
no jeżeli mi jakieś
totalne bzdury tam zrobicie,
no to
to mogą być punkty ujemne.
Więc,
moja sugestia,
nie piszcie czegokolwiek w egzaminie.
Ja was zapewniam,
że ja to czytam.
I czytam,
jak to się mówi, ze zrozumieniem.
Więc
nie znoszę bajek
takich, które, więc
jeżeli nawet będą jakieś pytania takie,
na które trzeba będzie tekstem
odpowiedzieć, to
to ja wiem, że w waszej
szkole macie jakąś taką zdolność,
do takiego pisania
nawet poprawnych
składniowo długich zdań,
tylko nic z tych zdań nie wynika.
Więc ja niestety
nie lubię takich odpowiedzi
i jeżeli, to ja
oczekuję odpowiedzi konkretnych
i na temat,
a nie pisania bajek.
I teraz, jeżeli taka bajka
jest no taką dużą bajką,
to uwaga, można dostać punkty ujemne.
Czyli nie opłaca się pisać
czegokolwiek na egzaminie.
Podobnie, jeżeli będą
zadania
z wyborem, że jest
na przykład kilka, może być tak,
że jest powiedzmy pięć
odpowiedzi i z tych pięciu
odpowiedzi są dwie dobre,
a reszta nie.
Więc proszę Państwa,
nie opłaca się wam zaznaczać
czegokolwiek,
czy zaznaczać na hebił trafił,
dlatego, że
za błędną
odpowiedź będą punkty ujemne
i na przykład zaznaczycie jedną
odpowiedź dobrą,
jedną nie, no to
może nie być tych punktów wtedy.
Albo będzie tych punktów
na plus będzie mało, bo na przykład
będzie pięć punktów za dobrą odpowiedź,
tak,
a ujemna jest,
a ta niewłaściwa
odpowiedź może być
minusowymi punktami. Więc można
nawet jakiś minus dostać za odpowiedź
za zadanie. Także
nie opłaca się odpowiadać
czegokolwiek, nie opłaca się
zaznaczać odpowiedzi
na hebił trafił, bo
to, ja już miałam proszę Państwa
w waszej szkole przykłady, że
egzamin był, ktoś napisał na minus
jeden punkt.
No, więc
naprawdę zaznaczajcie to,
co wiecie, że jest dobre.
Czasu będzie dużo,
także tu nie ma z tym problemu.
Natomiast bardzo
możliwe, że nie będzie możliwości
wycofywania się do zadań
poprzednich.
Ja
przed egzaminem Państwu powiem
na przykład, które zadania wymagają
więcej czasu, żebyście
sobie mogli to, jak gdyby
dochodząc do tego zadania,
prawda, wiedzieć, że przy na przykład
zadaniu piątym,
tak,
musicie poświęcić trochę więcej czasu
na to zadanie.
Być może właśnie takie
zadania z jakimś otwartym takim
rysunkiem, czy czymś
tego typu, no, będę
lokować na końcu egzaminu,
tak, żeby tutaj
to nie,
prawda, nie blokować Wam tego
czasu rozwiązywania innych zadań.
Może być również zadanie
na przykład takie, że
no, ja napiszę parę zdań
i może trzeba będzie diagramiuska
narysować do tego. No i wtedy,
proszę Państwa, owale,
czy jaja są bardzo mile widziane,
bo wtedy wiadomo, że w diagramie
use case to to jest właśnie,
to to jest właśnie
ten przypadek użycia i
tego trzeba będzie użyć właściwie.
Dobra,
czy coś może macie jeszcze jakieś
pytania, czy dotyczące egzaminu?
Także
popatrzcie na te prace domowe,
które były, nawet jeśli ktoś,
prawda, nie zrobił tych
prac domowych, no to w
nagraniach z wykładów, tam myśmy je
omawiali potem, może zobaczyć,
jak powinno być to rozwiązanie
zrobione, spróbować sobie
samemu te
zadania zrobić może jeszcze
raz. Macie również
taki plik, który się nazywa
zadania i tam są przykładowe zadania
umieszczone, więc
popatrzcie, co tam jest, tam
są jakieś zadania
właśnie takie,
że diagram
klas trzeba
rysować. Proszę Państwa,
takiego diagramu klas
złożonego, jak tutaj było tam,
nie pamiętam, z tymi duchami zamkiem,
to raczej
w tym terminie pierwszym nie będzie,
to raczej, jeżeli to we wrześniowym,
bo tu miałabym za dużo do sprawdzenia,
natomiast
na pewno będziecie Państwo
poproszeni o
na przykład
narysowanie
takiego diagramu klas, ale
robiliśmy takie prostsze przykłady,
ze zdaniami.
Takie, czyli
były podane zdania,
zaraz, może jeszcze mi się uda
szybko pokazać jakieś,
tutaj,
o właśnie,
jakieś tutaj, prawda, trafiłam,
znowu Pan Bartek ma
na początku ze względu na
to, co mi się tutaj wyświetla,
więc jest na początku,
więc było jakieś
takie zdanie, prawda, że klient,
nie wiem, kupił miejscówkę na
określony pociąg,
jedna z możliwości,
pokazanie, że pociąg jest pewnym
zbiorem miejscówek, zawiera wiele
miejscówek, klient z miejscówką,
to nie jest jedyna dobra odpowiedź,
tutaj, tu było możliwości wiele,
proste zdania,
typu listonosz dostarcza przesyłkę,
wtedy nazwa... A ta Pani udostępnia coś?
O, o, momencik, dobra, dobra,
tak dobrze, że mnie Pan tutaj pilnuje,
już nie, właśnie,
nie udostępniłam,
już się robi,
dobra, teraz widać?
Teraz widać,
super, więc na przykład
listonosz dostarcza przesyłkę,
tu jest, no,
w zasadzie jedyna sensowna możliwość
pokazana, asocjacja
listonosz przesyłka,
wiele przesyłek może dostarczać,
to już wiemy, że tak powiem,
z naszej wiedzy ogólnej,
warto nazwać tą relację,
czyli dostarcza jako nazwa tej relacji,
bileter sprzedaje bilety,
ktoś tu widzi jakiś błąd?
Bilet, tu powinno być
bilet, a nie bilety,
powinno być
bilet, a nie bilety,
że wiele tych biletów to pokazujemy
właśnie tą gwiazdką,
czyli nazwy klas w liczbie pojedynczej,
prawda, jedna miejscówka,
nazwa,
nazwa relacji
i będziecie Państwo
pewnie poproszeni jeszcze
do, no, właśnie jakiegoś
uzasadnienia,
na przykład jeżeli zastosujecie
generalizację, dlaczego to jest
generalizacja, tak,
albo dlaczego to jest,
nie wiem, tak jak tutaj, dlaczego tutaj
jest użyta agregacja,
może być tutaj to również zupełnie
inaczej rozwiązane i jakieś
inne rozwiązania też były
pokazane.
Już, kochani, zaraz idziemy,
zaraz kończę.
To by było na tyle,
proszę Państwa,
więcej chyba już nie zdążycie,
nie zdążymy.
Czy takie zaokrąglone krawędzie
też można tutaj tak rysować?
Nie, nie, nie, nie rysować tego,
nie rysować zaokrąglone.
Tutaj, no, jak gdyby w tym
rozwiązaniu ja tego nie, tego się
wydałam, ale, ale
proszę się pilnować, żeby to były prostokąty,
a nie prostokąty z zaokrąglonymi
krawędziami, bo
prostokąty z zaokrąglonymi krawędziami
na przykład w niektórych
metodach obiektowych miały pewne
specjalne znaczenie,
więc, no, więc
nie należy tego
powielać.
Prostokąty z zaokrąglonymi
krawędziami to jest, proszę Państwa,
ktoś pamięta? Stan
UML-u, więc
nie chcę mieć mieszanych
diagramów zmian stanów z diagramami
klasy. Dobra?
Ja, proszę Państwa,
ustawię
spotkanie również na czas trwania
egzaminu,
żebyście, nie wiem, mogli
na przykład, nie wiem, ewentualnie
jakieś pytanie zadać, czy
no, czy żeby
była potencjalna możliwość,
ale jak gdyby nie ma obowiązku udziału
w tym spotkaniu, to ja będę,
żebyście wy ze mną mieli jakieś
kontakt w tym czasie.
No, także
musicie troszkę tam popatrzeć
na te zadania, które robiliście, zrobić
sobie ściągę, może się Wam wtedy
po prostu będzie Wam szybciej pewne rzeczy
i również,
no, opanować taki mechanizm, ale
nie miałam z tym nigdy problemu, że
rysujecie, nie wiem, tylko
no, proszę rysować, czy
jak pisać, to proszę, tam zwykle będzie
miejsce takie, żebyście mogli po prostu
na klawiaturze to napisać,
natomiast
rysunek, no, jeśli to będą
podstawowe, takie proste linie,
to pewnie też mamy takie mechanizmy,
nawet w InSperze
dopuszczone
i jeżeli można będzie włożyć
swój plik własny, no, to
przypomnijcie sobie, jak to się robi.
Tylko bardzo proszę też jakoś
starać się ten rysunek na kartce
robić, bo może być
to rysunek odręczny, jak najbardziej,
potem, nie wiem, robić zdjęcie na przykład
i włożyć to zdjęcie,
no, żeby to było czytelne.
No i życzę powodzenia,
mam nadzieję, że wszystko się
uda jakoś dobrze,
no, ale trochę musicie się,
to nie jest, proszę Państwa, egzamin
taki, że jest tylko 41
punktów do zdobycia, więc
stosunkowo na 100 możliwych, więc
stosunkowo łatwo, ale jednak
pewną wiedzą musicie się wykazać.
No i jeszcze raz
przypominam, nie znakować
byle czego tylko.
Jak nie wiecie, to lepiej nic
nie zaznaczać, niż
niż na chybiu
trafił.
Zamykam w takim razie nagrywanie.
